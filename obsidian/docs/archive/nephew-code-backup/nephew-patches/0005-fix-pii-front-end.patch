From 6c4cd5010d4b42a2bf2d945eb1624f997791a3a8 Mon Sep 17 00:00:00 2001
From: GolferGeek <golfergeek@gmail.com>
Date: Thu, 11 Sep 2025 14:25:23 -0500
Subject: [PATCH 5/5] fix: pii front end

---
 apps/api/PII_MIGRATION_GUIDE.md               |  212 ++
 .../actual/finance/metrics/agent-function.ts  |   17 +-
 .../typescript/function-agent-base.service.ts |   21 +-
 apps/api/src/app.service.ts                   |    5 +-
 apps/api/src/auth/guards/jwt-auth.guard.ts    |    7 +-
 .../types/simplified-pii-metadata.types.ts    |   85 +
 .../common/utils/pii-metadata-converter.ts    |  116 +
 .../src/config/model-configuration.service.ts |   65 +-
 .../centralized-routing-simplified.service.ts |  169 ++
 .../llms/data-sanitization.service.spec.ts    |  688 ------
 .../api/src/llms/data-sanitization.service.ts |  795 -------
 apps/api/src/llms/llm.controller.ts           |   17 +-
 apps/api/src/llms/llm.module.ts               |    6 +-
 apps/api/src/llms/llm.service.ts              |  151 +-
 apps/api/src/llms/llm.service.ts.backup       | 2004 -----------------
 apps/api/src/llms/pii-pseudonym-e2e.spec.ts   |  335 +++
 ...sanitization-management.controller.spec.ts |  700 ------
 .../sanitization-management.controller.ts     | 1383 ------------
 apps/api/src/llms/secret-redaction.service.ts |   12 +
 .../src/llms/services/openai-llm.service.ts   |   41 +-
 .../services/supabase/supabase-mcp.service.ts |    9 +-
 .../src/mcp/services/supabase/supabase.mcp.ts |   60 +-
 .../api/src/services/pii-simplified.module.ts |   34 +
 .../src/services/pii-simplified.service.ts    |  117 +
 .../src/websocket/task-progress.gateway.ts    |    4 +
 .../components/Admin/LLMUsageDetailModal.vue  |  564 +++++
 apps/web/src/components/AgentTaskItem.vue     |   60 +-
 .../src/components/admin/LlmUsageTable.vue    |   68 +-
 apps/web/src/services/llmMonitoringService.ts |   13 +
 apps/web/src/services/pseudonymService.ts     |   17 +
 apps/web/src/stores/agentChatStore/store.ts   |   58 +
 apps/web/src/stores/llmMonitoringStore.ts     |   16 +-
 apps/web/src/stores/pseudonymMappingsStore.ts |   22 +-
 apps/web/src/utils/pii-converter.ts           |   87 +
 package-lock.json                             |   63 +-
 package.json                                  |    1 +
 scripts/setup-pii-dictionary.sh               |  144 ++
 scripts/setup-pii-test-data.sh                |  167 ++
 scripts/test-llm-pii-flow.sh                  |  112 +
 scripts/test-pii-pseudonym.sh                 |   45 +
 scripts/wt-add.sh                             |   46 +
 start-dev-local.sh                            |   31 +-
 42 files changed, 2881 insertions(+), 5686 deletions(-)
 create mode 100644 apps/api/PII_MIGRATION_GUIDE.md
 create mode 100644 apps/api/src/common/types/simplified-pii-metadata.types.ts
 create mode 100644 apps/api/src/common/utils/pii-metadata-converter.ts
 create mode 100644 apps/api/src/llms/centralized-routing-simplified.service.ts
 delete mode 100644 apps/api/src/llms/data-sanitization.service.spec.ts
 delete mode 100644 apps/api/src/llms/data-sanitization.service.ts
 delete mode 100644 apps/api/src/llms/llm.service.ts.backup
 create mode 100644 apps/api/src/llms/pii-pseudonym-e2e.spec.ts
 delete mode 100644 apps/api/src/llms/sanitization-management.controller.spec.ts
 delete mode 100644 apps/api/src/llms/sanitization-management.controller.ts
 create mode 100644 apps/api/src/services/pii-simplified.module.ts
 create mode 100644 apps/api/src/services/pii-simplified.service.ts
 create mode 100644 apps/web/src/components/Admin/LLMUsageDetailModal.vue
 create mode 100644 apps/web/src/utils/pii-converter.ts
 create mode 100755 scripts/setup-pii-dictionary.sh
 create mode 100755 scripts/setup-pii-test-data.sh
 create mode 100755 scripts/test-llm-pii-flow.sh
 create mode 100755 scripts/test-pii-pseudonym.sh
 create mode 100755 scripts/wt-add.sh

diff --git a/apps/api/PII_MIGRATION_GUIDE.md b/apps/api/PII_MIGRATION_GUIDE.md
new file mode 100644
index 0000000..568b69a
--- /dev/null
+++ b/apps/api/PII_MIGRATION_GUIDE.md
@@ -0,0 +1,212 @@
+# PII System Migration Guide
+
+## Overview
+
+We're simplifying the PII system from a complex, nested structure to a clean, simple one. This guide shows how to migrate existing code.
+
+## Key Changes
+
+### Old Complex Structure
+```typescript
+PIIProcessingMetadata {
+  piiDetected: boolean;
+  showstopperDetected: boolean;
+  detectionResults: {
+    totalMatches: number;
+    flaggedMatches: PIIMatch[];
+    showstopperMatches?: PIIMatch[];
+    dataTypesSummary: Record<string, DataTypeSummary>;
+    severityBreakdown: SeverityBreakdown;
+  };
+  policyDecision: PolicyDecision;
+  pseudonymInstructions?: PseudonymInstructions;
+  pseudonymResults?: PseudonymResults;
+  userMessage: UserMessage;
+  processingFlow: ProcessingFlow;
+  processingSteps: string[];
+  timestamps: ProcessingTimestamps;
+}
+```
+
+### New Simple Structure
+```typescript
+SimplifiedPIIMetadata {
+  flags: PIIFlag[];           // Pattern-detected PII
+  pseudonyms: PIIPseudonym[]; // Dictionary-replaced items
+  flagCount: number;
+  pseudonymCount: number;
+  blocked?: boolean;
+  blockingReason?: string;
+}
+```
+
+## Migration Examples
+
+### Before: Complex Routing Service
+```typescript
+// OLD - Complex with multiple PII checks
+async route(prompt: string, options: any) {
+  // Check showstoppers
+  const piiResult = await this.piiService.checkPolicy(prompt, options);
+  if (piiResult.metadata.showstopperDetected) {
+    return { blocked: true, piiMetadata: piiResult.metadata };
+  }
+  
+  // Apply dictionary pseudonymization separately
+  const pseudonymResult = await this.dictionaryService.pseudonymizeText(prompt);
+  
+  // Merge complex metadata
+  const metadata = {
+    ...piiResult.metadata,
+    pseudonymInstructions: { /* complex */ },
+    pseudonymResults: { /* complex */ }
+  };
+  
+  return { provider, model, piiMetadata: metadata };
+}
+```
+
+### After: Simple Routing Service
+```typescript
+// NEW - Single clean call
+async route(prompt: string, options: any) {
+  // Everything in one call
+  const { processedText, metadata, dictionaryMappings } = 
+    await this.piiService.processPII(prompt, options);
+  
+  if (metadata.blocked) {
+    return { blocked: true, piiMetadata: metadata };
+  }
+  
+  return { 
+    provider, 
+    model, 
+    piiMetadata: metadata,
+    dictionaryMappings // For reversal later
+  };
+}
+```
+
+### Before: Complex LLM Service
+```typescript
+// OLD - Multiple PII processing steps
+async generateResponse(prompt: string) {
+  // Check PII policy
+  const piiCheck = await this.piiService.checkPolicy(prompt);
+  
+  // Apply dictionary separately
+  const dictResult = await this.dictionaryService.pseudonymizeText(prompt);
+  
+  // Complex metadata merging
+  const piiMetadata = {
+    ...piiCheck.metadata,
+    pseudonymsApplied: dictResult.mappings.map(/* transform */),
+    // ... lots of complex nesting
+  };
+  
+  // Send to LLM
+  const response = await llm.invoke(processedPrompt);
+  
+  // Reverse pseudonyms
+  const reversed = await this.dictionaryService.reversePseudonyms(response);
+  
+  return { content: reversed, piiMetadata };
+}
+```
+
+### After: Simple LLM Service
+```typescript
+// NEW - Clean pass-through
+async generateResponse(prompt: string, routingDecision: any) {
+  // PII already processed by routing
+  const { piiMetadata, dictionaryMappings } = routingDecision;
+  
+  // Send to LLM (text already pseudonymized if needed)
+  const response = await llm.invoke(prompt);
+  
+  // Reverse if needed
+  if (dictionaryMappings?.length > 0) {
+    const { originalText } = await this.piiService.reversePseudonyms(
+      response, 
+      dictionaryMappings
+    );
+    return { content: originalText, piiMetadata };
+  }
+  
+  return { content: response, piiMetadata };
+}
+```
+
+### Before: Agent Getting PII Counts
+```typescript
+// OLD - Navigate complex structure
+const flagCount = 
+  metadata?.detectionResults?.flaggedMatches?.length || 
+  metadata?.detectionResults?.totalMatches || 0;
+
+const pseudonymCount = 
+  metadata?.pseudonymResults?.processedMatches?.length ||
+  metadata?.pseudonymResults?.mappingsCount ||
+  metadata?.pseudonymInstructions?.targetMatches?.length || 0;
+```
+
+### After: Agent Getting PII Counts
+```typescript
+// NEW - Direct access
+const flagCount = metadata?.flagCount || 0;
+const pseudonymCount = metadata?.pseudonymCount || 0;
+```
+
+## Step-by-Step Migration
+
+1. **Install Simplified Module**
+   ```typescript
+   import { SimplifiedPIIModule } from './services/pii-simplified.module';
+   
+   @Module({
+     imports: [SimplifiedPIIModule],
+     // ...
+   })
+   ```
+
+2. **Update Service Injection**
+   ```typescript
+   // OLD
+   constructor(
+     private piiService: PIIService,
+     private dictionaryService: DictionaryPseudonymizerService,
+     private centralizedRouting: CentralizedRoutingService
+   ) {}
+   
+   // NEW
+   constructor(
+     private piiService: SimplifiedPIIService,
+     private routing: SimplifiedCentralizedRoutingService
+   ) {}
+   ```
+
+3. **Update Method Calls**
+   - Replace `piiService.checkPolicy()` with `piiService.processPII()`
+   - Remove separate `dictionaryService.pseudonymizeText()` calls
+   - Use `metadata.flags` instead of `metadata.detectionResults.flaggedMatches`
+   - Use `metadata.pseudonyms` instead of complex pseudonym structures
+
+4. **Update Frontend**
+   - Use `simplifiedPii` field in message metadata
+   - Direct access to `flagCount` and `pseudonymCount`
+
+## Benefits
+
+1. **Single Responsibility**: Each service does one thing
+2. **Clear Data Flow**: PII processing happens once at routing
+3. **Simple Structure**: No nested objects to navigate
+4. **Easy Testing**: Simple in/out for each service
+5. **Maintainable**: Easy to understand and modify
+
+## Rollback Plan
+
+Both systems can coexist during migration:
+- Legacy services remain unchanged
+- New simplified services available via `SimplifiedPIIModule`
+- Frontend supports both metadata formats
+- Gradual migration of services
\ No newline at end of file
diff --git a/apps/api/src/agents/actual/finance/metrics/agent-function.ts b/apps/api/src/agents/actual/finance/metrics/agent-function.ts
index d194c2f..c01ea9b 100644
--- a/apps/api/src/agents/actual/finance/metrics/agent-function.ts
+++ b/apps/api/src/agents/actual/finance/metrics/agent-function.ts
@@ -108,8 +108,9 @@ Respond with JSON only:
       analysisPrompt,
       {
         temperature: 0.1,
-        provider: metadata?.providerName,
-        modelName: metadata?.modelName,
+        // Use unified keys; prefer llmSelection passed by UI, then metadata
+        providerName: (params as any)?.llmSelection?.providerName || metadata?.providerName,
+        modelName: (params as any)?.llmSelection?.modelName || metadata?.modelName,
         maxTokens: 1000,
         callerType: 'agent',
         callerName: metadata?.agentName || 'metrics-agent',
@@ -175,9 +176,13 @@ Respond with JSON only:
     
     try {
       // Step 3.1: Generate SQL using MCP client
+      // Heuristic: if the user asks "how many X" or "count X", steer the NL query toward COUNT(*)
+      // Pure LLM-driven SQL generation using MCP, guided only by schema context
+      const nlQuery = userMessage;
+      const schemaTables = availableTables;
       const sqlGenResponse = await mcpService.generateSQL({
-        natural_language_query: userMessage,
-        schema_tables: availableTables,
+        natural_language_query: nlQuery,
+        schema_tables: schemaTables,
         max_rows: 100,
       });
 
@@ -349,8 +354,8 @@ ${
       reportPrompt,
       {
         temperature: 0.3,
-        provider: metadata?.providerName,
-        modelName: metadata?.modelName,
+        providerName: (params as any)?.llmSelection?.providerName || metadata?.providerName,
+        modelName: (params as any)?.llmSelection?.modelName || metadata?.modelName,
         maxTokens: 4000,
         callerType: 'agent',
         callerName: metadata?.agentName || 'metrics-agent',
diff --git a/apps/api/src/agents/base/implementations/base-services/function/typescript/function-agent-base.service.ts b/apps/api/src/agents/base/implementations/base-services/function/typescript/function-agent-base.service.ts
index bb1287a..7ba19e9 100644
--- a/apps/api/src/agents/base/implementations/base-services/function/typescript/function-agent-base.service.ts
+++ b/apps/api/src/agents/base/implementations/base-services/function/typescript/function-agent-base.service.ts
@@ -116,10 +116,23 @@ export class FunctionAgentBaseService extends A2AAgentBaseService {
           // Merge user preferences with function options
           const mergedOptions = {
             ...options,
-            providerName: params.providerName || options?.providerName,
-            modelName: params.modelName || options?.modelName,
-            temperature: params.temperature ?? options?.temperature,
-            maxTokens: params.maxTokens || options?.maxTokens,
+            // Accept either flat params or nested llmSelection
+            providerName:
+              (params as any)?.providerName ||
+              (params as any)?.llmSelection?.providerName ||
+              options?.providerName,
+            modelName:
+              (params as any)?.modelName ||
+              (params as any)?.llmSelection?.modelName ||
+              options?.modelName,
+            temperature:
+              (params as any)?.temperature ??
+              (params as any)?.llmSelection?.temperature ??
+              options?.temperature,
+            maxTokens:
+              (params as any)?.maxTokens ||
+              (params as any)?.llmSelection?.maxTokens ||
+              options?.maxTokens,
             cidafmOptions: params.cidafmOptions || options?.cidafmOptions,
             authToken: params.authToken || options?.authToken,
             sessionId: params.sessionId || options?.sessionId,
diff --git a/apps/api/src/app.service.ts b/apps/api/src/app.service.ts
index d164190..50cb4dc 100644
--- a/apps/api/src/app.service.ts
+++ b/apps/api/src/app.service.ts
@@ -165,7 +165,10 @@ export class AppService implements OnModuleInit {
 
         return {
           id: this.agentDiscovery.generateAgentId(agent.name, agent.path),
-          name: agentCard?.name || agent.name,
+          // Preserve the discovered machine-friendly name so frontend matching works
+          name: agent.name,
+          // Expose human-friendly display name separately when available
+          displayName: agentCard?.name || agent.name,
           type: agent.type,
           description:
             agentCard?.description ||
diff --git a/apps/api/src/auth/guards/jwt-auth.guard.ts b/apps/api/src/auth/guards/jwt-auth.guard.ts
index 100f448..d93fd33 100644
--- a/apps/api/src/auth/guards/jwt-auth.guard.ts
+++ b/apps/api/src/auth/guards/jwt-auth.guard.ts
@@ -36,10 +36,13 @@ export class JwtAuthGuard implements CanActivate {
     const configuredTestKey = process.env.TEST_API_SECRET_KEY;
 
     if (configuredTestKey && testApiKey && testApiKey === configuredTestKey) {
+      // Prefer configured test user from environment to satisfy DB FKs in development
+      const devUserId = process.env.SUPABASE_TEST_USERID || '00000000-0000-0000-0000-000000000001';
+      const devEmail = process.env.SUPABASE_TEST_USER || 'test_api_key_user@example.com';
 
       (request as any).user = {
-        id: '00000000-0000-0000-0000-000000000001',
-        email: 'test_api_key_user@example.com',
+        id: devUserId,
+        email: devEmail,
         aud: 'authenticated',
         role: 'authenticated',
         appMetadata: { provider: 'api_key', providers: ['api_key'] },
diff --git a/apps/api/src/common/types/simplified-pii-metadata.types.ts b/apps/api/src/common/types/simplified-pii-metadata.types.ts
new file mode 100644
index 0000000..f15d6b0
--- /dev/null
+++ b/apps/api/src/common/types/simplified-pii-metadata.types.ts
@@ -0,0 +1,85 @@
+/**
+ * Simplified PII Metadata Types
+ * 
+ * Clean, minimal structure for PII tracking without legacy complexity
+ */
+
+/**
+ * Represents a flagged PII item detected by pattern matching
+ */
+export interface PIIFlag {
+  value: string;           // The actual PII value detected
+  dataType: string;        // Type of PII (email, phone, ssn, name, etc.)
+  severity: 'info' | 'warning' | 'showstopper';
+  confidence: number;      // Detection confidence (0.0 to 1.0)
+  pattern: string;         // Pattern that matched
+}
+
+/**
+ * Represents a pseudonymized item replaced by dictionary
+ */
+export interface PIIPseudonym {
+  original: string;        // Original value
+  pseudonym: string;       // Replacement pseudonym
+  dataType: string;        // Type of data
+  conversationId?: string; // For tracking reversals
+}
+
+/**
+ * Simplified PII metadata structure
+ * This is all we need - flags and pseudonyms
+ */
+export interface SimplifiedPIIMetadata {
+  // Pattern-detected PII items (flagged for awareness)
+  flags: PIIFlag[];
+  
+  // Dictionary-replaced items (actually pseudonymized)
+  pseudonyms: PIIPseudonym[];
+  
+  // Simple counts for quick access
+  flagCount: number;
+  pseudonymCount: number;
+  
+  // Optional: Track if there were showstoppers that blocked the request
+  blocked?: boolean;
+  blockingReason?: string;
+}
+
+/**
+ * Helper function to create empty PII metadata
+ */
+export function createEmptyPIIMetadata(): SimplifiedPIIMetadata {
+  return {
+    flags: [],
+    pseudonyms: [],
+    flagCount: 0,
+    pseudonymCount: 0
+  };
+}
+
+/**
+ * Helper function to merge PII metadata from multiple sources
+ */
+export function mergePIIMetadata(
+  ...sources: Partial<SimplifiedPIIMetadata>[]
+): SimplifiedPIIMetadata {
+  const merged: SimplifiedPIIMetadata = createEmptyPIIMetadata();
+  
+  for (const source of sources) {
+    if (source.flags) {
+      merged.flags.push(...source.flags);
+    }
+    if (source.pseudonyms) {
+      merged.pseudonyms.push(...source.pseudonyms);
+    }
+    if (source.blocked) {
+      merged.blocked = true;
+      merged.blockingReason = source.blockingReason || merged.blockingReason;
+    }
+  }
+  
+  merged.flagCount = merged.flags.length;
+  merged.pseudonymCount = merged.pseudonyms.length;
+  
+  return merged;
+}
\ No newline at end of file
diff --git a/apps/api/src/common/utils/pii-metadata-converter.ts b/apps/api/src/common/utils/pii-metadata-converter.ts
new file mode 100644
index 0000000..74dea55
--- /dev/null
+++ b/apps/api/src/common/utils/pii-metadata-converter.ts
@@ -0,0 +1,116 @@
+/**
+ * Converter utility to transform legacy PII metadata to simplified structure
+ */
+
+import { PIIProcessingMetadata } from '../types/pii-metadata.types';
+import { SimplifiedPIIMetadata, PIIFlag, PIIPseudonym } from '../types/simplified-pii-metadata.types';
+
+/**
+ * Converts legacy PIIProcessingMetadata to SimplifiedPIIMetadata
+ */
+export function convertToSimplifiedPIIMetadata(
+  legacy: PIIProcessingMetadata | undefined | null
+): SimplifiedPIIMetadata {
+  if (!legacy) {
+    return {
+      flags: [],
+      pseudonyms: [],
+      flagCount: 0,
+      pseudonymCount: 0
+    };
+  }
+
+  // Extract flags from detection results
+  const flags: PIIFlag[] = [];
+  if (legacy.detectionResults?.flaggedMatches) {
+    for (const match of legacy.detectionResults.flaggedMatches) {
+      flags.push({
+        value: match.value,
+        dataType: match.dataType,
+        severity: match.severity,
+        confidence: match.confidence,
+        pattern: match.pattern
+      });
+    }
+  }
+
+  // Extract pseudonyms from pseudonymResults or pseudonymInstructions
+  const pseudonyms: PIIPseudonym[] = [];
+  
+  // Check pseudonymResults first (actual applied pseudonyms)
+  if (legacy.pseudonymResults?.processedMatches) {
+    for (const match of legacy.pseudonymResults.processedMatches) {
+      if (match.pseudonym) {
+        pseudonyms.push({
+          original: match.value,
+          pseudonym: match.pseudonym,
+          dataType: match.dataType
+        });
+      }
+    }
+  }
+  
+  // If no results, check instructions (intended pseudonyms)
+  else if (legacy.pseudonymInstructions?.targetMatches) {
+    for (const match of legacy.pseudonymInstructions.targetMatches) {
+      if (match.pseudonym) {
+        pseudonyms.push({
+          original: match.value,
+          pseudonym: match.pseudonym,
+          dataType: match.dataType
+        });
+      }
+    }
+  }
+
+  // Check if request was blocked
+  const blocked = legacy.showstopperDetected || legacy.policyDecision?.blocked || false;
+  const blockingReason = legacy.policyDecision?.blockingReason || 
+                         (legacy.showstopperDetected ? 'showstopper-pii' : undefined);
+
+  return {
+    flags,
+    pseudonyms,
+    flagCount: flags.length,
+    pseudonymCount: pseudonyms.length,
+    blocked,
+    blockingReason
+  };
+}
+
+/**
+ * Converts dictionary pseudonymization results to simplified format
+ */
+export function convertDictionaryToSimplified(
+  mappings: Array<{ originalValue: string; pseudonym: string; dataType: string }>
+): SimplifiedPIIMetadata {
+  const pseudonyms: PIIPseudonym[] = mappings.map(m => ({
+    original: m.originalValue,
+    pseudonym: m.pseudonym,
+    dataType: m.dataType
+  }));
+
+  return {
+    flags: [], // Dictionary doesn't create flags
+    pseudonyms,
+    flagCount: 0,
+    pseudonymCount: pseudonyms.length
+  };
+}
+
+/**
+ * Merges PII metadata from pattern detection and dictionary pseudonymization
+ */
+export function mergePatternAndDictionary(
+  patternMetadata: SimplifiedPIIMetadata,
+  dictionaryMetadata: SimplifiedPIIMetadata
+): SimplifiedPIIMetadata {
+  return {
+    flags: [...patternMetadata.flags],
+    pseudonyms: [...patternMetadata.pseudonyms, ...dictionaryMetadata.pseudonyms],
+    flagCount: patternMetadata.flagCount,
+    pseudonymCount: patternMetadata.pseudonymCount + dictionaryMetadata.pseudonymCount,
+    blocked: patternMetadata.blocked || dictionaryMetadata.blocked,
+    blockingReason: patternMetadata.blockingReason || dictionaryMetadata.blockingReason
+  };
+}
\ No newline at end of file
diff --git a/apps/api/src/config/model-configuration.service.ts b/apps/api/src/config/model-configuration.service.ts
index 1ecad6b..c9d909b 100644
--- a/apps/api/src/config/model-configuration.service.ts
+++ b/apps/api/src/config/model-configuration.service.ts
@@ -29,17 +29,33 @@ export interface SystemModelConfiguration {
 export class ModelConfigurationService {
   private readonly config?: SystemModelConfiguration;
   private readonly globalDefault?: ModelConfiguration;
-  private readonly mode: 'system' | 'global';
-
-  constructor(configOrGlobal?: SystemModelConfiguration | ModelConfiguration) {
-    // Support either a full system configuration or a single global default per deployment
-    if (configOrGlobal && 'provider' in (configOrGlobal as any)) {
-      this.mode = 'global';
-      this.globalDefault = configOrGlobal as ModelConfiguration;
-    } else {
-      this.mode = 'system';
-      this.config = (configOrGlobal as SystemModelConfiguration) ?? { agents: {}, environmentDefaults: {} as any };
+  private readonly globalLocalOnly?: ModelConfiguration;
+  private readonly mode: 'system' | 'global' | 'global_dual';
+
+  constructor(
+    configOrGlobal?: SystemModelConfiguration | ModelConfiguration | { default: ModelConfiguration; localOnly?: ModelConfiguration },
+  ) {
+    // Accept:
+    // - System model config (agents + environmentDefaults)
+    // - Global single default (provider/model)
+    // - Global dual config { default, localOnly }
+    if (configOrGlobal && typeof configOrGlobal === 'object') {
+      const anyCfg = configOrGlobal as any;
+      if ('default' in anyCfg && !('provider' in anyCfg)) {
+        this.mode = 'global_dual';
+        this.globalDefault = anyCfg.default as ModelConfiguration;
+        this.globalLocalOnly = anyCfg.localOnly as ModelConfiguration | undefined;
+        return;
+      }
+      if ('provider' in anyCfg) {
+        this.mode = 'global';
+        this.globalDefault = anyCfg as ModelConfiguration;
+        return;
+      }
     }
+
+    this.mode = 'system';
+    this.config = (configOrGlobal as SystemModelConfiguration) ?? { agents: {}, environmentDefaults: {} as any };
   }
 
   /**
@@ -53,6 +69,16 @@ export class ModelConfigurationService {
       this.assertModel(this.globalDefault, 'global default');
       return;
     }
+    if (this.mode === 'global_dual') {
+      if (!this.globalDefault) {
+        throw new Error('ModelConfigurationService: global dual configuration requires a default model');
+      }
+      this.assertModel(this.globalDefault, 'global dual default');
+      if (this.globalLocalOnly) {
+        this.assertModel(this.globalLocalOnly, 'global dual localOnly');
+      }
+      return;
+    }
     // system mode
     if (!this.config) {
       throw new Error('ModelConfigurationService: system configuration is required');
@@ -125,11 +151,21 @@ export class ModelConfigurationService {
    * Get the single global default when running in global mode (no NODE_ENV required)
    */
   public getGlobalDefault(): ModelConfiguration {
-    if (this.mode !== 'global' || !this.globalDefault) {
-      throw new Error('ModelConfigurationService: global default not configured');
+    if ((this.mode === 'global' || this.mode === 'global_dual') && this.globalDefault) {
+      this.assertModel(this.globalDefault, 'global default');
+      return this.globalDefault;
     }
-    this.assertModel(this.globalDefault, 'global default');
-    return this.globalDefault;
+    throw new Error('ModelConfigurationService: global default not configured');
+  }
+
+  /**
+   * Get the global local-only default if configured
+   */
+  public getGlobalLocalOnly(): ModelConfiguration | undefined {
+    if (this.mode === 'global_dual') {
+      return this.globalLocalOnly;
+    }
+    return undefined;
   }
 
   /** Indicate current configuration mode */
@@ -158,4 +194,3 @@ export class ModelConfigurationService {
   }
 }
 
-
diff --git a/apps/api/src/llms/centralized-routing-simplified.service.ts b/apps/api/src/llms/centralized-routing-simplified.service.ts
new file mode 100644
index 0000000..dfdbeb0
--- /dev/null
+++ b/apps/api/src/llms/centralized-routing-simplified.service.ts
@@ -0,0 +1,169 @@
+/**
+ * Simplified Centralized Routing Service
+ * 
+ * Clean routing logic that:
+ * 1. Checks for showstoppers (blocks early)
+ * 2. Selects appropriate provider/model
+ * 3. Passes metadata through without modification
+ */
+
+import { Injectable, Logger } from '@nestjs/common';
+import { SimplifiedPIIService } from '../services/pii-simplified.service';
+import { SimplifiedPIIMetadata } from '../common/types/simplified-pii-metadata.types';
+import { FeatureFlagService } from '../config/feature-flag.service';
+import { SovereignPolicyService } from '../config/sovereign-policy.service';
+
+export interface SimplifiedRoutingDecision {
+  provider: string;
+  model: string;
+  isLocal: boolean;
+  shouldRoute: boolean;
+  blockingReason?: string;
+  piiMetadata?: SimplifiedPIIMetadata;
+  dictionaryMappings?: any[]; // For reversal later
+}
+
+@Injectable()
+export class SimplifiedCentralizedRoutingService {
+  private readonly logger = new Logger(SimplifiedCentralizedRoutingService.name);
+
+  constructor(
+    private readonly piiService: SimplifiedPIIService,
+    private readonly featureFlagService: FeatureFlagService,
+    private readonly sovereignPolicyService: SovereignPolicyService,
+  ) {}
+
+  /**
+   * Main routing decision - simple and clean
+   */
+  async route(
+    prompt: string,
+    options: {
+      systemPrompt?: string;
+      provider?: string;
+      model?: string;
+      conversationId?: string;
+      userId?: string;
+    } = {}
+  ): Promise<SimplifiedRoutingDecision> {
+    try {
+      // Step 1: Quick showstopper check
+      const hasShowstoppers = await this.piiService.hasShowstoppers(prompt);
+      if (hasShowstoppers) {
+        this.logger.warn('üõë [ROUTING] Showstopper PII detected - blocking request');
+        
+        // Get full PII details for metadata
+        const { metadata } = await this.piiService.processPII(prompt, {
+          provider: options.provider,
+          conversationId: options.conversationId,
+          applyDictionary: false // Don't apply dictionary for blocked requests
+        });
+
+        return {
+          provider: 'blocked',
+          model: 'showstopper-pii',
+          isLocal: true,
+          shouldRoute: false,
+          blockingReason: 'showstopper-pii',
+          piiMetadata: metadata
+        };
+      }
+
+      // Step 2: Determine provider/model
+      let provider = options.provider || process.env.DEFAULT_PROVIDER || 'openai';
+      let model = options.model || this.getDefaultModel(provider);
+      
+      // Check sovereign mode
+      const sovereignMode = await this.featureFlagService.isEnabled(
+        'sovereign-mode',
+        { userId: options.userId }
+      );
+
+      if (sovereignMode) {
+        // Force local provider in sovereign mode
+        provider = 'ollama';
+        model = 'llama3.2:latest';
+        this.logger.debug('üîí [ROUTING] Sovereign mode active - using local model');
+      }
+
+      const isLocal = provider.toLowerCase() === 'ollama' || 
+                     provider.toLowerCase() === 'local';
+
+      // Step 3: Process PII (flags ONLY - no pseudonymization here)
+      const { metadata } = await this.piiService.processPII(prompt, {
+        provider,
+        conversationId: options.conversationId
+      });
+
+      this.logger.debug(`‚úÖ [ROUTING] Decision: ${provider}/${model} (local: ${isLocal})`);
+      this.logger.debug(`‚úÖ [ROUTING] PII: ${metadata.flagCount} flags detected`);
+
+      return {
+        provider,
+        model,
+        isLocal,
+        shouldRoute: true,
+        piiMetadata: metadata,
+        dictionaryMappings: [] // LLM service will handle this
+      };
+
+    } catch (error) {
+      this.logger.error(`‚ùå [ROUTING] Error: ${error instanceof Error ? error.message : String(error)}`);
+      
+      // On error, use fallback provider
+      return {
+        provider: 'ollama',
+        model: 'llama3.2:latest',
+        isLocal: true,
+        shouldRoute: true,
+        piiMetadata: {
+          flags: [],
+          pseudonyms: [],
+          flagCount: 0,
+          pseudonymCount: 0
+        }
+      };
+    }
+  }
+
+  /**
+   * Process agent response - just reverse pseudonyms
+   */
+  async processResponse(
+    response: string,
+    dictionaryMappings?: any[]
+  ): Promise<{
+    processedResponse: string;
+    reversalCount: number;
+  }> {
+    if (!dictionaryMappings || dictionaryMappings.length === 0) {
+      return {
+        processedResponse: response,
+        reversalCount: 0
+      };
+    }
+
+    const result = await this.piiService.reversePseudonyms(response, dictionaryMappings);
+    this.logger.debug(`üîÑ [ROUTING] Reversed ${result.reversalCount} pseudonyms in response`);
+
+    return {
+      processedResponse: result.originalText,
+      reversalCount: result.reversalCount
+    };
+  }
+
+  /**
+   * Get default model for provider
+   */
+  private getDefaultModel(provider: string): string {
+    const defaults: Record<string, string> = {
+      openai: 'gpt-4-turbo-preview',
+      anthropic: 'claude-3-opus-20240229',
+      google: 'gemini-pro',
+      ollama: 'llama3.2:latest',
+      groq: 'llama-3.1-70b-versatile'
+    };
+
+    return defaults[provider.toLowerCase()] || 'gpt-4-turbo-preview';
+  }
+}
\ No newline at end of file
diff --git a/apps/api/src/llms/data-sanitization.service.spec.ts b/apps/api/src/llms/data-sanitization.service.spec.ts
deleted file mode 100644
index 56232a8..0000000
--- a/apps/api/src/llms/data-sanitization.service.spec.ts
+++ /dev/null
@@ -1,688 +0,0 @@
-import { Test, TestingModule } from '@nestjs/testing';
-import { DataSanitizationService } from './data-sanitization.service';
-import { SecretRedactionService } from './secret-redaction.service';
-import { PseudonymizationService } from './pseudonymization.service';
-
-describe('DataSanitizationService', () => {
-  let service: DataSanitizationService;
-  let mockSecretRedactionService: jest.Mocked<SecretRedactionService>;
-  let mockPseudonymizationService: jest.Mocked<PseudonymizationService>;
-
-  beforeEach(async () => {
-    const mockSecretRedaction = {
-      redactSecrets: jest.fn(),
-      addRedactionPattern: jest.fn(),
-      removeRedactionPattern: jest.fn(),
-      getRedactionPatterns: jest.fn(),
-      testRedaction: jest.fn(),
-      getStats: jest.fn(),
-      debug: jest.fn(),
-      info: jest.fn(),
-      warn: jest.fn(),
-      error: jest.fn(),
-    };
-
-    const mockPseudonymization = {
-      pseudonymizeText: jest.fn(),
-      generatePseudonym: jest.fn(),
-      lookupPseudonym: jest.fn(),
-      reversePseudonymization: jest.fn(),
-      createReversiblePseudonymization: jest.fn(),
-      addPIIPattern: jest.fn(),
-      getPIIPatterns: jest.fn(),
-      getStats: jest.fn(),
-    };
-
-    const module: TestingModule = await Test.createTestingModule({
-      providers: [
-        DataSanitizationService,
-        { provide: SecretRedactionService, useValue: mockSecretRedaction },
-        { provide: PseudonymizationService, useValue: mockPseudonymization },
-      ],
-    }).compile();
-
-    service = module.get<DataSanitizationService>(DataSanitizationService);
-    mockSecretRedactionService = module.get(SecretRedactionService);
-    mockPseudonymizationService = module.get(PseudonymizationService);
-  });
-
-  afterEach(() => {
-    jest.clearAllMocks();
-  });
-
-  describe('sanitizeText', () => {
-    it('should sanitize text with both redaction and pseudonymization', async () => {
-      const inputText = 'API key: sk-1234567890 and email: john@example.com';
-      
-      mockSecretRedactionService.redactSecrets.mockReturnValue({
-        redactedText: 'API key: [REDACTED] and email: john@example.com',
-        result: {
-          originalLength: inputText.length,
-          redactedLength: 45,
-          redactionCount: 1,
-          patternsMatched: ['api_key'],
-        },
-      });
-
-      mockPseudonymizationService.pseudonymizeText.mockResolvedValue({
-        originalText: 'API key: [REDACTED] and email: john@example.com',
-        pseudonymizedText: 'API key: [REDACTED] and email: user123@example.com',
-        pseudonyms: [{
-          originalValue: 'john@example.com',
-          pseudonym: 'user123@example.com',
-          dataType: 'email',
-          isNew: false,
-        }],
-        processingTime: 10,
-      });
-
-      const result = await service.sanitizeText(inputText);
-
-      expect(result.sanitizedText).toBe('API key: [REDACTED] and email: user123@example.com');
-      expect(result.originalLength).toBe(inputText.length);
-      expect(result.redactionResult).toBeDefined();
-      expect(result.pseudonymizationResult).toBeDefined();
-      expect(result.processingTimeMs).toBeGreaterThan(0);
-    });
-
-    it('should handle redaction-only mode', async () => {
-      const inputText = 'API key: sk-1234567890';
-      
-      mockSecretRedactionService.redactSecrets.mockReturnValue({
-        redactedText: 'API key: [REDACTED]',
-        result: {
-          originalLength: inputText.length,
-          redactedLength: 17,
-          redactionCount: 1,
-          patternsMatched: ['api_key'],
-        },
-      });
-
-      const result = await service.sanitizeText(inputText, {
-        enableRedaction: true,
-        enablePseudonymization: false,
-      });
-
-      expect(result.sanitizedText).toBe('API key: [REDACTED]');
-      expect(mockSecretRedactionService.redactSecrets).toHaveBeenCalled();
-      expect(mockPseudonymizationService.pseudonymizeText).not.toHaveBeenCalled();
-    });
-
-    it('should handle pseudonymization-only mode', async () => {
-      const inputText = 'Email: john@example.com';
-      
-      mockPseudonymizationService.pseudonymizeText.mockResolvedValue({
-        originalText: inputText,
-        pseudonymizedText: 'Email: user123@example.com',
-        pseudonyms: [{
-          originalValue: 'john@example.com',
-          pseudonym: 'user123@example.com',
-          dataType: 'email',
-          isNew: false,
-        }],
-        processingTime: 5,
-      });
-
-      const result = await service.sanitizeText(inputText, {
-        enableRedaction: false,
-        enablePseudonymization: true,
-      });
-
-      expect(result.sanitizedText).toBe('Email: user123@example.com');
-      expect(mockSecretRedactionService.redactSecrets).not.toHaveBeenCalled();
-      expect(mockPseudonymizationService.pseudonymizeText).toHaveBeenCalled();
-    });
-
-    it('should handle empty input', async () => {
-      const result = await service.sanitizeText('');
-
-      expect(result.sanitizedText).toBe('');
-      expect(result.originalLength).toBe(0);
-      expect(result.sanitizedLength).toBe(0);
-      expect(result.processingTimeMs).toBeGreaterThanOrEqual(0);
-    });
-
-    it('should handle null input', async () => {
-      const result = await service.sanitizeText(null as any);
-
-      expect(result.sanitizedText).toBe(null);
-      expect(result.originalLength).toBe(0);
-      expect(result.sanitizedLength).toBe(0);
-    });
-
-    it('should propagate errors from underlying services', async () => {
-      const inputText = 'test input';
-      
-      mockSecretRedactionService.redactSecrets.mockImplementation(() => {
-        throw new Error('Redaction error');
-      });
-
-      await expect(service.sanitizeText(inputText)).rejects.toThrow('Redaction error');
-    });
-  });
-
-  describe('sanitizeObject', () => {
-    it('should sanitize all string values in an object', async () => {
-      const inputObject = {
-        apiKey: 'sk-1234567890',
-        userEmail: 'john@example.com',
-        nested: {
-          password: 'secretpassword',
-          phone: '(555) 123-4567',
-        },
-        numbers: [123, 456],
-        mixedArray: ['text', 'jane@example.com', 789],
-      };
-
-      mockSecretRedactionService.redactSecrets
-        .mockReturnValueOnce({
-          redactedText: '[REDACTED]',
-          result: { originalLength: 14, redactedLength: 11, redactionCount: 1, patternsMatched: ['api_key'] },
-        })
-        .mockReturnValueOnce({
-          redactedText: 'john@example.com',
-          result: { originalLength: 16, redactedLength: 16, redactionCount: 0, patternsMatched: [] },
-        })
-        .mockReturnValueOnce({
-          redactedText: '[REDACTED]',
-          result: { originalLength: 14, redactedLength: 11, redactionCount: 1, patternsMatched: ['password'] },
-        })
-        .mockReturnValueOnce({
-          redactedText: '(555) 123-4567',
-          result: { originalLength: 14, redactedLength: 14, redactionCount: 0, patternsMatched: [] },
-        })
-        .mockReturnValueOnce({
-          redactedText: 'text',
-          result: { originalLength: 4, redactedLength: 4, redactionCount: 0, patternsMatched: [] },
-        })
-        .mockReturnValueOnce({
-          redactedText: 'jane@example.com',
-          result: { originalLength: 16, redactedLength: 16, redactionCount: 0, patternsMatched: [] },
-        });
-
-      mockPseudonymizationService.pseudonymizeText
-        .mockResolvedValueOnce({
-          originalText: '[REDACTED]',
-          pseudonymizedText: '[REDACTED]',
-          pseudonyms: [],
-          processingTime: 1,
-        })
-        .mockResolvedValueOnce({
-          originalText: 'john@example.com',
-          pseudonymizedText: 'user123@example.com',
-          pseudonyms: [{ originalValue: 'john@example.com', pseudonym: 'user123@example.com', dataType: 'email', isNew: false }],
-          processingTime: 2,
-        })
-        .mockResolvedValueOnce({
-          originalText: '[REDACTED]',
-          pseudonymizedText: '[REDACTED]',
-          pseudonyms: [],
-          processingTime: 1,
-        })
-        .mockResolvedValueOnce({
-          originalText: '(555) 123-4567',
-          pseudonymizedText: '(555) 999-0000',
-          pseudonyms: [{ originalValue: '(555) 123-4567', pseudonym: '(555) 999-0000', dataType: 'phone', isNew: false }],
-          processingTime: 3,
-        })
-        .mockResolvedValueOnce({
-          originalText: 'text',
-          pseudonymizedText: 'text',
-          pseudonyms: [],
-          processingTime: 1,
-        })
-        .mockResolvedValueOnce({
-          originalText: 'jane@example.com',
-          pseudonymizedText: 'user456@example.com',
-          pseudonyms: [{ originalValue: 'jane@example.com', pseudonym: 'user456@example.com', dataType: 'email', isNew: false }],
-          processingTime: 2,
-        });
-
-      const result = await service.sanitizeObject(inputObject);
-
-      expect(result.sanitizedObject.apiKey).toBe('[REDACTED]');
-      expect(result.sanitizedObject.userEmail).toBe('user123@example.com');
-      expect(result.sanitizedObject.nested.password).toBe('[REDACTED]');
-      expect(result.sanitizedObject.nested.phone).toBe('(555) 999-0000');
-      expect(result.sanitizedObject.numbers).toEqual([123, 456]);
-      expect(result.sanitizedObject.mixedArray[1]).toBe('user456@example.com');
-    });
-
-    it('should handle arrays correctly', async () => {
-      const inputArray = ['sk-1234567890', 'john@example.com', 123];
-
-      mockSecretRedactionService.redactSecrets
-        .mockReturnValueOnce({
-          redactedText: '[REDACTED]',
-          result: { originalLength: 14, redactedLength: 11, redactionCount: 1, patternsMatched: ['api_key'] },
-        })
-        .mockReturnValueOnce({
-          redactedText: 'john@example.com',
-          result: { originalLength: 16, redactedLength: 16, redactionCount: 0, patternsMatched: [] },
-        });
-
-      mockPseudonymizationService.pseudonymizeText
-        .mockResolvedValueOnce({
-          originalText: '[REDACTED]',
-          pseudonymizedText: '[REDACTED]',
-          pseudonyms: [],
-          processingTime: 1,
-        })
-        .mockResolvedValueOnce({
-          originalText: 'john@example.com',
-          pseudonymizedText: 'user123@example.com',
-          pseudonyms: [{ originalValue: 'john@example.com', pseudonym: 'user123@example.com', dataType: 'email', isNew: false }],
-          processingTime: 2,
-        });
-
-      const result = await service.sanitizeObject(inputArray);
-
-      expect(Array.isArray(result.sanitizedObject)).toBe(true);
-      expect(result.sanitizedObject[0]).toBe('[REDACTED]');
-      expect(result.sanitizedObject[1]).toBe('user123@example.com');
-      expect(result.sanitizedObject[2]).toBe(123);
-    });
-
-    it('should handle non-object input', async () => {
-      mockSecretRedactionService.redactSecrets.mockReturnValue({
-        redactedText: 'test',
-        result: { originalLength: 4, redactedLength: 4, redactionCount: 0, patternsMatched: [] },
-      });
-
-      mockPseudonymizationService.pseudonymizeText.mockResolvedValue({
-        originalText: 'test',
-        pseudonymizedText: 'test',
-        pseudonyms: [],
-        processingTime: 1,
-      });
-
-      const result = await service.sanitizeObject('test string');
-
-      expect(result.sanitizedObject).toBe('test');
-    });
-  });
-
-  describe('reversibleSanitizeText', () => {
-    it('should create reversible sanitization with context', async () => {
-      const inputText = 'Email john@example.com and phone (555) 123-4567';
-      const requestId = 'request-123';
-
-      mockSecretRedactionService.redactSecrets.mockReturnValue({
-        redactedText: inputText, // No secrets to redact
-        result: { originalLength: inputText.length, redactedLength: inputText.length, redactionCount: 0, patternsMatched: [] },
-      });
-
-      mockPseudonymizationService.createReversiblePseudonymization.mockResolvedValue({
-        pseudonymizedText: 'Email user123@example.com and phone (555) 999-0000',
-        reversalContext: [
-          { originalValue: 'john@example.com', pseudonym: 'user123@example.com', dataType: 'email', isNew: false },
-          { originalValue: '(555) 123-4567', pseudonym: '(555) 999-0000', dataType: 'phone', isNew: false },
-        ],
-        processingTime: 15,
-      });
-
-      const result = await service.reversibleSanitizeText(inputText, requestId);
-
-      expect(result.sanitizedText).toBe('Email user123@example.com and phone (555) 999-0000');
-      expect(result.reversalContext).toBeDefined();
-      expect(result.reversalContext).toHaveLength(2);
-      expect(result.result.reversalContext).toBe(result.reversalContext);
-    });
-
-    it('should store context in cache', async () => {
-      const requestId = 'cache-test-123';
-      const inputText = 'john@example.com';
-
-      mockSecretRedactionService.redactSecrets.mockReturnValue({
-        redactedText: inputText,
-        result: { originalLength: inputText.length, redactedLength: inputText.length, redactionCount: 0, patternsMatched: [] },
-      });
-
-      mockPseudonymizationService.createReversiblePseudonymization.mockResolvedValue({
-        pseudonymizedText: 'user123@example.com',
-        reversalContext: [{ originalValue: 'john@example.com', pseudonym: 'user123@example.com', dataType: 'email', isNew: false }],
-        processingTime: 5,
-      });
-
-      await service.reversibleSanitizeText(inputText, requestId);
-
-      // Verify context was stored (check cache stats)
-      const cacheStats = service.getCacheStats();
-      expect(cacheStats.size).toBeGreaterThan(0);
-    });
-
-    it('should handle empty input', async () => {
-      const result = await service.reversibleSanitizeText('', 'request-123');
-
-      expect(result.sanitizedText).toBe('');
-      expect(result.reversalContext).toBeNull();
-      expect(result.result.originalLength).toBe(0);
-    });
-  });
-
-  describe('reverseSanitization', () => {
-    it('should reverse sanitization using provided context', async () => {
-      const sanitizedText = 'Contact user123@example.com';
-      const reversalContext = [
-        { originalValue: 'john@example.com', pseudonym: 'user123@example.com', dataType: 'email', isNew: false },
-      ];
-
-      mockPseudonymizationService.reversePseudonymization.mockResolvedValue({
-        originalText: 'Contact john@example.com',
-        reversalCount: 1,
-        processingTime: 3,
-      });
-
-      const result = await service.reverseSanitization(sanitizedText, reversalContext);
-
-      expect(result.originalText).toBe('Contact john@example.com');
-      expect(result.reversalCount).toBe(1);
-      expect(result.source).toBe('context');
-    });
-
-    it('should use cache when context not provided but requestId available', async () => {
-      const requestId = 'cached-request-456';
-      const sanitizedText = 'Contact user123@example.com';
-
-      // First, store something in cache
-      const contextData = [
-        { originalValue: 'john@example.com', pseudonym: 'user123@example.com', dataType: 'email', isNew: false },
-      ];
-      
-      mockSecretRedactionService.redactSecrets.mockReturnValue({
-        redactedText: 'john@example.com',
-        result: { originalLength: 16, redactedLength: 16, redactionCount: 0, patternsMatched: [] },
-      });
-
-      mockPseudonymizationService.createReversiblePseudonymization.mockResolvedValue({
-        pseudonymizedText: 'user123@example.com',
-        reversalContext: contextData,
-        processingTime: 5,
-      });
-
-      // Store in cache first
-      await service.reversibleSanitizeText('john@example.com', requestId);
-
-      // Now try to reverse using cache
-      mockPseudonymizationService.reversePseudonymization.mockResolvedValue({
-        originalText: 'Contact john@example.com',
-        reversalCount: 1,
-        processingTime: 2,
-      });
-
-      const result = await service.reverseSanitization(sanitizedText, null, requestId);
-
-      expect(result.originalText).toBe('Contact john@example.com');
-      expect(result.source).toBe('memory');
-    });
-
-    it('should handle missing context gracefully', async () => {
-      const sanitizedText = 'Contact user123@example.com';
-
-      const result = await service.reverseSanitization(sanitizedText, null);
-
-      expect(result.originalText).toBe(sanitizedText);
-      expect(result.reversalCount).toBe(0);
-      expect(result.source).toBe('context');
-    });
-
-    it('should handle errors during reversal', async () => {
-      const sanitizedText = 'Contact user123@example.com';
-      const reversalContext = [
-        { originalValue: 'john@example.com', pseudonym: 'user123@example.com', dataType: 'email', isNew: false },
-      ];
-
-      mockPseudonymizationService.reversePseudonymization.mockRejectedValue(new Error('Reversal error'));
-
-      const result = await service.reverseSanitization(sanitizedText, reversalContext);
-
-      expect(result.originalText).toBe(sanitizedText); // Should return original on error
-      expect(result.reversalCount).toBe(0);
-    });
-  });
-
-  describe('sanitizeForLLM', () => {
-    it('should sanitize both system prompt and user message', async () => {
-      const systemPrompt = 'System API key: sk-1234567890';
-      const userMessage = 'User email: john@example.com';
-      const requestId = 'llm-request-789';
-
-      mockSecretRedactionService.redactSecrets
-        .mockReturnValueOnce({
-          redactedText: 'System API key: [REDACTED]',
-          result: { originalLength: systemPrompt.length, redactedLength: 25, redactionCount: 1, patternsMatched: ['api_key'] },
-        })
-        .mockReturnValueOnce({
-          redactedText: userMessage,
-          result: { originalLength: userMessage.length, redactedLength: userMessage.length, redactionCount: 0, patternsMatched: [] },
-        });
-
-      mockPseudonymizationService.createReversiblePseudonymization
-        .mockResolvedValueOnce({
-          pseudonymizedText: 'System API key: [REDACTED]',
-          reversalContext: [],
-          processingTime: 2,
-        })
-        .mockResolvedValueOnce({
-          pseudonymizedText: 'User email: user123@example.com',
-          reversalContext: [{ originalValue: 'john@example.com', pseudonym: 'user123@example.com', dataType: 'email', isNew: false }],
-          processingTime: 5,
-        });
-
-      const result = await service.sanitizeForLLM(systemPrompt, userMessage, requestId);
-
-      expect(result.sanitizedSystemPrompt).toBe('System API key: [REDACTED]');
-      expect(result.sanitizedUserMessage).toBe('User email: user123@example.com');
-      expect(result.reversalContext).toBeDefined();
-      expect(result.reversalContext.system).toBeDefined();
-      expect(result.reversalContext.user).toBeDefined();
-    });
-  });
-
-  describe('reverseLLMResponse', () => {
-    it('should reverse LLM response using combined contexts', async () => {
-      const llmResponse = 'The user user123@example.com should be contacted';
-      const reversalContext = {
-        system: [],
-        user: [{ originalValue: 'john@example.com', pseudonym: 'user123@example.com', dataType: 'email', isNew: false }],
-      };
-
-      mockPseudonymizationService.reversePseudonymization
-        .mockResolvedValueOnce({
-          originalText: llmResponse, // No system context changes
-          reversalCount: 0,
-          processingTime: 1,
-        })
-        .mockResolvedValueOnce({
-          originalText: 'The user john@example.com should be contacted',
-          reversalCount: 1,
-          processingTime: 3,
-        });
-
-      const result = await service.reverseLLMResponse(llmResponse, reversalContext);
-
-      expect(result).toBe('The user john@example.com should be contacted');
-    });
-
-    it('should handle missing reversal context', async () => {
-      const llmResponse = 'No pseudonyms to reverse';
-
-      const result = await service.reverseLLMResponse(llmResponse, null);
-
-      expect(result).toBe(llmResponse);
-    });
-  });
-
-  describe('safe logging', () => {
-    it('should provide safe logging methods', async () => {
-      mockSecretRedactionService.redactSecrets.mockReturnValue({
-        redactedText: 'Safe message',
-        result: { originalLength: 12, redactedLength: 12, redactionCount: 0, patternsMatched: [] },
-      });
-
-      mockPseudonymizationService.pseudonymizeText.mockResolvedValue({
-        originalText: 'Safe message',
-        pseudonymizedText: 'Safe message',
-        pseudonyms: [],
-        processingTime: 1,
-      });
-
-      // These should not throw
-      await expect(service.debug('test message')).resolves.not.toThrow();
-      await expect(service.info('test message')).resolves.not.toThrow();
-      await expect(service.warn('test message')).resolves.not.toThrow();
-      await expect(service.error('test message')).resolves.not.toThrow();
-    });
-
-    it('should handle sanitization errors in logging gracefully', async () => {
-      mockSecretRedactionService.redactSecrets.mockImplementation(() => {
-        throw new Error('Sanitization failed');
-      });
-
-      // Should not throw, should fallback gracefully
-      await expect(service.info('test message')).resolves.not.toThrow();
-    });
-  });
-
-  describe('cache management', () => {
-    it('should provide cache statistics', () => {
-      const stats = service.getCacheStats();
-
-      expect(stats).toHaveProperty('size');
-      expect(stats).toHaveProperty('maxSize');
-      expect(stats).toHaveProperty('expirationMs');
-      expect(typeof stats.size).toBe('number');
-      expect(typeof stats.maxSize).toBe('number');
-      expect(typeof stats.expirationMs).toBe('number');
-    });
-
-    it('should respect cache size limits', async () => {
-      // This would require testing the internal cache implementation
-      // For now, just verify the cache stats are accessible
-      const initialStats = service.getCacheStats();
-      expect(initialStats.size).toBe(0);
-    });
-
-    it('should handle cache expiration', async () => {
-      // This would require mocking time or waiting for expiration
-      // For unit tests, we'll just verify the expiration setting exists
-      const stats = service.getCacheStats();
-      expect(stats.expirationMs).toBeGreaterThan(0);
-    });
-  });
-
-  describe('getStats', () => {
-    it('should return comprehensive statistics', async () => {
-      mockSecretRedactionService.getStats.mockReturnValue({
-        totalPatterns: 10,
-        productionMode: false,
-        verboseLogging: false,
-        customPatterns: 2,
-      });
-
-      mockPseudonymizationService.getStats.mockResolvedValue({
-        totalPIIPatterns: 8,
-        productionMode: false,
-        customPatterns: 1,
-        patternServiceStats: {},
-      });
-
-      const result = await service.getStats();
-
-      expect(result.redactionStats).toBeDefined();
-      expect(result.pseudonymizationStats).toBeDefined();
-      expect(result.totalPatterns).toBe(18); // 10 + 8
-      expect(result.productionMode).toBe(false);
-      expect(result.verboseLogging).toBe(false);
-    });
-  });
-
-  describe('testSanitization', () => {
-    it('should provide comprehensive test results', async () => {
-      const testText = 'API: sk-1234567890 Email: john@example.com';
-
-      mockSecretRedactionService.redactSecrets.mockReturnValue({
-        redactedText: 'API: [REDACTED] Email: john@example.com',
-        result: { originalLength: testText.length, redactedLength: 39, redactionCount: 1, patternsMatched: ['api_key'] },
-      });
-
-      mockPseudonymizationService.pseudonymizeText.mockResolvedValue({
-        originalText: 'API: [REDACTED] Email: john@example.com',
-        pseudonymizedText: 'API: [REDACTED] Email: user123@example.com',
-        pseudonyms: [{ originalValue: 'john@example.com', pseudonym: 'user123@example.com', dataType: 'email', isNew: false }],
-        processingTime: 8,
-      });
-
-      mockSecretRedactionService.testRedaction.mockReturnValue({
-        redactedText: 'API: [REDACTED] Email: john@example.com',
-        result: { originalLength: testText.length, redactedLength: 39, redactionCount: 1, patternsMatched: ['api_key'] },
-        patternDetails: [{ name: 'api_key', matches: 1, description: 'API keys' }],
-      });
-
-      const result = await service.testSanitization(testText);
-
-      expect(result.sanitizedText).toBe('API: [REDACTED] Email: user123@example.com');
-      expect(result.result).toBeDefined();
-      expect(result.redactionDetails).toBeDefined();
-      expect(result.pseudonymizationDetails).toBeDefined();
-    });
-  });
-
-  describe('error handling and edge cases', () => {
-    it('should handle service initialization errors gracefully', () => {
-      // Service should initialize even if dependencies have issues
-      expect(service).toBeDefined();
-    });
-
-    it('should handle concurrent operations', async () => {
-      const text = 'john@example.com';
-      const requestId = 'concurrent-test';
-
-      mockSecretRedactionService.redactSecrets.mockReturnValue({
-        redactedText: text,
-        result: { originalLength: text.length, redactedLength: text.length, redactionCount: 0, patternsMatched: [] },
-      });
-
-      mockPseudonymizationService.createReversiblePseudonymization.mockResolvedValue({
-        pseudonymizedText: 'user123@example.com',
-        reversalContext: [{ originalValue: 'john@example.com', pseudonym: 'user123@example.com', dataType: 'email', isNew: false }],
-        processingTime: 5,
-      });
-
-      // Run multiple concurrent operations
-      const promises = Array.from({ length: 5 }, (_, i) => 
-        service.reversibleSanitizeText(text, `${requestId}-${i}`)
-      );
-
-      const results = await Promise.all(promises);
-
-      expect(results).toHaveLength(5);
-      results.forEach(result => {
-        expect(result.sanitizedText).toBe('user123@example.com');
-      });
-    });
-
-    it('should handle very large text inputs', async () => {
-      const largeText = 'test@example.com '.repeat(1000);
-
-      mockSecretRedactionService.redactSecrets.mockReturnValue({
-        redactedText: largeText,
-        result: { originalLength: largeText.length, redactedLength: largeText.length, redactionCount: 0, patternsMatched: [] },
-      });
-
-      mockPseudonymizationService.pseudonymizeText.mockResolvedValue({
-        originalText: largeText,
-        pseudonymizedText: largeText.replace(/test@example\.com/g, 'user123@example.com'),
-        pseudonyms: [],
-        processingTime: 50,
-      });
-
-      const startTime = Date.now();
-      const result = await service.sanitizeText(largeText);
-      const endTime = Date.now();
-
-      expect(result).toBeDefined();
-      expect(endTime - startTime).toBeLessThan(5000); // Should complete in reasonable time
-    });
-  });
-});
\ No newline at end of file
diff --git a/apps/api/src/llms/data-sanitization.service.ts b/apps/api/src/llms/data-sanitization.service.ts
deleted file mode 100644
index 7375e0b..0000000
--- a/apps/api/src/llms/data-sanitization.service.ts
+++ /dev/null
@@ -1,795 +0,0 @@
-import { Injectable, Logger } from '@nestjs/common';
-import { SecretRedactionService, RedactionResult } from './secret-redaction.service';
-import { PseudonymizationService, PseudonymizationResult } from './pseudonymization.service';
-
-export interface SanitizationOptions {
-  enableRedaction?: boolean;
-  enablePseudonymization?: boolean;
-  pseudonymizationContext?: string;
-  preserveFormatting?: boolean;
-}
-
-export interface SanitizationResult {
-  sanitizedText: string;
-  originalLength: number;
-  sanitizedLength: number;
-  redactionResult?: RedactionResult;
-  pseudonymizationResult?: PseudonymizationResult;
-  processingTimeMs: number;
-  reversalContext?: any; // Context needed to reverse pseudonymization
-}
-
-export interface DetailedSanitizationMetrics {
-  piiDetected: boolean;
-  piiTypes: string[];
-  pseudonymsUsed: number;
-  pseudonymTypes: string[];
-  redactionsApplied: number;
-  redactionTypes: string[];
-  sanitizationTimeMs: number;
-  reversalContextSize: number;
-  sanitizationLevel: 'none' | 'basic' | 'standard' | 'strict';
-}
-
-export interface LogEntry {
-  runId: string;
-  timestamp: string;
-  level: 'debug' | 'info' | 'warn' | 'error';
-  message: string;
-  context?: string;
-  metadata?: Record<string, any>;
-}
-
-@Injectable()
-export class DataSanitizationService {
-  private readonly logger = new Logger(DataSanitizationService.name);
-  private readonly isProduction = process.env.NODE_ENV === 'production';
-  private readonly enableVerboseLogging = process.env.ENABLE_VERBOSE_LOGGING === 'true';
-  private readonly enableRedactionByDefault = process.env.ENABLE_REDACTION === 'true';
-  
-  // In-memory cache for pseudonym contexts (fast lookup)
-  private readonly contextCache = new Map<string, any>();
-  private readonly cacheExpirationMs = 60 * 60 * 1000; // 1 hour
-  private readonly maxCacheSize = 10000;
-
-  constructor(
-    private readonly secretRedactionService: SecretRedactionService,
-    private readonly pseudonymizationService: PseudonymizationService
-  ) {
-    this.logger.log(`DataSanitizationService initialized (production: ${this.isProduction})`);
-    this.logger.log(`üîê Redaction enabled by default: ${this.enableRedactionByDefault}`);
-    this.logger.log(`‚úÖ SecretRedactionService injected: ${!!this.secretRedactionService}`);
-    this.logger.log(`‚úÖ PseudonymizationService injected: ${!!this.pseudonymizationService}`);
-  }
-
-  /**
-   * Sanitize text by applying both redaction and pseudonymization
-   */
-  async sanitizeText(
-    text: string,
-    options: SanitizationOptions = {}
-  ): Promise<SanitizationResult> {
-    const startTime = Date.now();
-    const originalLength = text?.length || 0;
-
-
-    if (!text) {
-      this.logger.log(`‚ö†Ô∏è Empty text provided to sanitizeText`);
-      return {
-        sanitizedText: text,
-        originalLength: 0,
-        sanitizedLength: 0,
-        processingTimeMs: Date.now() - startTime,
-      };
-    }
-
-    const {
-      enableRedaction = this.enableRedactionByDefault,
-      enablePseudonymization = true,
-      pseudonymizationContext = 'general',
-      preserveFormatting = true,
-    } = options;
-
-    let sanitizedText = text;
-    let redactionResult: RedactionResult | undefined;
-    let pseudonymizationResult: PseudonymizationResult | undefined;
-
-    try {
-      // First apply pseudonymization to detect and replace PII
-      if (enablePseudonymization) {
-        this.logger.log(`üé≠ Applying pseudonymization...`);
-        pseudonymizationResult = await this.pseudonymizationService.pseudonymizeText(
-          sanitizedText,
-          { context: pseudonymizationContext }
-        );
-        sanitizedText = pseudonymizationResult.pseudonymizedText;
-        this.logger.log(`üé≠ Pseudonymization complete. Pseudonyms: ${pseudonymizationResult?.pseudonyms?.length || 0}`);
-      }
-
-      // Then apply secret redaction to catch any remaining secrets
-      if (enableRedaction) {
-        this.logger.log(`üîê Applying secret redaction...`);
-        const redactionResponse = this.secretRedactionService.redactSecrets(sanitizedText);
-        sanitizedText = redactionResponse.redactedText;
-        redactionResult = redactionResponse.result;
-        this.logger.log(`üîê Redaction complete. Redactions: ${redactionResult?.redactionCount || 0}, Patterns: ${redactionResult?.patternsMatched?.join(', ') || 'none'}`);
-      }
-
-      const result: SanitizationResult = {
-        sanitizedText,
-        originalLength,
-        sanitizedLength: sanitizedText.length,
-        redactionResult,
-        pseudonymizationResult,
-        processingTimeMs: Date.now() - startTime,
-      };
-
-      return result;
-    } catch (error) {
-      this.logger.error(`Error during text sanitization: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
-      throw error;
-    }
-  }
-
-  /**
-   * Sanitize object by recursively processing all string values
-   */
-  async sanitizeObject(
-    obj: any,
-    options: SanitizationOptions = {}
-  ): Promise<{ sanitizedObject: any; result: SanitizationResult }> {
-    const startTime = Date.now();
-
-    if (!obj || typeof obj !== 'object') {
-      const sanitizationResult = await this.sanitizeText(String(obj), options);
-      return {
-        sanitizedObject: sanitizationResult.sanitizedText,
-        result: sanitizationResult,
-      };
-    }
-
-    const sanitizedObject: any = Array.isArray(obj) ? [] : {};
-    let totalOriginalLength = 0;
-    let totalSanitizedLength = 0;
-    let totalRedactionCount = 0;
-    let totalPseudonymCount = 0;
-    const allPatternsMatched: string[] = [];
-    const allPiiTypesFound: string[] = [];
-
-    for (const [key, value] of Object.entries(obj)) {
-      if (typeof value === 'string') {
-        const sanitizationResult = await this.sanitizeText(value, options);
-        sanitizedObject[key] = sanitizationResult.sanitizedText;
-        
-        totalOriginalLength += sanitizationResult.originalLength;
-        totalSanitizedLength += sanitizationResult.sanitizedLength;
-        
-        if (sanitizationResult.redactionResult) {
-          totalRedactionCount += sanitizationResult.redactionResult.redactionCount;
-          allPatternsMatched.push(...sanitizationResult.redactionResult.patternsMatched);
-        }
-        
-        if (sanitizationResult.pseudonymizationResult) {
-          totalPseudonymCount += sanitizationResult.pseudonymizationResult.pseudonyms.length;
-          allPiiTypesFound.push(...sanitizationResult.pseudonymizationResult.pseudonyms.map(p => p.dataType));
-        }
-      } else if (typeof value === 'object' && value !== null) {
-        const nestedResult = await this.sanitizeObject(value, options);
-        sanitizedObject[key] = nestedResult.sanitizedObject;
-        
-        totalOriginalLength += nestedResult.result.originalLength;
-        totalSanitizedLength += nestedResult.result.sanitizedLength;
-        
-        if (nestedResult.result.redactionResult) {
-          totalRedactionCount += nestedResult.result.redactionResult.redactionCount;
-          allPatternsMatched.push(...nestedResult.result.redactionResult.patternsMatched);
-        }
-        
-        if (nestedResult.result.pseudonymizationResult) {
-          totalPseudonymCount += nestedResult.result.pseudonymizationResult.pseudonyms.length;
-          allPiiTypesFound.push(...nestedResult.result.pseudonymizationResult.pseudonyms.map(p => p.dataType));
-        }
-      } else {
-        sanitizedObject[key] = value;
-      }
-    }
-
-    const result: SanitizationResult = {
-      sanitizedText: JSON.stringify(sanitizedObject),
-      originalLength: totalOriginalLength,
-      sanitizedLength: totalSanitizedLength,
-      redactionResult: totalRedactionCount > 0 ? {
-        originalLength: totalOriginalLength,
-        redactedLength: totalSanitizedLength,
-        redactionCount: totalRedactionCount,
-        patternsMatched: [...new Set(allPatternsMatched)],
-      } : undefined,
-      pseudonymizationResult: totalPseudonymCount > 0 ? {
-        originalText: JSON.stringify(obj),
-        pseudonymizedText: JSON.stringify(sanitizedObject),
-        pseudonyms: [], // This would need to be properly aggregated if needed
-        processingTime: 0,
-      } : undefined,
-      processingTimeMs: Date.now() - startTime,
-    };
-
-    return { sanitizedObject, result };
-  }
-
-  /**
-   * Reversible sanitization for LLM requests - preserves context for reversal
-   */
-  async reversibleSanitizeText(
-    text: string,
-    requestId: string,
-    options: SanitizationOptions = {}
-  ): Promise<{
-    sanitizedText: string;
-    reversalContext: any;
-    result: SanitizationResult;
-  }> {
-    const startTime = Date.now();
-    const originalLength = text?.length || 0;
-
-    if (!text) {
-      return {
-        sanitizedText: text,
-        reversalContext: null,
-        result: {
-          sanitizedText: text,
-          originalLength: 0,
-          sanitizedLength: 0,
-          processingTimeMs: Date.now() - startTime,
-        },
-      };
-    }
-
-    const {
-      enableRedaction = this.enableRedactionByDefault,
-      enablePseudonymization = true,
-      pseudonymizationContext = 'llm-request',
-    } = options;
-
-    let sanitizedText = text;
-    let redactionResult: RedactionResult | undefined;
-    let pseudonymizationContext_internal: any = null;
-
-    try {
-      // Step 1: Apply secret redaction (irreversible)
-      if (enableRedaction) {
-        const redactionResponse = this.secretRedactionService.redactSecrets(sanitizedText);
-        sanitizedText = redactionResponse.redactedText;
-        redactionResult = redactionResponse.result;
-      }
-
-      // Step 2: Apply reversible pseudonymization
-      if (enablePseudonymization) {
-        const pseudonymResponse = await this.pseudonymizationService.createReversiblePseudonymization(
-          sanitizedText,
-          requestId,
-          { context: pseudonymizationContext }
-        );
-        sanitizedText = pseudonymResponse.pseudonymizedText;
-        pseudonymizationContext_internal = pseudonymResponse.reversalContext;
-      }
-
-      const result: SanitizationResult = {
-        sanitizedText,
-        originalLength,
-        sanitizedLength: sanitizedText.length,
-        redactionResult,
-        pseudonymizationResult: pseudonymizationContext_internal ? {
-          originalText: text,
-          pseudonymizedText: sanitizedText,
-          pseudonyms: pseudonymizationContext_internal,
-          processingTime: 0,
-        } : undefined,
-        processingTimeMs: Date.now() - startTime,
-        reversalContext: pseudonymizationContext_internal,
-      };
-
-      // Store in memory cache for fast lookup
-      if (pseudonymizationContext_internal) {
-        this.storeContextInCache(requestId, pseudonymizationContext_internal);
-        
-        // Async fire-and-forget persistence to database
-        this.persistContextToDatabase(requestId, pseudonymizationContext_internal).catch(error => {
-          this.logger.warn(`Failed to persist context to database: ${error instanceof Error ? error.message : 'Unknown error'}`);
-        });
-      }
-
-      return {
-        sanitizedText,
-        reversalContext: pseudonymizationContext_internal,
-        result,
-      };
-    } catch (error) {
-      this.logger.error(`Error during reversible text sanitization: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
-      throw error;
-    }
-  }
-
-  /**
-   * Reverse sanitization - convert pseudonyms back to original values
-   * Uses hybrid lookup: memory first, database fallback
-   */
-  async reverseSanitization(
-    sanitizedText: string,
-    reversalContext: any,
-    requestId?: string
-  ): Promise<{
-    originalText: string;
-    reversalCount: number;
-    processingTimeMs: number;
-    source: 'memory' | 'database' | 'context';
-  }> {
-    const startTime = Date.now();
-
-    if (!sanitizedText) {
-      return {
-        originalText: sanitizedText,
-        reversalCount: 0,
-        processingTimeMs: Date.now() - startTime,
-        source: 'context',
-      };
-    }
-
-    try {
-      let contextToUse = reversalContext;
-      let source: 'memory' | 'database' | 'context' = 'context';
-
-      // Strategy 1: Use provided context (fastest)
-      if (!contextToUse && requestId) {
-        // Strategy 2: Check memory cache (fast)
-        contextToUse = this.getContextFromCache(requestId);
-        if (contextToUse) {
-          source = 'memory';
-        } else {
-          // Strategy 3: Database fallback (slower)
-          contextToUse = await this.getContextFromDatabase(requestId);
-          if (contextToUse) {
-            source = 'database';
-            // Cache it for future use
-            this.storeContextInCache(requestId, contextToUse);
-          }
-        }
-      }
-
-      if (!contextToUse) {
-        return {
-          originalText: sanitizedText,
-          reversalCount: 0,
-          processingTimeMs: Date.now() - startTime,
-          source,
-        };
-      }
-
-      // Reverse pseudonymization using the found context
-      const reverseResult = await this.pseudonymizationService.reversePseudonymization(
-        sanitizedText,
-        contextToUse
-      );
-
-      return {
-        originalText: reverseResult.originalText,
-        reversalCount: reverseResult.reversalCount,
-        processingTimeMs: Date.now() - startTime,
-        source,
-      };
-    } catch (error) {
-      this.logger.error(`Error during reverse sanitization: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
-      
-      // Return the sanitized text if reversal fails
-      return {
-        originalText: sanitizedText,
-        reversalCount: 0,
-        processingTimeMs: Date.now() - startTime,
-        source: 'context',
-      };
-    }
-  }
-
-  /**
-   * Complete LLM request sanitization pipeline with reversal
-   */
-  async sanitizeForLLM(
-    systemPrompt: string,
-    userMessage: string,
-    requestId: string,
-    options: SanitizationOptions = {}
-  ): Promise<{
-    sanitizedSystemPrompt: string;
-    sanitizedUserMessage: string;
-    reversalContext: any;
-    systemSanitizationResult: SanitizationResult;
-    userSanitizationResult: SanitizationResult;
-  }> {
-    console.log(`üîç DEBUG: DataSanitizationService.sanitizeForLLM called`);
-    // Sanitize both system prompt and user message
-    const systemResult = await this.reversibleSanitizeText(systemPrompt, `${requestId}-system`, options);
-    const userResult = await this.reversibleSanitizeText(userMessage, `${requestId}-user`, options);
-
-    // Combine reversal contexts
-    const combinedReversalContext = {
-      system: systemResult.reversalContext,
-      user: userResult.reversalContext,
-    };
-
-    return {
-      sanitizedSystemPrompt: systemResult.sanitizedText,
-      sanitizedUserMessage: userResult.sanitizedText,
-      reversalContext: combinedReversalContext,
-      systemSanitizationResult: systemResult.result,
-      userSanitizationResult: userResult.result,
-    };
-  }
-
-  /**
-   * Reverse LLM response sanitization
-   */
-  async reverseLLMResponse(
-    llmResponse: string,
-    reversalContext: any
-  ): Promise<string> {
-    if (!reversalContext) {
-      return llmResponse;
-    }
-
-    // Try to reverse using both system and user contexts
-    let reversedResponse = llmResponse;
-
-    if (reversalContext.system) {
-      const systemReversal = await this.reverseSanitization(reversedResponse, reversalContext.system);
-      reversedResponse = systemReversal.originalText;
-    }
-
-    if (reversalContext.user) {
-      const userReversal = await this.reverseSanitization(reversedResponse, reversalContext.user);
-      reversedResponse = userReversal.originalText;
-    }
-
-    return reversedResponse;
-  }
-
-  /**
-   * Safe logging method that automatically sanitizes all content
-   */
-  async safeLog(
-    level: 'debug' | 'info' | 'warn' | 'error',
-    message: string,
-    runId?: string,
-    context?: string,
-    metadata?: Record<string, any>
-  ): Promise<void> {
-    // Skip verbose logging in production unless explicitly enabled
-    if (this.isProduction && level === 'debug' && !this.enableVerboseLogging) {
-      return;
-    }
-
-    try {
-      // Sanitize the message
-      const sanitizedMessageResult = await this.sanitizeText(message, {
-        enableRedaction: this.enableRedactionByDefault,
-        enablePseudonymization: true,
-        pseudonymizationContext: 'logging',
-      });
-
-      // Sanitize metadata if provided
-      let sanitizedMetadata = metadata;
-      if (metadata) {
-        const sanitizedMetadataResult = await this.sanitizeObject(metadata, {
-          enableRedaction: this.enableRedactionByDefault,
-          enablePseudonymization: true,
-          pseudonymizationContext: 'logging',
-        });
-        sanitizedMetadata = sanitizedMetadataResult.sanitizedObject;
-      }
-
-      // Create structured log entry
-      const logEntry: LogEntry = {
-        runId: runId || 'system',
-        timestamp: new Date().toISOString(),
-        level,
-        message: sanitizedMessageResult.sanitizedText,
-        context,
-        metadata: sanitizedMetadata,
-      };
-
-      // Log using NestJS logger with appropriate level
-      const logMessage = this.formatLogMessage(logEntry);
-      
-      switch (level) {
-        case 'debug':
-          this.logger.debug(logMessage);
-          break;
-        case 'info':
-          this.logger.log(logMessage);
-          break;
-        case 'warn':
-          this.logger.warn(logMessage);
-          break;
-        case 'error':
-          this.logger.error(logMessage);
-          break;
-      }
-    } catch (error) {
-      // Fallback to basic logging if sanitization fails
-      this.logger.error(`Failed to sanitize log message: ${error instanceof Error ? error.message : 'Unknown error'}`);
-      this.logger[level === 'info' ? 'log' : level](`[UNSANITIZED] ${message}`);
-    }
-  }
-
-  /**
-   * Format log message for structured logging
-   */
-  private formatLogMessage(logEntry: LogEntry): string {
-    const parts = [`[${logEntry.runId}]`, logEntry.message];
-    
-    if (logEntry.context) {
-      parts.push(`(${logEntry.context})`);
-    }
-
-    if (logEntry.metadata && Object.keys(logEntry.metadata).length > 0) {
-      parts.push(JSON.stringify(logEntry.metadata));
-    }
-
-    return parts.join(' ');
-  }
-
-  /**
-   * Convenience methods for different log levels with automatic sanitization
-   */
-  async debug(message: string, runId?: string, context?: string, metadata?: Record<string, any>): Promise<void> {
-    await this.safeLog('debug', message, runId, context, metadata);
-  }
-
-  async info(message: string, runId?: string, context?: string, metadata?: Record<string, any>): Promise<void> {
-    await this.safeLog('info', message, runId, context, metadata);
-  }
-
-  async warn(message: string, runId?: string, context?: string, metadata?: Record<string, any>): Promise<void> {
-    await this.safeLog('warn', message, runId, context, metadata);
-  }
-
-  async error(message: string, runId?: string, context?: string, metadata?: Record<string, any>): Promise<void> {
-    await this.safeLog('error', message, runId, context, metadata);
-  }
-
-  /**
-   * Get combined statistics from both services
-   */
-  async getStats(): Promise<{
-    redactionStats: any;
-    pseudonymizationStats: any;
-    totalPatterns: number;
-    productionMode: boolean;
-    verboseLogging: boolean;
-  }> {
-    const redactionStats = this.secretRedactionService.getStats();
-    const pseudonymizationStats = await this.pseudonymizationService.getStats();
-
-    return {
-      redactionStats,
-      pseudonymizationStats,
-      totalPatterns: redactionStats.totalPatterns + (pseudonymizationStats.totalPIIPatterns || 0),
-      productionMode: this.isProduction,
-      verboseLogging: this.enableVerboseLogging,
-    };
-  }
-
-  /**
-   * Test sanitization with detailed results
-   */
-  async testSanitization(text: string): Promise<{
-    sanitizedText: string;
-    result: SanitizationResult;
-    redactionDetails?: any;
-    pseudonymizationDetails?: any;
-  }> {
-    const sanitizationResult = await this.sanitizeText(text, {
-      enableRedaction: this.enableRedactionByDefault,
-      enablePseudonymization: true,
-      pseudonymizationContext: 'testing',
-    });
-
-    // Get detailed test results from individual services
-    const redactionDetails = this.secretRedactionService.testRedaction(text);
-    const pseudonymizationDetails = await this.pseudonymizationService.pseudonymizeText(text, { context: 'testing' });
-
-    return {
-      sanitizedText: sanitizationResult.sanitizedText,
-      result: sanitizationResult,
-      redactionDetails,
-      pseudonymizationDetails,
-    };
-  }
-
-  /**
-   * Cache Management Methods
-   */
-  
-  private storeContextInCache(requestId: string, context: any): void {
-    try {
-      // Implement LRU eviction if cache is full
-      if (this.contextCache.size >= this.maxCacheSize) {
-        const firstKey = this.contextCache.keys().next().value;
-        if (firstKey !== undefined) {
-          this.contextCache.delete(firstKey);
-        }
-      }
-
-      this.contextCache.set(requestId, {
-        context,
-        timestamp: Date.now(),
-      });
-    } catch (error) {
-      this.logger.warn(`Failed to store context in cache: ${error instanceof Error ? error.message : 'Unknown error'}`);
-    }
-  }
-
-  private getContextFromCache(requestId: string): any {
-    try {
-      const cached = this.contextCache.get(requestId);
-      if (!cached) return null;
-
-      // Check if expired
-      const isExpired = Date.now() - cached.timestamp > this.cacheExpirationMs;
-      if (isExpired) {
-        this.contextCache.delete(requestId);
-        return null;
-      }
-
-      return cached.context;
-    } catch (error) {
-      this.logger.warn(`Failed to get context from cache: ${error instanceof Error ? error.message : 'Unknown error'}`);
-      return null;
-    }
-  }
-
-  private async persistContextToDatabase(requestId: string, context: any): Promise<void> {
-    try {
-      // Store context as JSONB for flexible querying
-      const contextData = {
-        request_id: requestId,
-        context_data: context,
-        created_at: new Date().toISOString(),
-        expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24 hours
-      };
-
-      // This would require a context storage table - for now just log
-      this.logger.debug(`Would persist context for request ${requestId} to database`);
-      
-      // TODO: Implement actual database persistence
-      // await client.from('pseudonym_contexts').insert(contextData);
-    } catch (error) {
-      this.logger.warn(`Failed to persist context to database: ${error instanceof Error ? error.message : 'Unknown error'}`);
-    }
-  }
-
-  private async getContextFromDatabase(requestId: string): Promise<any> {
-    try {
-      // TODO: Implement actual database lookup
-      // const { data } = await client
-      //   .from('pseudonym_contexts')
-      //   .select('context_data')
-      //   .eq('request_id', requestId)
-      //   .gt('expires_at', new Date().toISOString())
-      //   .single();
-      
-      this.logger.debug(`Would lookup context for request ${requestId} from database`);
-      return null; // For now, return null until table is created
-    } catch (error) {
-      this.logger.warn(`Failed to get context from database: ${error instanceof Error ? error.message : 'Unknown error'}`);
-      return null;
-    }
-  }
-
-  /**
-   * Cleanup expired cache entries
-   */
-  private cleanupExpiredCache(): void {
-    const now = Date.now();
-    for (const [key, value] of this.contextCache.entries()) {
-      if (now - value.timestamp > this.cacheExpirationMs) {
-        this.contextCache.delete(key);
-      }
-    }
-  }
-
-  /**
-   * Extract detailed sanitization metrics from a sanitization result
-   */
-  extractSanitizationMetrics(
-    sanitizationResult?: SanitizationResult,
-    isLocalProvider: boolean = false
-  ): DetailedSanitizationMetrics {
-    if (isLocalProvider || !sanitizationResult) {
-      return {
-        piiDetected: false,
-        piiTypes: [],
-        pseudonymsUsed: 0,
-        pseudonymTypes: [],
-        redactionsApplied: 0,
-        redactionTypes: [],
-        sanitizationTimeMs: 0,
-        reversalContextSize: 0,
-        sanitizationLevel: 'none',
-      };
-    }
-
-    const redactionResult = sanitizationResult.redactionResult;
-    const pseudonymResult = sanitizationResult.pseudonymizationResult;
-    
-    // Extract PII types from redaction results
-    const piiTypes: string[] = [];
-    const redactionTypes = redactionResult?.patternsMatched || [];
-    
-    // Map patterns to PII types
-    redactionTypes.forEach(pattern => {
-      if (pattern.includes('email')) piiTypes.push('email');
-      else if (pattern.includes('phone')) piiTypes.push('phone');
-      else if (pattern.includes('ssn')) piiTypes.push('ssn');
-      else if (pattern.includes('credit')) piiTypes.push('credit_card');
-      else if (pattern.includes('key')) piiTypes.push('api_key');
-      else piiTypes.push('other');
-    });
-    
-    // Extract pseudonym information
-    const pseudonymTypes: string[] = [];
-    let pseudonymsUsed = 0;
-    
-    if (pseudonymResult?.pseudonyms) {
-      pseudonymsUsed = pseudonymResult.pseudonyms.length;
-      
-      // Extract types from pseudonym data
-      pseudonymResult.pseudonyms.forEach(pseudonym => {
-        pseudonymTypes.push(pseudonym.dataType);
-      });
-    }
-
-    return {
-      piiDetected: piiTypes.length > 0 || pseudonymsUsed > 0,
-      piiTypes: [...new Set(piiTypes)], // Remove duplicates
-      pseudonymsUsed,
-      pseudonymTypes: [...new Set(pseudonymTypes)], // Remove duplicates
-      redactionsApplied: redactionResult?.redactionCount || 0,
-      redactionTypes: [...new Set(redactionTypes)],
-      sanitizationTimeMs: sanitizationResult.processingTimeMs,
-      reversalContextSize: sanitizationResult.reversalContext 
-        ? JSON.stringify(sanitizationResult.reversalContext).length 
-        : 0,
-      sanitizationLevel: this.determineSanitizationLevel(piiTypes, pseudonymsUsed, redactionResult?.redactionCount || 0),
-    };
-  }
-
-  /**
-   * Determine the sanitization level based on what was processed
-   */
-  private determineSanitizationLevel(
-    piiTypes: string[],
-    pseudonymsUsed: number,
-    redactionsApplied: number
-  ): 'none' | 'basic' | 'standard' | 'strict' {
-    const totalActions = piiTypes.length + pseudonymsUsed + redactionsApplied;
-    
-    if (totalActions === 0) return 'none';
-    if (totalActions <= 2) return 'basic';
-    if (totalActions <= 5) return 'standard';
-    return 'strict';
-  }
-
-  /**
-   * Get cache statistics
-   */
-  getCacheStats(): {
-    size: number;
-    maxSize: number;
-    expirationMs: number;
-  } {
-    return {
-      size: this.contextCache.size,
-      maxSize: this.maxCacheSize,
-      expirationMs: this.cacheExpirationMs,
-    };
-  }
-}
\ No newline at end of file
diff --git a/apps/api/src/llms/llm.controller.ts b/apps/api/src/llms/llm.controller.ts
index 11905bc..bc0d59f 100644
--- a/apps/api/src/llms/llm.controller.ts
+++ b/apps/api/src/llms/llm.controller.ts
@@ -40,8 +40,7 @@ export class LLMController {
         dataClassification?: string;
       };
     },
-  ): Promise<{ response: string; sanitizationMetadata?: any }> {
-
+  ): Promise<{ response: string; content?: string; sanitizationMetadata?: any; piiMetadata?: any; metadata?: any }> {
     try {
       const result = await this.llmService.generateResponse(
         request.systemPrompt,
@@ -63,14 +62,24 @@ export class LLMController {
         },
       );
 
+      console.log('üéÆ [CONTROLLER] Result type:', typeof result);
+      console.log('üéÆ [CONTROLLER] Result keys:', result && typeof result === 'object' ? Object.keys(result) : 'N/A');
+      console.log('üéÆ [CONTROLLER] Has piiMetadata?', result && typeof result === 'object' ? !!result.piiMetadata : false);
+
       // Handle both string and object responses
       if (typeof result === 'string') {
         return { response: result };
       } else {
-        return { 
+        // Return all relevant fields from the LLM service response
+        const response = { 
           response: result.content || result.response || result,
-          sanitizationMetadata: result.sanitizationMetadata
+          content: result.content || result.response || result,
+          sanitizationMetadata: result.sanitizationMetadata,
+          piiMetadata: result.piiMetadata,
+          metadata: result.metadata
         };
+        console.log('üéÆ [CONTROLLER] Returning response with piiMetadata?', !!response.piiMetadata);
+        return response;
       }
     } catch (error) {
 
diff --git a/apps/api/src/llms/llm.module.ts b/apps/api/src/llms/llm.module.ts
index e7807cb..ad21fc6 100644
--- a/apps/api/src/llms/llm.module.ts
+++ b/apps/api/src/llms/llm.module.ts
@@ -2,7 +2,6 @@ import { Module } from '@nestjs/common';
 import { HttpModule } from '@nestjs/axios';
 import { LLMService } from './llm.service';
 import { LLMController } from './llm.controller';
-import { SanitizationManagementController } from './sanitization-management.controller';
 import { SupabaseModule } from '../supabase/supabase.module';
 import { CIDAFMModule } from '../cidafm/cidafm.module';
 import { SovereignPolicyModule } from '../config/sovereign-policy.module';
@@ -14,7 +13,6 @@ import { ProviderConfigService } from './provider-config.service';
 import { SecretRedactionService } from './secret-redaction.service';
 import { PIIPatternService } from './pii-pattern.service';
 import { PseudonymizationService } from './pseudonymization.service';
-import { DataSanitizationService } from './data-sanitization.service';
 import { LocalModelStatusService } from './local-model-status.service';
 import { LocalLLMService } from './local-llm.service';
 import { MemoryManagerService } from './memory-manager.service';
@@ -35,7 +33,7 @@ import { GrokLLMService } from './services/grok-llm.service';
 
 @Module({
   imports: [SupabaseModule, CIDAFMModule, SovereignPolicyModule, FeatureFlagModule, ModelConfigurationModule, HttpModule],
-  controllers: [LLMController, SanitizationManagementController, LlmUsageController, ProductionOptimizationController],
+  controllers: [LLMController, LlmUsageController, ProductionOptimizationController],
   providers: [
     LLMService,
     CentralizedRoutingService,
@@ -44,7 +42,6 @@ import { GrokLLMService } from './services/grok-llm.service';
     SecretRedactionService,
     PIIPatternService,
     PseudonymizationService,
-    DataSanitizationService,
     LocalModelStatusService,
     LocalLLMService,
     MemoryManagerService,
@@ -66,7 +63,6 @@ import { GrokLLMService } from './services/grok-llm.service';
     SecretRedactionService,
     PIIPatternService,
     PseudonymizationService,
-    DataSanitizationService,
     LocalModelStatusService,
     LocalLLMService,
     MemoryManagerService,
diff --git a/apps/api/src/llms/llm.service.ts b/apps/api/src/llms/llm.service.ts
index 95e7141..2a044e2 100644
--- a/apps/api/src/llms/llm.service.ts
+++ b/apps/api/src/llms/llm.service.ts
@@ -11,7 +11,6 @@ import { CIDAFMService } from '../cidafm/cidafm.service';
 import { CentralizedRoutingService } from './centralized-routing.service';
 import { RunMetadataService, RunMetadata } from './run-metadata.service';
 import { ProviderConfigService } from './provider-config.service';
-import { DataSanitizationService, DetailedSanitizationMetrics } from './data-sanitization.service';
 import { PIIService } from '../services/pii.service';
 import { DictionaryPseudonymizerService } from '../services/dictionary-pseudonymizer.service';
 import { PIIProcessingMetadata } from '../common/types/pii-metadata.types';
@@ -74,7 +73,6 @@ export class LLMService {
     private readonly centralizedRoutingService: CentralizedRoutingService,
     private readonly runMetadataService: RunMetadataService,
     private readonly providerConfigService: ProviderConfigService,
-    private readonly dataSanitizationService: DataSanitizationService,
     private readonly piiService: PIIService,
     private readonly dictionaryPseudonymizerService: DictionaryPseudonymizerService,
     private readonly localModelStatusService: LocalModelStatusService,
@@ -143,6 +141,45 @@ export class LLMService {
         this.logger.debug(`üîç [LLM-PII-DEBUG] Received options.piiMetadata:`, options?.piiMetadata);
         this.logger.debug(`üîç [LLM-PII-DEBUG] Received options.routingDecision:`, options?.routingDecision);
 
+        // === PII PROCESSING BEFORE FACTORY CALL ===
+        let processedUserMessage = userMessage;
+        let dictionaryMappings: any[] = [];
+        let enhancedPiiMetadata = options?.piiMetadata;
+
+        // Only process PII for non-Ollama providers
+        if (options.providerName.toLowerCase() !== 'ollama' && !enhancedPiiMetadata) {
+          console.log('üîç [LLM-SERVICE] Processing PII for provider:', options.providerName);
+          
+          // 1. Check for flaggings using PII service
+          const piiPolicyResult = await this.piiService.checkPolicy(userMessage, {
+            provider: options.providerName,
+            providerName: options.providerName
+          });
+
+          // 2. Apply dictionary pseudonymization
+          const pseudonymResult = await this.dictionaryPseudonymizerService.pseudonymizeText(userMessage);
+          processedUserMessage = pseudonymResult.pseudonymizedText;
+          dictionaryMappings = pseudonymResult.mappings;
+
+          // 3. Build complete PII metadata
+          enhancedPiiMetadata = {
+            ...piiPolicyResult.metadata,
+            pseudonymsApplied: pseudonymResult.mappings.map(m => ({
+              original: m.originalValue,
+              pseudonym: m.pseudonym,
+              type: m.dataType
+            })),
+            piiDetected: piiPolicyResult.metadata.piiDetected || pseudonymResult.mappings.length > 0,
+            flaggings: piiPolicyResult.metadata.detectionResults?.flaggedMatches || [],
+            processingTimeMs: (piiPolicyResult.metadata.timestamps?.policyCheck || Date.now()) - 
+                             (piiPolicyResult.metadata.timestamps?.detectionStart || Date.now()) + 
+                             pseudonymResult.processingTimeMs,
+            sanitizationLevel: pseudonymResult.mappings.length > 0 ? 'standard' : 'none'
+          };
+
+          console.log(`üéØ [LLM-SERVICE] PII complete - flags: ${piiPolicyResult.metadata.detectionResults?.flaggedMatches?.length || 0}, pseudonyms: ${pseudonymResult.mappings.length}`);
+        }
+
         // Use the new unified LLM service factory approach
         const config: LLMServiceConfig = {
           provider: options.providerName as any,
@@ -153,7 +190,7 @@ export class LLMService {
 
         const factoryParams: GenerateResponseParams = {
           systemPrompt,
-          userMessage,
+          userMessage: processedUserMessage, // Use processed message
           config,
           options: {
             callerType: options.callerType,
@@ -164,14 +201,32 @@ export class LLMService {
             authToken: options.authToken,
             currentUser: options.currentUser,
             dataClassification: options.dataClassification,
-            // Pass PII metadata from routing decision
-            piiMetadata: (options as any)?.piiMetadata,
+            // Pass enhanced PII metadata and mappings
+            piiMetadata: enhancedPiiMetadata,
+            dictionaryMappings: dictionaryMappings,
             routingDecision: (options as any)?.routingDecision,
           }
         };
 
         const unifiedResult = await this.llmServiceFactory.generateResponse(config, factoryParams);
 
+        // Apply reverse pseudonymization if we have mappings
+        if (dictionaryMappings && dictionaryMappings.length > 0 && unifiedResult.content) {
+          const reverseResult = await this.dictionaryPseudonymizerService.reversePseudonyms(
+            unifiedResult.content,
+            dictionaryMappings
+          );
+          unifiedResult.content = reverseResult.originalText;
+          this.logger.debug(`üîÑ [LLM-SERVICE] Reversed ${reverseResult.reversalCount} pseudonyms in response`);
+        }
+
+        // Ensure PII metadata is included in response
+        if (enhancedPiiMetadata) {
+          unifiedResult.piiMetadata = enhancedPiiMetadata;
+          console.log('‚úÖ [LLM-SERVICE] Added PII metadata to response');
+        }
+
+        console.log('üì¶ [LLM-SERVICE] Returning result with keys:', Object.keys(unifiedResult));
         // Return the result (string or object based on includeMetadata)
         return unifiedResult;
       }
@@ -408,6 +463,54 @@ export class LLMService {
         throw new Error(`Unsupported provider: ${params.provider}. Supported providers: ${supportedProviders.join(', ')}`);
       }
 
+      // === PII PROCESSING AT LLM SERVICE LEVEL ===
+      // Skip PII processing for Ollama (local models don't need sanitization)
+      let enhancedPiiMetadata = params.options?.piiMetadata;
+      let processedUserMessage = params.userMessage;
+      let dictionaryMappings: any[] = [];
+
+      // Only process PII for non-Ollama providers
+      if (params.provider.toLowerCase() === 'ollama') {
+        this.logger.debug('üè† [LLM-SERVICE] Skipping PII processing for Ollama (local model)');
+      } else if (!enhancedPiiMetadata) {
+        this.logger.debug('üîç [LLM-SERVICE] No PII metadata provided, performing PII processing at LLM Service level for provider:', params.provider);
+        
+        // 1. Check for flaggings using PII service (NOT showstoppers - those are handled at agent level)
+        const piiPolicyResult = await this.piiService.checkPolicy(params.userMessage, {
+          provider: params.provider,
+          providerName: params.provider
+        });
+
+        // 2. Apply dictionary pseudonymization
+        const pseudonymResult = await this.dictionaryPseudonymizerService.pseudonymizeText(params.userMessage);
+        processedUserMessage = pseudonymResult.pseudonymizedText;
+        dictionaryMappings = pseudonymResult.mappings;
+
+        // 3. Build complete PII metadata combining policy check and pseudonymization
+        enhancedPiiMetadata = {
+          ...piiPolicyResult.metadata,
+          // Add pseudonym information
+          pseudonymsApplied: pseudonymResult.mappings.map(m => ({
+            original: m.originalValue,
+            pseudonym: m.pseudonym,
+            type: m.dataType
+          })),
+          // Update PII detected flag if pseudonyms were applied
+          piiDetected: piiPolicyResult.metadata.piiDetected || pseudonymResult.mappings.length > 0,
+          // Add processing times
+          processingTimeMs: (piiPolicyResult.metadata.timestamps?.policyCheck || Date.now()) - 
+                           (piiPolicyResult.metadata.timestamps?.detectionStart || Date.now()) + 
+                           pseudonymResult.processingTimeMs,
+          sanitizationLevel: pseudonymResult.mappings.length > 0 ? 'standard' : 'none'
+        };
+
+        this.logger.debug(`üéØ [LLM-SERVICE] PII Processing complete:`, {
+          flaggingsFound: piiPolicyResult.metadata.detectionResults?.flaggedMatches?.length || 0,
+          pseudonymsApplied: pseudonymResult.mappings.length,
+          textModified: processedUserMessage !== params.userMessage
+        });
+      }
+
       // Create LLM service configuration
       const config: LLMServiceConfig = {
         provider: params.provider,
@@ -416,10 +519,10 @@ export class LLMService {
         maxTokens: params.options?.maxTokens,
       };
 
-      // Create GenerateResponseParams for the factory
+      // Create GenerateResponseParams for the factory with enhanced PII metadata
       const factoryParams: GenerateResponseParams = {
         systemPrompt: params.systemPrompt,
-        userMessage: params.userMessage,
+        userMessage: processedUserMessage, // Use processed message with pseudonyms
         config,
         conversationId: params.options?.conversationId,
         sessionId: params.options?.sessionId,
@@ -432,14 +535,30 @@ export class LLMService {
           dataClassification: params.options?.dataClassification,
           authToken: params.options?.authToken,
           currentUser: params.options?.currentUser,
-          // Pass PII metadata from routing decision
-          piiMetadata: params.options?.piiMetadata,
+          // Pass enhanced PII metadata and dictionary mappings
+          piiMetadata: enhancedPiiMetadata,
+          dictionaryMappings: dictionaryMappings,
           routingDecision: params.options?.routingDecision,
         },
       };
 
       // Use the LLMServiceFactory to generate the response
       const response = await this.llmServiceFactory.generateResponse(config, factoryParams);
+      
+      // Apply reverse pseudonymization if we have mappings
+      if (dictionaryMappings && dictionaryMappings.length > 0 && response.content) {
+        const reverseResult = await this.dictionaryPseudonymizerService.reversePseudonyms(
+          response.content,
+          dictionaryMappings
+        );
+        response.content = reverseResult.originalText;
+        this.logger.debug(`üîÑ [LLM-SERVICE] Reversed ${reverseResult.reversalCount} pseudonyms in response`);
+      }
+
+      // Ensure PII metadata is included in response
+      if (enhancedPiiMetadata) {
+        response.piiMetadata = enhancedPiiMetadata;
+      }
 
       // Return either string or full response based on includeMetadata flag
       if (params.options?.includeMetadata) {
@@ -532,12 +651,7 @@ export class LLMService {
 
     // Use LocalLLMService for local Ollama models - NO SANITIZATION needed
     if (routingDecision.isLocal && routingDecision.provider === 'ollama') {
-      await this.dataSanitizationService.debug(
-        'Using local Ollama - skipping sanitization',
-        undefined,
-        'CallProvider',
-        { provider: routingDecision.provider, model: routingDecision.model }
-      );
+      this.logger.debug('Using local Ollama - skipping sanitization');
 
       const response = await this.localLLMService.generateResponse({
         model: routingDecision.model,
@@ -602,12 +716,7 @@ export class LLMService {
     }
 
     // For EXTERNAL providers - apply sanitization before sending
-    await this.dataSanitizationService.debug(
-      'Using external provider - applying sanitization',
-      undefined,
-      'CallProvider',
-      { provider: routingDecision.provider, model: routingDecision.model }
-    );
+    this.logger.debug('Using external provider - applying sanitization');
 
     // NEW ARCHITECTURE: All PII processing is handled in the unified response method
     // This method receives already-processed content and just calls the LLM
diff --git a/apps/api/src/llms/llm.service.ts.backup b/apps/api/src/llms/llm.service.ts.backup
deleted file mode 100644
index 581516c..0000000
--- a/apps/api/src/llms/llm.service.ts.backup
+++ /dev/null
@@ -1,2004 +0,0 @@
-import { Injectable, Logger } from '@nestjs/common';
-import OpenAI from 'openai';
-import { ChatOpenAI } from '@langchain/openai';
-import { ChatAnthropic } from '@langchain/anthropic';
-import { ChatOllama } from '@langchain/ollama';
-import { ChatGoogleGenerativeAI } from '@langchain/google-genai';
-import { BaseChatModel } from '@langchain/core/language_models/chat_models';
-import { HumanMessage, SystemMessage, AIMessage } from '@langchain/core/messages';
-import { SupabaseService } from '../supabase/supabase.service';
-import { CIDAFMService } from '../cidafm/cidafm.service';
-import { CentralizedRoutingService } from './centralized-routing.service';
-import { RunMetadataService, RunMetadata } from './run-metadata.service';
-import { ProviderConfigService } from './provider-config.service';
-import { DataSanitizationService, DetailedSanitizationMetrics } from './data-sanitization.service';
-import { PIIService } from '../services/pii.service';
-import { PseudonymizerService } from '../services/pseudonymizer.service';
-import { DictionaryPseudonymizerService } from '../services/dictionary-pseudonymizer.service';
-import { PIIProcessingMetadata } from '../common/types/pii-metadata.types';
-import { LocalModelStatusService } from './local-model-status.service';
-import { LocalLLMService } from './local-llm.service';
-import { BlindedLLMService } from './blinded-llm.service';
-import { LLMServiceFactory } from './services/llm-service-factory';
-import {
-  UnifiedGenerateResponseParams,
-  LLMResponse,
-  LLMServiceConfig,
-} from './services/llm-interfaces';
-import {
-  Provider,
-  Model,
-  CostCalculation,
-  LLMUsageMetrics,
-  CIDAFMOptions,
-  SystemLLMConfigs,
-  SystemOperationType,
-  UserLLMPreferences,
-} from '../types/llm-evaluation';
-import { mapProviderFromDb, mapModelFromDb } from '../utils/case-converter';
-import { getTableName } from '../supabase/supabase.config';
-
-// Explicitly set LangSmith environment variables for automatic tracing
-// Support both the official LangSmith env vars and our custom ones for backward compatibility
-const langsmithEnabled =
-  process.env.LANGSMITH_TRACING === 'true' ||
-  process.env.LANGSMITH_ENABLED === 'true';
-const langsmithApiKey = process.env.LANGSMITH_API_KEY;
-const langsmithProject =
-  process.env.LANGSMITH_PROJECT ||
-  process.env.LANGSMITH_PROJECT_NAME ||
-  'orchestrator-ai';
-
-if (langsmithEnabled && langsmithApiKey) {
-  process.env.LANGCHAIN_TRACING_V2 = 'true';
-  process.env.LANGCHAIN_API_KEY = langsmithApiKey;
-  process.env.LANGCHAIN_PROJECT = langsmithProject;
-  if (process.env.LANGSMITH_ENDPOINT) {
-    process.env.LANGCHAIN_ENDPOINT = process.env.LANGSMITH_ENDPOINT;
-  }
-}
-
-@Injectable()
-export class LLMService {
-  private readonly logger = new Logger(LLMService.name);
-  private openai: OpenAI | null = null;
-  public readonly systemLLMConfigs: SystemLLMConfigs;
-  private llmServiceFactory: LLMServiceFactory;
-
-  constructor(
-    private readonly supabaseService: SupabaseService,
-    private readonly cidafmService: CIDAFMService,
-    private readonly centralizedRoutingService: CentralizedRoutingService,
-    private readonly runMetadataService: RunMetadataService,
-    private readonly providerConfigService: ProviderConfigService,
-    private readonly dataSanitizationService: DataSanitizationService,
-    private readonly piiService: PIIService,
-    private readonly pseudonymizerService: PseudonymizerService,
-    private readonly dictionaryPseudonymizerService: DictionaryPseudonymizerService,
-    private readonly localModelStatusService: LocalModelStatusService,
-    private readonly localLLMService: LocalLLMService,
-    private readonly blindedLLMService: BlindedLLMService,
-    private readonly llmServiceFactoryInstance: LLMServiceFactory,
-  ) {
-
-    // Initialize OpenAI client only if API key is available
-    if (process.env.OPENAI_API_KEY) {
-      this.openai = new OpenAI({
-        apiKey: process.env.OPENAI_API_KEY,
-      });
-
-    } else {
-
-    }
-
-    // Initialize system LLM configurations for different orchestrator operations
-    // Each operation type can have its own optimized configuration
-    this.systemLLMConfigs = {
-      delegation: {
-        provider: (process.env.SYSTEM_DELEGATION_LLM_PROVIDER as any) || 'disabled',
-        model: process.env.SYSTEM_DELEGATION_LLM_MODEL || 'disabled',
-        temperature: parseFloat(
-          process.env.SYSTEM_DELEGATION_LLM_TEMPERATURE || '0.0',
-        ),
-        maxTokens: parseInt(
-          process.env.SYSTEM_DELEGATION_LLM_MAX_TOKENS || '300',
-        ),
-        enabled: process.env.SYSTEM_DELEGATION_LLM_ENABLED !== 'false' && 
-                 !!process.env.SYSTEM_DELEGATION_LLM_PROVIDER && 
-                 !!process.env.SYSTEM_DELEGATION_LLM_MODEL,
-        description: 'Fast delegation decisions - which agent to use',
-      },
-      agent_selection: {
-        provider: (process.env.SYSTEM_AGENT_SELECTION_LLM_PROVIDER as any) || 'disabled',
-        model: process.env.SYSTEM_AGENT_SELECTION_LLM_MODEL || 'disabled',
-        temperature: parseFloat(
-          process.env.SYSTEM_AGENT_SELECTION_LLM_TEMPERATURE || '0.1',
-        ),
-        maxTokens: parseInt(
-          process.env.SYSTEM_AGENT_SELECTION_LLM_MAX_TOKENS || '400',
-        ),
-        enabled: process.env.SYSTEM_AGENT_SELECTION_LLM_ENABLED !== 'false' && 
-                 !!process.env.SYSTEM_AGENT_SELECTION_LLM_PROVIDER && 
-                 !!process.env.SYSTEM_AGENT_SELECTION_LLM_MODEL,
-        description: 'Agent selection and matching logic',
-      },
-      response_coordination: {
-        provider: (process.env.SYSTEM_RESPONSE_COORD_LLM_PROVIDER as any) || 'disabled',
-        model: process.env.SYSTEM_RESPONSE_COORD_LLM_MODEL || 'disabled',
-        temperature: parseFloat(
-          process.env.SYSTEM_RESPONSE_COORD_LLM_TEMPERATURE || '0.2',
-        ),
-        maxTokens: parseInt(
-          process.env.SYSTEM_RESPONSE_COORD_LLM_MAX_TOKENS || '800',
-        ),
-        enabled: process.env.SYSTEM_RESPONSE_COORD_LLM_ENABLED !== 'false' && 
-                 !!process.env.SYSTEM_RESPONSE_COORD_LLM_PROVIDER && 
-                 !!process.env.SYSTEM_RESPONSE_COORD_LLM_MODEL,
-        description: 'Response coordination and organization',
-      },
-      conversation_analysis: {
-        provider: (process.env.SYSTEM_CONVERSATION_LLM_PROVIDER as any) || 'disabled',
-        model: process.env.SYSTEM_CONVERSATION_LLM_MODEL || 'disabled',
-        temperature: parseFloat(
-          process.env.SYSTEM_CONVERSATION_LLM_TEMPERATURE || '0.1',
-        ),
-        maxTokens: parseInt(
-          process.env.SYSTEM_CONVERSATION_LLM_MAX_TOKENS || '600',
-        ),
-        enabled: process.env.SYSTEM_CONVERSATION_LLM_ENABLED !== 'false' && 
-                 !!process.env.SYSTEM_CONVERSATION_LLM_PROVIDER && 
-                 !!process.env.SYSTEM_CONVERSATION_LLM_MODEL,
-        description: 'Conversation context analysis',
-      },
-      error_handling: {
-        provider: (process.env.SYSTEM_ERROR_LLM_PROVIDER as any) || 'disabled',
-        model: process.env.SYSTEM_ERROR_LLM_MODEL || 'disabled',
-        temperature: parseFloat(
-          process.env.SYSTEM_ERROR_LLM_TEMPERATURE || '0.0',
-        ),
-        maxTokens: parseInt(process.env.SYSTEM_ERROR_LLM_MAX_TOKENS || '200'),
-        enabled: process.env.SYSTEM_ERROR_LLM_ENABLED !== 'false' && 
-                 !!process.env.SYSTEM_ERROR_LLM_PROVIDER && 
-                 !!process.env.SYSTEM_ERROR_LLM_MODEL,
-        description: 'Error handling and fallback operations',
-      },
-      default: {
-        provider: (process.env.SYSTEM_DEFAULT_LLM_PROVIDER as any) || 'disabled',
-        model: process.env.SYSTEM_DEFAULT_LLM_MODEL || 'disabled',
-        temperature: parseFloat(
-          process.env.SYSTEM_DEFAULT_LLM_TEMPERATURE || '0.1',
-        ),
-        maxTokens: parseInt(process.env.SYSTEM_DEFAULT_LLM_MAX_TOKENS || '500'),
-        enabled: process.env.SYSTEM_DEFAULT_LLM_ENABLED !== 'false' && 
-                 !!process.env.SYSTEM_DEFAULT_LLM_PROVIDER && 
-                 !!process.env.SYSTEM_DEFAULT_LLM_MODEL,
-        description: 'Default system operations',
-      },
-    };
-
-    Object.entries(this.systemLLMConfigs).forEach(([operation, config]) => {
-
-    });
-
-    // Initialize the LLM service factory
-    this.llmServiceFactory = this.llmServiceFactoryInstance;
-  }
-
-  /**
-   * Simple LLM call with system and user messages - using LangChain for automatic LangSmith tracing
-   */
-  async generateResponse(
-    systemPrompt: string,
-    userMessage: string,
-    options?: {
-      temperature?: number;
-      maxTokens?: number;
-      provider?: 'openai' | 'anthropic' | 'ollama' | 'google';
-      // Support full LLM preferences from UI
-      providerName?: string;
-      modelName?: string;
-      cidafmOptions?: CIDAFMOptions;
-      authToken?: string;
-      sessionId?: string;
-      currentUser?: any; // User object with id, email, etc.
-      userId?: string; // Direct user ID for usage tracking
-      // Intelligent routing hints
-      complexity?: 'simple' | 'medium' | 'complex' | 'reasoning'; // Task complexity for routing decisions
-      // Caller tracking for usage analytics
-      callerType?: string; // 'agent', 'api', 'user', 'system', 'service'
-      callerName?: string; // 'metrics-agent', 'user-chat', 'api-endpoint', etc.
-      conversationId?: string; // Optional conversation/session context
-      dataClassification?: string; // 'public', 'internal', 'confidential', 'restricted'
-      // Return format control
-      includeMetadata?: boolean; // If true, return object with metadata instead of just string
-    },
-  ): Promise<string | any> {
-    this.logger.debug(`üîç [LLM-USAGE-DEBUG] generateResponse called with callerType: ${options?.callerType}, callerName: ${options?.callerName}, providerName: ${options?.providerName}, modelName: ${options?.modelName}`);
-    try {
-      // Debug LLM options being received
-
-      // If providerName/modelName are provided, delegate to enhanced response for proper DB lookup
-      if (options?.providerName || options?.modelName || options?.cidafmOptions) {
-        this.logger.debug(`üîç [LLM-USAGE-DEBUG] Delegating to generateEnhancedResponse`);
-
-        // Extract user ID from userId field or currentUser object
-        const userId = options.userId || options.currentUser?.id;
-
-        const enhancedResult = await this.generateEnhancedResponse(
-          userId,
-          systemPrompt,
-          userMessage,
-          {
-            provider: options.providerName,
-            model: options.modelName,
-            cidafmOptions: options.cidafmOptions,
-            sessionId: options.sessionId,
-            temperature: options.temperature,
-            maxTokens: options.maxTokens,
-            // Pass caller tracking options
-            callerType: options.callerType,
-            callerName: options.callerName,
-            conversationId: options.conversationId,
-            dataClassification: options.dataClassification,
-          },
-        );
-
-        // Return just the content for backward compatibility with simple method
-        return enhancedResult.content;
-      }
-
-      // Use centralized routing for intelligent provider/model selection
-      // Only use centralized routing if no explicit provider/model is specified
-      const hasExplicitSelection = (options?.provider || options?.providerName) && options?.modelName;
-      
-      // Use centralized routing if there's no explicit selection (regardless of routing hints)
-      if (!hasExplicitSelection) {
-        const centralizedResult = await this.generateCentralizedResponse(
-          systemPrompt,
-          userMessage,
-          {
-            temperature: options?.temperature,
-            maxTokens: options?.maxTokens,
-            // Map frontend field names to routing service field names
-            provider: options?.provider || options?.providerName,
-            model: options?.modelName,
-            preferLocal: true, // Default to preferring local models
-            maxComplexity: options?.complexity, // Pass complexity hint to routing
-            authToken: options?.authToken,
-            sessionId: options?.sessionId,
-            currentUser: options?.currentUser,
-            callerType: options?.callerType,
-            callerName: options?.callerName,
-            conversationId: options?.conversationId,
-            dataClassification: options?.dataClassification,
-          },
-        );
-
-        // Return just the content for backward compatibility
-        return centralizedResult.content;
-      }
-
-      // Original simple implementation for backward compatibility
-      const provider = options?.provider || options?.providerName;
-      
-      // No fallback - require explicit provider configuration
-      if (!provider) {
-        throw new Error(
-          'No LLM provider specified. Please provide either "provider" or "providerName" in options. ' +
-          'Available providers: ollama, anthropic, openai, google'
-        );
-      }
-      
-      const isLocalProvider = provider === 'ollama';
-      
-      this.logger.log(`üîç [SIMPLE-LLM-DEBUG] Simple response path - provider: ${provider}, isLocal: ${isLocalProvider}`);
-      this.logger.log(`üîç [SIMPLE-LLM-DEBUG] User message preview: "${userMessage.substring(0, 100)}..."`);
-
-      // Apply conditional sanitization using unified PII service
-      // Generate request ID for pseudonymization context
-      const requestId = options?.conversationId || options?.sessionId || `simple-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
-      
-      // Step 1: Dictionary-based pseudonymization for external providers
-      let sanitizedUserMessage = userMessage;
-      let sanitizationContext: any = null;
-      
-      if (!isLocalProvider) {
-        const pseudonymResult = await this.dictionaryPseudonymizerService.pseudonymizeText(userMessage);
-        sanitizedUserMessage = pseudonymResult.pseudonymizedText;
-        sanitizationContext = {
-          mappings: pseudonymResult.mappings,
-          processingTimeMs: pseudonymResult.processingTimeMs
-        };
-        
-        this.logger.log(`üéØ [DICTIONARY-PSEUDONYMIZER] Simple path pseudonymization completed: ${pseudonymResult.mappings.length} replacements in ${pseudonymResult.processingTimeMs}ms`);
-        if (pseudonymResult.mappings.length > 0) {
-          pseudonymResult.mappings.forEach((mapping: any) => {
-            this.logger.log(`üéØ [DICTIONARY-PSEUDONYMIZER] "${mapping.originalValue}" ‚Üí "${mapping.pseudonym}"`);
-          });
-        }
-      } else {
-        this.logger.log(`üéØ [DICTIONARY-PSEUDONYMIZER] Skipping pseudonymization for local provider: ${provider}`);
-      }
-
-      const sanitizedSystemPrompt = systemPrompt; // System prompts typically don't contain user PII
-
-      // Start usage tracking for simple path
-      const routingDecision = {
-        provider: provider,
-        model: options?.modelName || 'default',
-        tier: provider === 'ollama' ? 'local' : 'external',
-        isLocal: provider === 'ollama',
-        routingReason: 'simple-path-default'
-      };
-
-      const metadataContext = await this.runMetadataService.startRequest(routingDecision, {
-        userId: options?.userId || options?.currentUser?.id, // Accept userId directly or from currentUser object
-        callerType: options?.callerType || 'system',
-        callerName: options?.callerName || 'simple-llm',
-        conversationId: options?.conversationId, // Use proper conversation ID from current system
-        dataClassification: options?.dataClassification || 'internal',
-      });
-
-      try {
-        // Use LangChain LLM instead of raw OpenAI - this gets automatic LangSmith tracing
-        const llm =
-          options?.temperature || options?.maxTokens || options?.provider
-            ? this.createCustomLangGraphLLM({
-                provider: provider as any,
-                model: options?.modelName,
-                temperature: options?.temperature,
-                maxTokens: options?.maxTokens,
-              })
-            : this.getLangGraphLLM(provider as any);
-
-        // Format messages for the specific provider - LLM service controls the format
-        const messages = this.formatMessagesForProvider(
-          sanitizedSystemPrompt,
-          sanitizedUserMessage,
-          provider,
-          options?.modelName
-        );
-        
-        // Add debug logging to see what's being sent
-        this.logger.debug('üîç [LLM-DEBUG] Messages being sent to LLM:', JSON.stringify(messages, null, 2));
-        this.logger.debug('üîç [LLM-DEBUG] Provider:', provider);
-        this.logger.debug('üîç [LLM-DEBUG] Model:', options?.modelName);
-
-        const response = await llm.invoke(messages);
-      let content = (response.content as string) || 'I apologize, but I was unable to generate a response.';
-
-      // Step 2: Reverse pseudonyms in the response
-      if (sanitizationContext && sanitizationContext.mappings && sanitizationContext.mappings.length > 0) {
-        const reversalResult = await this.dictionaryPseudonymizerService.reversePseudonyms(
-          content,
-          sanitizationContext.mappings
-        );
-        content = reversalResult.originalText;
-        
-        this.logger.log(`üîÑ [DICTIONARY-PSEUDONYMIZER] Simple path reversal completed: ${reversalResult.reversalCount} reversals in ${reversalResult.processingTimeMs}ms`);
-        
-        if (reversalResult.reversalCount === 0 && sanitizationContext.mappings.length > 0) {
-          this.logger.warn(`üîÑ [DICTIONARY-PSEUDONYMIZER] Expected reversals but none found - LLM may not have used the pseudonyms`);
-        }
-      }
-
-      // Complete usage tracking for simple path
-      await this.runMetadataService.completeRequest(metadataContext, {
-        content: content,
-        inputTokens: 0, // LangChain doesn't provide token counts easily
-        outputTokens: 0,
-      });
-
-      // Return metadata if requested (for HTTP API calls)
-      if (options?.includeMetadata) {
-        // Create metadata from dictionary-based pseudonymization results
-        const pseudonymizationMetadata = sanitizationContext ? {
-          pseudonymizationApplied: sanitizationContext.mappings.length > 0,
-          pseudonymCount: sanitizationContext.mappings.length,
-          processingTimeMs: sanitizationContext.processingTimeMs,
-          mappings: sanitizationContext.mappings.map((m: any) => ({
-            type: m.dataType,
-            originalLength: m.originalValue.length,
-            pseudonymLength: m.pseudonym.length
-          }))
-        } : {
-          pseudonymizationApplied: false,
-          pseudonymCount: 0,
-          processingTimeMs: 0,
-          mappings: []
-        };
-        
-        return {
-          content: content,
-          response: content, // For backward compatibility
-          sanitizationMetadata: pseudonymizationMetadata
-        };
-      }
-
-      return content;
-    } catch (error) {
-      // Complete usage tracking with error for simple path
-      if (metadataContext) {
-        try {
-          await this.runMetadataService.completeRequestWithError(
-            metadataContext,
-            error instanceof Error ? error : new Error(String(error))
-          );
-        } catch (trackingError) {
-          this.logger.error('Failed to complete usage tracking on error:', trackingError);
-        }
-      }
-
-      const errorMessage =
-        error instanceof Error ? error.message : String(error);
-      throw new Error(`LLM service error: ${errorMessage}`);
-    }
-  } catch (outerError) {
-    // Handle any errors in the try block setup
-    const errorMessage =
-      outerError instanceof Error ? outerError.message : String(outerError);
-    throw new Error(`LLM service error: ${errorMessage}`);
-  }
-  }
-
-  /**
-   * Unified generateResponse method - the new entry point for all LLM requests
-   * 
-   * This method consolidates the three existing response methods into a single unified interface
-   * that requires explicit provider and model specification and uses the new LLMServiceFactory
-   * architecture.
-   * 
-   * @param params - Unified parameters including provider, model, and messages
-   * @returns Promise<string | LLMResponse> - String content or full response object based on includeMetadata flag
-   */
-  async generateUnifiedResponse(params: UnifiedGenerateResponseParams): Promise<string | LLMResponse> {
-    this.logger.debug(`üîç [UNIFIED-LLM] generateUnifiedResponse called`, {
-      provider: params.provider,
-      model: params.model,
-      callerType: params.options?.callerType,
-      callerName: params.options?.callerName,
-      includeMetadata: params.options?.includeMetadata,
-    });
-
-    try {
-      // Validate required parameters
-      if (!params.provider) {
-        throw new Error('Missing required parameter: provider is required');
-      }
-      if (!params.model) {
-        throw new Error('Missing required parameter: model is required');
-      }
-      if (!params.systemPrompt) {
-        throw new Error('Missing required parameter: systemPrompt is required');
-      }
-      if (!params.userMessage) {
-        throw new Error('Missing required parameter: userMessage is required');
-      }
-
-      // Validate provider is supported
-      const supportedProviders = ['openai', 'anthropic', 'google', 'grok', 'ollama'];
-      if (!supportedProviders.includes(params.provider.toLowerCase())) {
-        throw new Error(`Unsupported provider: ${params.provider}. Supported providers: ${supportedProviders.join(', ')}`);
-      }
-
-      // Create LLM service configuration
-      const config: LLMServiceConfig = {
-        provider: params.provider,
-        model: params.model,
-        temperature: params.options?.temperature,
-        maxTokens: params.options?.maxTokens,
-      };
-
-      // Create GenerateResponseParams for the factory
-      const factoryParams = {
-        systemPrompt: params.systemPrompt,
-        userMessage: params.userMessage,
-        config,
-        conversationId: params.options?.conversationId,
-        sessionId: params.options?.sessionId,
-        userId: params.options?.userId,
-        options: {
-          temperature: params.options?.temperature,
-          maxTokens: params.options?.maxTokens,
-          callerType: params.options?.callerType,
-          callerName: params.options?.callerName,
-          dataClassification: params.options?.dataClassification,
-          authToken: params.options?.authToken,
-          currentUser: params.options?.currentUser,
-        },
-      };
-
-      // Use the LLMServiceFactory to generate the response
-      const response = await this.llmServiceFactory.generateResponse(config, factoryParams);
-
-      // Return either string or full response based on includeMetadata flag
-      if (params.options?.includeMetadata) {
-        return response;
-      } else {
-        return response.content;
-      }
-
-    } catch (error) {
-      this.logger.error(`üö® [UNIFIED-LLM] Error in generateUnifiedResponse`, {
-        provider: params.provider,
-        model: params.model,
-        error: error.message,
-      });
-      
-      const errorMessage = error instanceof Error ? error.message : String(error);
-      throw new Error(`Unified LLM service error: ${errorMessage}`);
-    }
-  }
-
-  // REMOVED: generateEnhancedResponse method - replaced by generateUnifiedResponse
-    systemPrompt: string,
-    userMessage: string,
-    options?: {
-      provider?: string;
-      model?: string;
-      cidafmOptions?: CIDAFMOptions;
-      sessionId?: string;
-      temperature?: number;
-      maxTokens?: number;
-      // Add caller tracking for usage analytics
-      callerType?: string;
-      callerName?: string;
-      conversationId?: string;
-      dataClassification?: string;
-    },
-  ): Promise<{
-    content: string;
-    usage: LLMUsageMetrics;
-    costCalculation: CostCalculation;
-    langsmithRunId?: string;
-    processedPrompt: string;
-    cidafmState?: any;
-    llmMetadata?: {
-      providerName: string;
-      modelName: string;
-      temperature?: number;
-      maxTokens?: number;
-      responseTimeMs?: number;
-    };
-    sanitizationMetadata?: any;
-  }> {
-    // Deprecation warning
-    console.warn('‚ö†Ô∏è  generateEnhancedResponse is deprecated. Please use generateUnifiedResponse instead.');
-    this.logger.warn('generateEnhancedResponse is deprecated. Please use generateUnifiedResponse instead.');
-    
-    this.logger.debug(`üîç [LLM-USAGE-DEBUG] generateEnhancedResponse called with userId: ${userId}, callerType: ${options?.callerType}, callerName: ${options?.callerName}`);
-    const startTime = Date.now();
-    let metadataContext: any = null;
-
-    try {
-
-      // Get provider and model information from database
-      const { provider, model } = await this.getProviderAndModel(
-        options?.provider,
-        options?.model,
-      );
-
-
-      // Start usage tracking
-      const routingDecision = {
-        provider: provider?.name?.toLowerCase() || 'unknown',
-        model: model?.name || 'unknown',
-        isLocal: provider?.name?.toLowerCase() === 'ollama',
-        modelTier: 'general', // Default tier for enhanced response
-        fallbackUsed: false,
-        complexityLevel: undefined,
-        complexityScore: undefined,
-        routingReason: 'enhanced-response-user-selection'
-      };
-
-      this.logger.debug(`üîç [LLM-USAGE-DEBUG] Starting usage tracking with routing decision:`, routingDecision);
-      metadataContext = await this.runMetadataService.startRequest(
-        routingDecision,
-        {
-          userId: userId,
-          callerType: options?.callerType || 'enhanced',
-          callerName: options?.callerName || 'enhanced-llm',
-          conversationId: options?.conversationId || options?.sessionId,
-          dataClassification: options?.dataClassification || 'internal'
-        }
-      );
-      this.logger.debug(`üîç [LLM-USAGE-DEBUG] Usage tracking started, runId: ${metadataContext?.runId}`);
-
-      // Process CIDAFM commands if provided
-      let processedPrompt = userMessage;
-      let cidafmState: any = {};
-
-      if (options?.cidafmOptions || options?.sessionId) {
-        const cidafmResult = await this.cidafmService.processMessage(
-          userId || 'anonymous',
-          userMessage,
-          options.cidafmOptions,
-          options.sessionId,
-        );
-
-        processedPrompt = cidafmResult.modifiedPrompt;
-        cidafmState = {
-          activeStateModifiers: cidafmResult.activeStateModifiers,
-          executedCommands: cidafmResult.executedCommands,
-          processingNotes: cidafmResult.processingNotes,
-        };
-      }
-
-      // Determine if provider is local (Ollama) or external
-      const isLocalProvider = provider.name.toLowerCase() === 'ollama';
-
-      // Apply state modifiers to system prompt if any
-      let enhancedSystemPrompt = this.applyStateModifiersToPrompt(
-        systemPrompt,
-        cidafmState.activeStateModifiers || [],
-      );
-      let finalProcessedPrompt = processedPrompt;
-      let sanitizationContext: any = null;
-
-      // Generate request ID for pseudonymization context
-      const requestId = options?.conversationId || options?.sessionId || `enhanced-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
-      
-      // Step 1: Dictionary-based pseudonymization before LLM call
-      // Only pseudonymize for external providers
-      let pseudonymResult: any = null;
-      if (!isLocalProvider) {
-        pseudonymResult = await this.dictionaryPseudonymizerService.pseudonymizeText(finalProcessedPrompt);
-      }
-
-      // Apply pseudonymization results if external provider
-      if (pseudonymResult) {
-        finalProcessedPrompt = pseudonymResult.pseudonymizedText;
-        sanitizationContext = pseudonymResult; // Store for reversal
-
-        this.logger.log(`üéØ [DICTIONARY-PSEUDONYMIZER] Enhanced pseudonymization applied: ${pseudonymResult.mappings.length} replacements in ${pseudonymResult.processingTimeMs}ms`);
-        if (pseudonymResult.mappings.length > 0) {
-          pseudonymResult.mappings.forEach((mapping: any) => {
-            this.logger.log(`üéØ [DICTIONARY-PSEUDONYMIZER] "${mapping.originalValue}" ‚Üí "${mapping.pseudonym}"`);
-          });
-        }
-      } else {
-        this.logger.log(`üéØ [DICTIONARY-PSEUDONYMIZER] Skipping pseudonymization for local provider: ${provider.name}`);
-      }
-
-      // Create sanitization metrics for compatibility
-      const sanitizationMetrics = {
-        sanitizationLevel: pseudonymResult && pseudonymResult.mappings.length > 0 ? 'pseudonymized' : 'none',
-        pseudonymCount: pseudonymResult ? pseudonymResult.mappings.length : 0,
-        processingTimeMs: pseudonymResult ? pseudonymResult.processingTimeMs : 0
-      };
-
-      // Create LLM instance with dynamic configuration
-      const llm = await this.createLLMFromModel(model, {
-        temperature: options?.temperature,
-        maxTokens: options?.maxTokens,
-      });
-
-      // Format messages for the specific provider - LLM service controls the format
-      const messages = this.formatMessagesForProvider(
-        enhancedSystemPrompt,
-        finalProcessedPrompt,
-        model.provider?.name || 'openai',
-        model.name
-      );
-
-      // Generate response with token counting
-      const response = await llm.invoke(messages);
-      let content = (response.content as string) || 'I apologize, but I was unable to generate a response.';
-
-      // Step 2: Reverse pseudonyms in the response
-      if (sanitizationContext && sanitizationContext.mappings && sanitizationContext.mappings.length > 0) {
-        const reversalResult = await this.dictionaryPseudonymizerService.reversePseudonyms(
-          content,
-          sanitizationContext.mappings
-        );
-        content = reversalResult.originalText;
-        
-        this.logger.log(`üîÑ [DICTIONARY-PSEUDONYMIZER] Reversal completed: ${reversalResult.reversalCount} reversals in ${reversalResult.processingTimeMs}ms`);
-        
-        if (reversalResult.reversalCount === 0 && sanitizationContext.mappings.length > 0) {
-          this.logger.warn(`üîÑ [DICTIONARY-PSEUDONYMIZER] Expected reversals but none found - LLM may not have used the pseudonyms`);
-        }
-      }
-
-      const endTime = Date.now();
-      const responseTimeMs = endTime - startTime;
-
-      // Calculate token usage (simplified estimation) using the content that was actually sent
-      const inputTokens = this.estimateTokens(
-        enhancedSystemPrompt + finalProcessedPrompt,
-      );
-      const outputTokens = this.estimateTokens(content);
-
-      // Calculate costs
-      const costCalculation = this.calculateCost(
-        inputTokens,
-        outputTokens,
-        model.pricingInputPer1k || 0,
-        model.pricingOutputPer1k || 0,
-      );
-
-      // Dictionary-based pseudonymization metadata for database tracking
-      const hasPiiProcessing = sanitizationContext && sanitizationContext.mappings && sanitizationContext.mappings.length > 0;
-      const pseudonymCount = sanitizationContext?.mappings?.length || 0;
-
-      const usage: LLMUsageMetrics = {
-        inputTokens: inputTokens,
-        outputTokens: outputTokens,
-        totalCost: costCalculation.totalCost,
-        responseTimeMs: responseTimeMs,
-        // langsmithRunId would be extracted from LangSmith tracing
-        
-        // Dictionary-based pseudonymization metrics
-        dataSanitizationApplied: hasPiiProcessing,
-        sanitizationLevel: hasPiiProcessing ? 'standard' : 'none' as 'none' | 'basic' | 'standard' | 'strict',
-        piiDetected: hasPiiProcessing,
-        piiTypes: sanitizationContext?.mappings?.map((m: any) => m.dataType) || [],
-        pseudonymsUsed: pseudonymCount,
-        pseudonymTypes: [...new Set(sanitizationContext?.mappings?.map((m: any) => m.dataType as string) || [])] as string[],
-        redactionsApplied: 0, // New architecture uses pseudonymization, not redaction
-        redactionTypes: [],
-        
-        // Source blinding metrics
-        sourceBlindingApplied: !isLocalProvider, // External providers use source blinding
-        headersStripped: !isLocalProvider ? 15 : 0, // Estimated number of headers stripped
-        customUserAgentUsed: !isLocalProvider,
-        
-        // Provider-specific privacy headers (assume all external providers support no-train)
-        noTrainHeaderSent: !isLocalProvider,
-        noRetainHeaderSent: false, // Most providers don't support no-retain yet
-        
-        // Data classification (could be enhanced based on content analysis)
-        dataClassification: 'public', // Default, could be inferred from content
-        policyProfile: 'standard',
-        sovereignMode: false,
-        
-        // Performance metrics
-        sanitizationTimeMs: sanitizationContext?.processingTimeMs || 0,
-        reversalContextSize: sanitizationContext?.mappings?.length || 0,
-        
-        // Dictionary-based compliance flags
-        complianceFlags: {
-          gdprCompliant: hasPiiProcessing && pseudonymCount > 0,
-          hipaaCompliant: false, // Dictionary-based approach doesn't have severity levels
-          pciCompliant: false, // Our dictionary doesn't contain credit card or SSN patterns
-        },
-      };
-
-      // Complete usage tracking
-      this.logger.debug(`üîç [LLM-USAGE-DEBUG] Completing usage tracking for runId: ${metadataContext?.runId}, inputTokens: ${inputTokens}, outputTokens: ${outputTokens}`);
-      const runMetadata = await this.runMetadataService.completeRequest(
-        metadataContext,
-        {
-          content,
-          inputTokens: inputTokens,
-          outputTokens: outputTokens,
-          enhancedMetrics: usage
-        }
-      );
-      this.logger.debug(`üîç [LLM-USAGE-DEBUG] Usage tracking completed successfully for runId: ${runMetadata?.runId}`);
-
-      return {
-        content,
-        usage,
-        costCalculation,
-        processedPrompt,
-        cidafmState,
-        // Include LLM metadata for transparency
-        llmMetadata: {
-          providerName: provider.name,
-          modelName: model.name,
-          temperature: options?.temperature,
-          maxTokens: options?.maxTokens,
-          responseTimeMs: responseTimeMs,
-        },
-        // Include sanitization metadata for frontend privacy indicators
-        sanitizationMetadata: await this.extractSanitizationMetadataForFrontend(sanitizationMetrics),
-      };
-
-      this.logger.log(`üîç [LLM-DEBUG] Final sanitization metadata for frontend:`, JSON.stringify(await this.extractSanitizationMetadataForFrontend(sanitizationMetrics), null, 2));
-    } catch (error) {
-      // Note: Usage tracking for failed requests would need to be implemented
-      // if we want to track failed enhanced LLM calls
-      const errorMessage =
-        error instanceof Error ? error.message : String(error);
-      throw new Error(`Enhanced LLM service error: ${errorMessage}`);
-    }
-  }
-
-  /**
-   * Centralized LLM call with routing, metadata tracking, and secret redaction
-   * 
-   * @deprecated This method is deprecated. Please use generateUnifiedResponse instead for new implementations.
-   * This method will be maintained for backward compatibility but may be removed in future versions.
-   */
-  async generateCentralizedResponse(
-    systemPrompt: string,
-    userMessage: string,
-    options?: {
-      temperature?: number;
-      maxTokens?: number;
-      provider?: string;
-      model?: string;
-      preferLocal?: boolean;
-      maxComplexity?: 'simple' | 'medium' | 'complex' | 'reasoning'; // Complexity hint for routing
-      authToken?: string;
-      sessionId?: string;
-      currentUser?: any;
-      userId?: string; // Direct user ID for usage tracking
-      // Caller tracking for usage analytics
-      callerType?: string; // 'agent', 'api', 'user', 'system', 'service'
-      callerName?: string; // 'metrics-agent', 'user-chat', 'api-endpoint', etc.
-      conversationId?: string; // Optional conversation/session context
-      dataClassification?: string; // 'public', 'internal', 'confidential', 'restricted'
-    },
-  ): Promise<{
-    content: string;
-    runMetadata: RunMetadata;
-    routingDecision: any;
-    piiMetadata?: PIIProcessingMetadata; // NEW: Include PII metadata in response
-  }> {
-    // Deprecation warning
-    console.warn('‚ö†Ô∏è  generateCentralizedResponse is deprecated. Please use generateUnifiedResponse instead.');
-    this.logger.warn('generateCentralizedResponse is deprecated. Please use generateUnifiedResponse instead.');
-    
-    const startTime = Date.now();
-
-    try {
-      // Step 1: Get routing decision from centralized routing service
-      await this.dataSanitizationService.debug(
-        'Starting centralized LLM request',
-        undefined,
-        'CentralizedLLM',
-        { systemPromptLength: systemPrompt.length, userMessageLength: userMessage.length }
-      );
-
-      const routingDecision = await this.centralizedRoutingService.determineRoute(
-        userMessage,
-        options
-      );
-
-      // Check if request was blocked by PII policy
-      if (routingDecision.provider === 'policy-blocked') {
-        this.logger.warn(`Request blocked by PII policy: ${routingDecision.model}`);
-        throw new Error(`Request blocked due to PII policy violation: ${routingDecision.model}`);
-      }
-
-      await this.dataSanitizationService.info(
-        `Routing decision: ${routingDecision.provider}/${routingDecision.model} (${routingDecision.isLocal ? 'local' : 'external'})`,
-        undefined,
-        'CentralizedLLM',
-        { routingDecision: routingDecision }
-      );
-
-      // Step 2: Start tracking metadata
-      const metadataContext = await this.runMetadataService.startRequest(routingDecision, {
-        userId: options?.userId || options?.currentUser?.id, // Accept userId directly or from currentUser object
-        callerType: options?.callerType || 'system',
-        callerName: options?.callerName || 'unknown',
-        conversationId: options?.sessionId || options?.conversationId,
-        dataClassification: options?.dataClassification,
-      });
-
-      try {
-        // Step 3: Get provider configuration
-        const providerConfig = this.providerConfigService.getEnhancedProviderConfig(routingDecision.provider);
-        if (!providerConfig) {
-          throw new Error(`Provider configuration not found: ${routingDecision.provider}`);
-        }
-
-        // Step 4: Add required headers
-        const headers = this.providerConfigService.getDefaultHeaders(routingDecision.provider, {
-          policyProfile: options?.sessionId ? 'session' : 'standard',
-          dataClass: 'public', // TODO: Make this configurable
-          sovereignMode: 'false', // TODO: Make this configurable
-          noTrain: true,
-          noRetain: false,
-        });
-
-        await this.dataSanitizationService.debug(
-          'Generated request headers',
-          metadataContext.runId,
-          'CentralizedLLM',
-          { headers }
-        );
-
-        // Step 5: NEW ARCHITECTURE - Apply boundary processing
-        let effectiveUserMessage = userMessage;
-        let effectiveSystemPrompt = systemPrompt;
-        let piiMetadata: PIIProcessingMetadata | undefined;
-
-        // Extract PII metadata from routing decision
-        if (routingDecision.piiMetadata) {
-          piiMetadata = routingDecision.piiMetadata;
-          
-          // If this is an external provider and we have pseudonym instructions, apply them
-          if (!routingDecision.isLocal && piiMetadata.pseudonymInstructions?.shouldPseudonymize) {
-            this.logger.debug(`üé≠ [LLM-BOUNDARY] Applying pseudonymization for external provider`);
-            
-            const requestId = options?.conversationId || options?.sessionId || `llm-${Date.now()}`;
-            
-            try {
-              // Apply dictionary-based pseudonymization to user message
-              const pseudonymResult = await this.dictionaryPseudonymizerService.pseudonymizeText(userMessage);
-              
-              effectiveUserMessage = pseudonymResult.pseudonymizedText;
-              
-              // Store pseudonym mappings in routing decision for reversal
-              (routingDecision as any).pseudonymMappings = pseudonymResult.mappings;
-              
-              this.logger.debug(`üéØ [DICTIONARY-PSEUDONYMIZER] Centralized pseudonymization applied: ${pseudonymResult.mappings.length} mappings created`);
-              
-            } catch (error) {
-              this.logger.error(`üéØ [DICTIONARY-PSEUDONYMIZER] Centralized pseudonymization failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
-              // Continue with original text if pseudonymization fails
-            }
-          } else {
-            this.logger.debug(`üé≠ [LLM-BOUNDARY] No pseudonymization needed (local: ${routingDecision.isLocal}, shouldPseudonymize: ${piiMetadata.pseudonymInstructions?.shouldPseudonymize})`);
-          }
-        }
-
-        // Step 6: Call provider with processed messages
-        const response = await this.callProviderWithRouting(
-          routingDecision as any, // Type conversion - routingDecision has piiMetadata from new architecture
-          effectiveSystemPrompt,
-          effectiveUserMessage,
-          headers,
-          options || {}
-        );
-
-        // Step 7: NEW ARCHITECTURE - Apply boundary reversal processing
-        let finalResponseContent = response.content;
-        
-        // If we applied pseudonymization, reverse it now
-        if (!routingDecision.isLocal && piiMetadata?.pseudonymInstructions?.shouldPseudonymize) {
-          this.logger.debug(`üîÑ [LLM-BOUNDARY] Reversing pseudonyms in response`);
-          
-          const requestId = options?.conversationId || options?.sessionId || `llm-${Date.now()}`;
-          
-          try {
-            // Use the stored mappings from pseudonymization step
-            const pseudonymMappings = (routingDecision as any).pseudonymMappings || [];
-            const reversalResult = await this.dictionaryPseudonymizerService.reversePseudonyms(
-              response.content,
-              pseudonymMappings
-            );
-            
-            finalResponseContent = reversalResult.originalText;
-            
-            this.logger.debug(`üîÑ [DICTIONARY-PSEUDONYMIZER] Centralized reversal completed: ${reversalResult.reversalCount} items restored`);
-            
-            // Update PII metadata with reversal results
-            if (piiMetadata) {
-              piiMetadata = {
-                ...piiMetadata,
-                pseudonymResults: piiMetadata.pseudonymResults ? {
-                  ...piiMetadata.pseudonymResults,
-                  reversalSuccess: true,
-                  reversalMatches: piiMetadata.pseudonymInstructions?.targetMatches || []
-                } : undefined
-              };
-            }
-            
-          } catch (error) {
-            this.logger.error(`üîÑ [LLM-BOUNDARY] Pseudonym reversal failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
-            // Continue with pseudonymized response if reversal fails
-          }
-        }
-
-        // Step 8: Complete metadata tracking with enhanced metrics (async, non-blocking)
-        const runMetadataPromise = this.runMetadataService.completeRequest(metadataContext, {
-          content: finalResponseContent,
-          inputTokens: response.inputTokens,
-          outputTokens: response.outputTokens,
-          enhancedMetrics: response.enhancedMetrics,
-        }).catch(error => {
-          this.logger.error(`Failed to complete usage tracking for ${metadataContext.runId}:`, error);
-        });
-
-        // Get essential metadata synchronously from context for immediate return
-        const runMetadata = {
-          runId: metadataContext.runId,
-          provider: metadataContext.provider,
-          model: metadataContext.model,
-          tier: metadataContext.tier,
-          cost: 0, // Will be calculated in background
-          duration: Date.now() - metadataContext.startTime,
-          timestamp: new Date().toISOString(),
-          inputTokens: response.inputTokens,
-          outputTokens: response.outputTokens,
-          status: 'completed' as const,
-          enhancedMetrics: response.enhancedMetrics,
-        };
-
-        await this.dataSanitizationService.info(
-          `Centralized LLM request completed successfully`,
-          runMetadata.runId,
-          'CentralizedLLM',
-          { 
-            duration: runMetadata.duration,
-            cost: runMetadata.cost,
-            provider: routingDecision.provider,
-            model: routingDecision.model
-          }
-        );
-
-        return {
-          content: finalResponseContent, // Use processed content with pseudonym reversal
-          runMetadata,
-          routingDecision,
-          piiMetadata, // Include PII metadata in response
-        };
-
-      } catch (error) {
-        // Handle errors and still return metadata (async, non-blocking)
-        this.runMetadataService.completeRequestWithError(metadataContext, error instanceof Error ? error : new Error('Unknown error')).catch(dbError => {
-          this.logger.error(`Failed to record error in usage tracking for ${metadataContext.runId}:`, dbError);
-        });
-
-        // Create immediate error metadata from context
-        const runMetadata = {
-          runId: metadataContext.runId,
-          provider: metadataContext.provider,
-          model: metadataContext.model,
-          tier: metadataContext.tier,
-          cost: 0,
-          duration: Date.now() - metadataContext.startTime,
-          timestamp: new Date().toISOString(),
-          status: 'error' as const,
-          errorMessage: error instanceof Error ? error.message : 'Unknown error',
-        };
-        
-        await this.dataSanitizationService.error(
-          `Centralized LLM request failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
-          runMetadata.runId,
-          'CentralizedLLM',
-          { error: error instanceof Error ? error.message : 'Unknown error', provider: routingDecision.provider }
-        );
-
-        throw new Error(`Centralized LLM request failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
-      }
-
-    } catch (error) {
-      await this.dataSanitizationService.error(
-        `Centralized routing failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
-        undefined,
-        'CentralizedLLM'
-      );
-      
-      throw new Error(`Centralized LLM service error: ${error instanceof Error ? error.message : 'Unknown error'}`);
-    }
-  }
-
-  /**
-   * Call provider using routing decision with conditional sanitization
-   */
-  private async callProviderWithRouting(
-    routingDecision: import('../common/types/pii-metadata.types').RoutingDecisionWithPII,
-    systemPrompt: string,
-    userMessage: string,
-    headers: any,
-    options: any
-  ): Promise<{
-    content: string;
-    inputTokens?: number;
-    outputTokens?: number;
-    enhancedMetrics?: LLMUsageMetrics;
-    sanitizationMetadata?: any;
-  }> {
-    // Use LocalLLMService for local Ollama models - NO SANITIZATION needed
-    if (routingDecision.isLocal && routingDecision.provider === 'ollama') {
-      await this.dataSanitizationService.debug(
-        'Using local Ollama - skipping sanitization',
-        undefined,
-        'CallProvider',
-        { provider: routingDecision.provider, model: routingDecision.model }
-      );
-
-      const response = await this.localLLMService.generateResponse({
-        model: routingDecision.model,
-        prompt: userMessage,
-        system: systemPrompt,
-        options: {
-          temperature: options.temperature,
-          max_tokens: options.maxTokens,
-        },
-      });
-
-      // Create enhanced metrics for local provider
-      const enhancedMetrics: LLMUsageMetrics = {
-        inputTokens: response.prompt_eval_count,
-        outputTokens: response.eval_count,
-        totalCost: 0, // Local models have no cost
-        responseTimeMs: 0, // Would be calculated by caller
-        
-        // No sanitization for local models
-        dataSanitizationApplied: false,
-        sanitizationLevel: 'none',
-        piiDetected: false,
-        piiTypes: [],
-        pseudonymsUsed: 0,
-        pseudonymTypes: [],
-        redactionsApplied: 0,
-        redactionTypes: [],
-        
-        // No source blinding for local models
-        sourceBlindingApplied: false,
-        headersStripped: 0,
-        customUserAgentUsed: false,
-        proxyUsed: false,
-        noTrainHeaderSent: false,
-        noRetainHeaderSent: false,
-        
-        // Performance metrics
-        sanitizationTimeMs: 0,
-        reversalContextSize: 0,
-        
-        // Data classification
-        dataClassification: 'public',
-        policyProfile: 'local',
-        sovereignMode: true, // Local = sovereign
-        
-        // Compliance flags for local processing
-        complianceFlags: {
-          gdprCompliant: true, // Local processing is GDPR compliant
-          hipaaCompliant: true, // Local processing is HIPAA compliant
-          pciCompliant: true, // Local processing is PCI compliant
-        },
-      };
-
-      return {
-        content: response.response,
-        inputTokens: response.prompt_eval_count,
-        outputTokens: response.eval_count,
-        enhancedMetrics,
-        // No sanitization metadata for local providers
-        sanitizationMetadata: null,
-      };
-    }
-
-    // For EXTERNAL providers - apply sanitization before sending
-    await this.dataSanitizationService.debug(
-      'Using external provider - applying sanitization',
-      undefined,
-      'CallProvider',
-      { provider: routingDecision.provider, model: routingDecision.model }
-    );
-
-    // NEW ARCHITECTURE: All PII processing is handled in generateCentralizedResponse
-    // This method receives already-processed content and just calls the LLM
-    const requestId = options.conversationId || options.sessionId || `callprovider-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
-
-    // Use LangChain for external providers
-    const llm = this.createCustomLangGraphLLM({
-      provider: routingDecision.provider as any,
-      model: routingDecision.model,
-      temperature: options.temperature,
-      maxTokens: options.maxTokens,
-    });
-
-    // Format messages for the specific provider - LLM service controls the format
-    const messages = this.formatMessagesForProvider(
-      systemPrompt,
-      userMessage,
-      routingDecision.provider,
-      routingDecision.model
-    );
-    
-    // Add debug logging to see what's being sent
-    this.logger.debug('üîç [CENTRALIZED-LLM-DEBUG] Messages being sent to LLM:', JSON.stringify(messages, null, 2));
-    this.logger.debug('üîç [CENTRALIZED-LLM-DEBUG] Provider:', routingDecision.provider);
-    this.logger.debug('üîç [CENTRALIZED-LLM-DEBUG] Model:', routingDecision.model);
-
-    const response = await llm.invoke(messages);
-    let responseContent = (response.content as string) || 'I apologize, but I was unable to generate a response.';
-
-    // Note: Pseudonym reversal is now handled in generateCentralizedResponse method
-    // This old reversal logic has been removed as part of the new architecture
-
-    // Estimate tokens (TODO: Get actual token counts from provider)
-    const inputTokens = this.estimateTokens(systemPrompt + userMessage);
-    const outputTokens = this.estimateTokens(responseContent);
-
-    // NEW ARCHITECTURE: Use PII metadata from routing decision instead of legacy sanitization metrics
-    const piiMetadata = routingDecision.piiMetadata;
-    const hasPiiProcessing = piiMetadata && piiMetadata.piiDetected;
-    const pseudonymCount = piiMetadata?.pseudonymInstructions?.targetMatches?.length || 0;
-
-    const enhancedMetrics: LLMUsageMetrics = {
-      inputTokens,
-      outputTokens,
-      totalCost: 0, // Would be calculated by caller
-      responseTimeMs: 0, // Would be calculated by caller
-      
-      // NEW ARCHITECTURE: Data sanitization metrics from PII metadata
-      dataSanitizationApplied: hasPiiProcessing,
-      sanitizationLevel: hasPiiProcessing ? 'standard' : 'none',
-      piiDetected: hasPiiProcessing,
-      piiTypes: Object.keys(piiMetadata?.detectionResults?.dataTypesSummary || {}),
-      pseudonymsUsed: pseudonymCount,
-      pseudonymTypes: piiMetadata?.pseudonymInstructions?.targetMatches?.map((m: any) => m.dataType) || [],
-      redactionsApplied: 0, // Redaction is separate from pseudonymization in new architecture
-      redactionTypes: [],
-      
-      // Source blinding metrics for external providers
-      sourceBlindingApplied: !routingDecision.isLocal,
-      headersStripped: !routingDecision.isLocal ? 15 : 0,
-      customUserAgentUsed: !routingDecision.isLocal,
-      proxyUsed: false,
-      noTrainHeaderSent: !routingDecision.isLocal,
-      noRetainHeaderSent: false,
-      
-      // Performance metrics from new architecture
-      sanitizationTimeMs: 0, // Processing time is tracked elsewhere in new architecture
-      reversalContextSize: piiMetadata ? JSON.stringify(piiMetadata).length : 0,
-      
-      // Data classification
-      dataClassification: options.dataClassification || 'public',
-      policyProfile: options.policyProfile || 'standard',
-      sovereignMode: routingDecision.isLocal || false,
-      
-      // NEW ARCHITECTURE: Compliance flags based on actual PII processing
-      complianceFlags: {
-        gdprCompliant: hasPiiProcessing && pseudonymCount > 0,
-        hipaaCompliant: hasPiiProcessing && pseudonymCount > 0,
-        pciCompliant: piiMetadata?.showstopperDetected === false, // No showstoppers = safer
-      },
-    };
-
-    return {
-      content: responseContent,
-      inputTokens,
-      outputTokens,
-      enhancedMetrics,
-      // NEW ARCHITECTURE: Include PII metadata for frontend privacy indicators
-      sanitizationMetadata: await this.extractSanitizationMetadataForFrontend({
-        sanitizationLevel: hasPiiProcessing ? 'standard' : 'none',
-        pseudonymCount: pseudonymCount,
-        processingTimeMs: 0 // Processing time tracked elsewhere in new architecture
-      }),
-    };
-  }
-
-  /**
-   * Get default headers for requests
-   */
-  private getDefaultHeaders(options: any, providerConfig: any): Record<string, string> {
-    return {
-      'X-Policy-Profile': options.policyProfile || 'standard',
-      'X-Data-Class': options.dataClass || 'public',
-      'X-Sovereign-Mode': options.sovereignMode || 'false',
-      ...providerConfig.headers,
-    };
-  }
-
-  /**
-   * Enhanced LLM call with conversation history support - using LangChain for automatic LangSmith tracing
-   */
-  async generateResponseWithHistory(
-    systemPrompt: string,
-    conversationHistory: Array<{ role: 'user' | 'assistant'; content: string }>,
-    currentMessage: string,
-  ): Promise<string> {
-    try {
-
-      // Use LangChain LLM instead of raw OpenAI - this gets automatic LangSmith tracing
-      const llm = this.getLangGraphLLM('openai');
-
-      // Build messages array with system prompt, conversation history, and current message
-      // Note: This method assumes OpenAI models, but we should check for o1 models
-      const messages: Array<{
-        role: 'system' | 'user' | 'assistant';
-        content: string;
-      }> = [];
-
-      // Check if this might be an o1 model (this method doesn't have model info, so we'll use a heuristic)
-      const isLikelyO1Model = false; // TODO: Add model detection if needed
-      
-      if (isLikelyO1Model) {
-        // For o1 models, combine system prompt with first user message
-        const firstUserMessage = conversationHistory.find(msg => msg.role === 'user')?.content || currentMessage;
-        const combinedMessage = systemPrompt 
-          ? `${systemPrompt}\n\nUser: ${firstUserMessage}`
-          : firstUserMessage;
-        
-        messages.push({
-          role: 'user',
-          content: combinedMessage,
-        });
-        
-        // Add remaining conversation history (skip the first user message if we used it)
-        conversationHistory.forEach((msg, index) => {
-          if (!(msg.role === 'user' && index === 0)) {
-            messages.push({
-              role: msg.role,
-              content: msg.content,
-            });
-          }
-        });
-        
-        // Add current message if it wasn't the first user message
-        if (conversationHistory.length === 0 || conversationHistory[0]?.role !== 'user') {
-          messages.push({
-            role: 'user',
-            content: currentMessage,
-          });
-        }
-      } else {
-        // Standard model handling
-        messages.push({
-          role: 'system',
-          content: systemPrompt,
-        });
-
-        // Add conversation history
-        conversationHistory.forEach((msg) => {
-          messages.push({
-            role: msg.role,
-            content: msg.content,
-          });
-        });
-
-        // Add current message
-        messages.push({
-          role: 'user',
-          content: currentMessage,
-        });
-      }
-
-      const response = await llm.invoke(messages);
-      const content =
-        (response.content as string) ||
-        'I apologize, but I was unable to generate a response.';
-
-      return content;
-    } catch (error) {
-
-      const errorMessage =
-        error instanceof Error ? error.message : String(error);
-      throw new Error(`LLM service error: ${errorMessage}`);
-    }
-  }
-
-  /**
-   * Generate response for system operations using optimized configurations
-   * This method is for orchestrator internal operations, not user content
-   */
-  async generateSystemResponse(
-    operationType: SystemOperationType,
-    systemPrompt: string,
-    userMessage: string,
-  ): Promise<string> {
-    try {
-      const config = this.systemLLMConfigs[operationType];
-
-      if (!config.enabled) {
-
-        const defaultConfig = this.systemLLMConfigs.default;
-        if (!defaultConfig.enabled) {
-          throw new Error('All system LLM configurations are disabled');
-        }
-      }
-
-      const activeConfig = config.enabled
-        ? config
-        : this.systemLLMConfigs.default;
-
-      // Create LLM instance with system configuration
-      const llm = this.createCustomLangGraphLLM({
-        provider: activeConfig.provider as any,
-        model: activeConfig.model,
-        temperature: activeConfig.temperature,
-        maxTokens: activeConfig.maxTokens,
-      });
-
-      // Format messages for the specific provider - LLM service controls the format
-      const messages = this.formatMessagesForProvider(
-        systemPrompt,
-        userMessage,
-        activeConfig.provider,
-        activeConfig.model
-      );
-      
-      // Add debug logging to see what's being sent
-      this.logger.debug('üîç [SYSTEM-LLM-DEBUG] Messages being sent to LLM:', JSON.stringify(messages, null, 2));
-      this.logger.debug('üîç [SYSTEM-LLM-DEBUG] Provider:', activeConfig.provider);
-      this.logger.debug('üîç [SYSTEM-LLM-DEBUG] Model:', activeConfig.model);
-
-      const response = await llm.invoke(messages);
-      const content =
-        (response.content as string) ||
-        'I apologize, but I was unable to generate a system response.';
-
-      return content;
-    } catch (error) {
-
-      const errorMessage =
-        error instanceof Error ? error.message : String(error);
-      throw new Error(`System LLM operation error: ${errorMessage}`);
-    }
-  }
-
-  /**
-   * Generate response for user content using their preferences
-   * This is the method that should be used for actual user content generation
-   */
-  async generateUserContentResponse(
-    systemPrompt: string,
-    userMessage: string,
-    userPreferences: UserLLMPreferences,
-    authToken?: string,
-    sessionId?: string,
-  ): Promise<{
-    content: string;
-    usage: LLMUsageMetrics;
-    costCalculation: CostCalculation;
-    langsmithRunId?: string;
-    processedPrompt: string;
-    cidafmState?: any;
-    llmMetadata?: {
-      providerName: string;
-      modelName: string;
-      temperature?: number;
-      maxTokens?: number;
-      responseTimeMs?: number;
-    };
-  }> {
-    try {
-
-      // Delegate to the existing enhanced response method
-      return await this.generateEnhancedResponse(
-        authToken || 'user',
-        systemPrompt,
-        userMessage,
-        {
-          provider: userPreferences.providerName,
-          model: userPreferences.modelName,
-          cidafmOptions: userPreferences.cidafmOptions,
-          sessionId: sessionId,
-          temperature: userPreferences.temperature,
-          maxTokens: userPreferences.maxTokens,
-        },
-      );
-    } catch (error) {
-
-      const errorMessage =
-        error instanceof Error ? error.message : String(error);
-      throw new Error(`User content LLM error: ${errorMessage}`);
-    }
-  }
-
-  /**
-   * Format messages for specific provider using proper LangChain message types
-   */
-  private formatMessagesForProvider(
-    systemPrompt: string,
-    userMessage: string,
-    provider: string,
-    modelName?: string
-  ): Array<HumanMessage | SystemMessage | AIMessage> {
-    // Check if this is an o1 model (only supports user/assistant)
-    const isO1Model = modelName?.includes('o1') || false;
-    
-    if (isO1Model) {
-      // O1 models: combine system + user into single HumanMessage
-      const combinedMessage = systemPrompt 
-        ? `${systemPrompt}\n\nUser: ${userMessage}`
-        : userMessage;
-      return [new HumanMessage(combinedMessage)];
-    }
-    
-    // For all other providers, let LangChain handle the conversion properly
-    switch (provider.toLowerCase()) {
-      case 'openai':
-        // OpenAI with ChatOpenAI: use HumanMessage only to avoid system role issues
-        const combinedOpenAI = systemPrompt 
-          ? `${systemPrompt}\n\nUser: ${userMessage}`
-          : userMessage;
-        return [new HumanMessage(combinedOpenAI)];
-        
-      case 'anthropic':
-        // Anthropic: can handle SystemMessage + HumanMessage properly
-        const messages = [];
-        if (systemPrompt) {
-          messages.push(new SystemMessage(systemPrompt));
-        }
-        messages.push(new HumanMessage(userMessage));
-        return messages;
-        
-      case 'ollama':
-        // Ollama: use HumanMessage only for consistency
-        const combinedOllama = systemPrompt 
-          ? `${systemPrompt}\n\nUser: ${userMessage}`
-          : userMessage;
-        return [new HumanMessage(combinedOllama)];
-        
-      case 'google':
-        // Google: use HumanMessage only for consistency
-        const combinedGoogle = systemPrompt 
-          ? `${systemPrompt}\n\nUser: ${userMessage}`
-          : userMessage;
-        return [new HumanMessage(combinedGoogle)];
-        
-      default:
-        // Default: use HumanMessage approach
-        const combinedDefault = systemPrompt 
-          ? `${systemPrompt}\n\nUser: ${userMessage}`
-          : userMessage;
-        return [new HumanMessage(combinedDefault)];
-    }
-  }
-
-  /**
-   * Get a LangGraph-compatible LLM instance for the specified provider with automatic LangSmith tracing
-   */
-  getLangGraphLLM(
-    provider: 'openai' | 'anthropic' | 'ollama' | 'google' = 'openai',
-  ): BaseChatModel {
-    try {
-      let llm: BaseChatModel;
-
-      switch (provider) {
-        case 'openai':
-          // Use source-blinded LLM for external providers
-          llm = this.blindedLLMService.createBlindedLLM({
-            provider: 'openai',
-            model: process.env.OPENAI_MODEL || 'gpt-3.5-turbo',
-            temperature: parseFloat(process.env.OPENAI_TEMPERATURE || '0.7'),
-            maxTokens: parseInt(process.env.OPENAI_MAX_TOKENS || '2000'),
-            apiKey: process.env.OPENAI_API_KEY,
-            sourceBlindingOptions: {
-              policyProfile: 'standard',
-              dataClass: 'public',
-              sovereignMode: 'false',
-              noTrain: true,
-              noRetain: false,
-            },
-          });
-          break;
-
-        case 'anthropic':
-          // Use source-blinded LLM for external providers
-          llm = this.blindedLLMService.createBlindedLLM({
-            provider: 'anthropic',
-            model: process.env.ANTHROPIC_MODEL || 'claude-3-5-sonnet-20241022',
-            temperature: parseFloat(process.env.ANTHROPIC_TEMPERATURE || '0.7'),
-            maxTokens: parseInt(process.env.ANTHROPIC_MAX_TOKENS || '2000'),
-            apiKey: process.env.ANTHROPIC_API_KEY,
-            sourceBlindingOptions: {
-              policyProfile: 'standard',
-              dataClass: 'public',
-              sovereignMode: 'false',
-              noTrain: true,
-              noRetain: false,
-            },
-          });
-          break;
-
-        case 'ollama':
-          // Ollama is local - no source blinding needed
-          llm = new ChatOllama({
-            baseUrl: process.env.OLLAMA_BASE_URL || 'http://localhost:11434',
-            model: process.env.OLLAMA_MODEL || 'llama2',
-            temperature: parseFloat(process.env.OLLAMA_TEMPERATURE || '0.7'),
-          });
-          break;
-
-        case 'google':
-          // Use source-blinded LLM for external providers
-          llm = this.blindedLLMService.createBlindedLLM({
-            provider: 'google',
-            model: process.env.GOOGLE_MODEL || 'gemini-pro',
-            temperature: parseFloat(process.env.GOOGLE_TEMPERATURE || '0.7'),
-            maxTokens: parseInt(process.env.GOOGLE_MAX_TOKENS || '2000'),
-            apiKey: process.env.GOOGLE_API_KEY,
-            sourceBlindingOptions: {
-              policyProfile: 'standard',
-              dataClass: 'public',
-              sovereignMode: 'false',
-              noTrain: true,
-              noRetain: false,
-            },
-          });
-          break;
-
-        default:
-
-          llm = this.getLangGraphLLM('openai');
-      }
-
-      // LangSmith will automatically trace this LangChain LLM if environment variables are set
-      return llm;
-    } catch (error) {
-
-      throw new Error(
-        `Failed to create LangGraph LLM: ${error instanceof Error ? error.message : String(error)}`,
-      );
-    }
-  }
-
-  /**
-   * Create a LangGraph LLM instance with custom configuration and automatic LangSmith tracing
-   */
-  createCustomLangGraphLLM(config: {
-    provider: 'openai' | 'anthropic' | 'ollama' | 'google';
-    model?: string;
-    temperature?: number;
-    maxTokens?: number;
-    apiKey?: string;
-    baseUrl?: string;
-  }): BaseChatModel {
-    try {
-      let llm: BaseChatModel;
-
-      switch (config.provider) {
-        case 'openai':
-          // Check if this is an o1 model (doesn't support custom temperature)
-          const isO1Model = config.model?.includes('o1') || false;
-          const temperature = isO1Model ? undefined : (config.temperature ?? parseFloat(process.env.OPENAI_TEMPERATURE || '0.7'));
-          
-          // Require explicit model - no fallbacks allowed
-          if (!config.model) {
-            throw new Error('OpenAI model must be explicitly specified - no fallback model configured');
-          }
-          
-          // Use source-blinded LLM for external providers
-          llm = this.blindedLLMService.createBlindedLLM({
-            provider: 'openai',
-            model: config.model,
-            temperature: temperature,
-            maxTokens: config.maxTokens ?? parseInt(process.env.OPENAI_MAX_TOKENS || '2000'),
-            apiKey: config.apiKey || process.env.OPENAI_API_KEY,
-            baseUrl: config.baseUrl, // Pass the database baseUrl for correct provider routing
-            sourceBlindingOptions: {
-              policyProfile: 'standard',
-              dataClass: 'public',
-              sovereignMode: 'false',
-              noTrain: true,
-              noRetain: false,
-            },
-          });
-          break;
-
-        case 'anthropic':
-          // Use source-blinded LLM for external providers
-          llm = this.blindedLLMService.createBlindedLLM({
-            provider: 'anthropic',
-            model: config.model || process.env.ANTHROPIC_MODEL || 'claude-3-5-sonnet-20241022',
-            temperature: config.temperature ?? parseFloat(process.env.ANTHROPIC_TEMPERATURE || '0.7'),
-            maxTokens: config.maxTokens ?? parseInt(process.env.ANTHROPIC_MAX_TOKENS || '2000'),
-            apiKey: config.apiKey || process.env.ANTHROPIC_API_KEY,
-            baseUrl: config.baseUrl, // Pass the database baseUrl for correct provider routing
-            sourceBlindingOptions: {
-              policyProfile: 'standard',
-              dataClass: 'public',
-              sovereignMode: 'false',
-              noTrain: true,
-              noRetain: false,
-            },
-          });
-          break;
-
-        case 'ollama':
-          llm = new ChatOllama({
-            baseUrl:
-              config.baseUrl ||
-              process.env.OLLAMA_BASE_URL ||
-              'http://localhost:11434',
-            model: config.model || process.env.OLLAMA_MODEL || 'llama2',
-            temperature:
-              config.temperature ??
-              parseFloat(process.env.OLLAMA_TEMPERATURE || '0.7'),
-          });
-          break;
-
-        case 'google':
-          // Use source-blinded LLM for external providers
-          llm = this.blindedLLMService.createBlindedLLM({
-            provider: 'google',
-            model: config.model || process.env.GOOGLE_MODEL || 'gemini-pro',
-            temperature: config.temperature ?? parseFloat(process.env.GOOGLE_TEMPERATURE || '0.7'),
-            maxTokens: config.maxTokens ?? parseInt(process.env.GOOGLE_MAX_TOKENS || '2000'),
-            apiKey: config.apiKey || process.env.GOOGLE_API_KEY,
-            sourceBlindingOptions: {
-              policyProfile: 'standard',
-              dataClass: 'public',
-              sovereignMode: 'false',
-              noTrain: true,
-              noRetain: false,
-            },
-          });
-          break;
-
-        default:
-          throw new Error(`Unsupported provider: ${config.provider}`);
-      }
-
-      // LangSmith will automatically trace this LangChain LLM if environment variables are set
-      return llm;
-    } catch (error) {
-
-      throw new Error(
-        `Failed to create custom LangGraph LLM: ${error instanceof Error ? error.message : String(error)}`,
-      );
-    }
-  }
-
-
-  /**
-   * Get provider and model from database by names, with fallback to defaults
-   */
-  private async getProviderAndModel(
-    providerName?: string,
-    modelName?: string,
-  ): Promise<{ provider: Provider; model: Model }> {
-    const client = this.supabaseService.getServiceClient();
-
-    // If both are provided, fetch them
-    if (providerName && modelName) {
-      const [providerResult, modelResult] = await Promise.all([
-        client.from(getTableName('llm_providers')).select('*').eq('name', providerName).single(),
-        client.from(getTableName('llm_models')).select('*')
-          .eq('model_name', modelName)
-          .eq('provider_name', providerName)
-          .single(),
-      ]);
-
-      if (providerResult.data && modelResult.data) {
-        return {
-          provider: mapProviderFromDb(providerResult.data),
-          model: mapModelFromDb(modelResult.data),
-        };
-      }
-
-      // If specific provider/model requested but not found, throw error instead of falling back
-      throw new Error(
-        `Requested provider '${providerName}' with model '${modelName}' not found in database. Please ensure the provider and model are properly configured.`
-      );
-    }
-
-    // If no provider/model specified, this is a configuration error
-    throw new Error(
-      'No provider or model specified. Please provide both providerName and modelName.'
-    );
-  }
-
-  /**
-   * Create LLM instance from database model configuration
-   */
-  private async createLLMFromModel(
-    model: Model,
-    overrides?: {
-      temperature?: number;
-      maxTokens?: number;
-    },
-  ): Promise<BaseChatModel> {
-    const client = this.supabaseService.getServiceClient();
-
-    // Get provider details
-    const { data: provider } = await client
-      .from(getTableName('llm_providers'))
-      .select('*')
-      .eq('name', model.providerName)
-      .single();
-
-    if (!provider) {
-      throw new Error(`Provider not found for model ${model.name}`);
-    }
-
-    const mappedProvider = mapProviderFromDb(provider);
-
-    // Map provider names to our LLM creation logic
-    // Note: Database provider names are lowercase, display_names are title case
-    const providerMap: Record<string, string> = {
-      // Database name mappings (lowercase)
-      openai: 'openai',
-      anthropic: 'anthropic', 
-      google: 'google',
-      ollama: 'ollama',
-      grok: 'openai', // Grok uses OpenAI-compatible API
-      // Display name mappings (title case) - for backward compatibility
-      OpenAI: 'openai',
-      Anthropic: 'anthropic',
-      Google: 'google',
-      'Google Gemini': 'google',
-      Ollama: 'ollama',
-      'Grok (xAI)': 'openai', // Grok uses OpenAI-compatible API
-      'X.AI (Grok)': 'openai', // Alternative Grok name
-      Groq: 'openai', // Groq uses OpenAI-compatible API
-      'Together AI': 'openai', // Together AI uses OpenAI-compatible API
-      Cohere: 'openai', // Cohere can use OpenAI-compatible API
-      Mistral: 'openai', // Mistral uses OpenAI-compatible API
-    };
-
-    const providerType = providerMap[mappedProvider.name] || 'openai';
-
-    // Get the correct API key for this provider
-    const providerApiKey = this.getApiKeyForProvider(mappedProvider.name);
-
-    return this.createCustomLangGraphLLM({
-      provider: providerType as any,
-      model: model.name,
-      temperature: overrides?.temperature,
-      maxTokens: overrides?.maxTokens || model.maxTokens,
-      apiKey: providerApiKey,
-      baseUrl: mappedProvider.apiBaseUrl,
-    });
-  }
-
-  /**
-   * Get the correct API key for a provider
-   */
-  private getApiKeyForProvider(providerName: string): string | undefined {
-    const envPrefix = providerName.toUpperCase();
-    
-    // Map provider names to their environment variable names
-    const apiKeyMap: Record<string, string> = {
-      'openai': 'OPENAI_API_KEY',
-      'anthropic': 'ANTHROPIC_API_KEY',
-      'google': 'GOOGLE_API_KEY',
-      'grok': 'GROK_API_KEY',
-      'ollama': 'OLLAMA_API_KEY',
-      // Add other providers as needed
-    };
-    
-    const envVarName = apiKeyMap[providerName.toLowerCase()] || `${envPrefix}_API_KEY`;
-    return process.env[envVarName];
-  }
-
-  /**
-   * Apply CIDAFM state modifiers to system prompt
-   */
-  private applyStateModifiersToPrompt(
-    systemPrompt: string,
-    activeModifiers: string[],
-  ): string {
-    let enhancedPrompt = systemPrompt;
-
-    for (const modifier of activeModifiers) {
-      switch (modifier) {
-        case 'token-efficient':
-          enhancedPrompt +=
-            '\n\n[CIDAFM: Be concise and token-efficient while preserving clarity and relevance.]';
-          break;
-        case 'disciplined':
-          enhancedPrompt +=
-            '\n\n[CIDAFM: Follow explicit user instructions only. Do not make assumptions. Request clarification if unclear.]';
-          break;
-        case 'context-independent':
-          enhancedPrompt +=
-            '\n\n[CIDAFM: Provide all necessary context for complete understanding without relying on external information.]';
-          break;
-        case 'friendly':
-          enhancedPrompt +=
-            '\n\n[CIDAFM: Use a warm, personable, and conversational tone in your response.]';
-          break;
-        case 'professional':
-          enhancedPrompt +=
-            '\n\n[CIDAFM: Maintain a formal, business-appropriate tone and structure.]';
-          break;
-        case 'technical':
-          enhancedPrompt +=
-            '\n\n[CIDAFM: Focus on technical accuracy and precision. Include relevant technical details.]';
-          break;
-        case 'educational':
-          enhancedPrompt +=
-            '\n\n[CIDAFM: Structure response to be educational, explaining concepts step-by-step.]';
-          break;
-        default:
-          // Custom user modifier
-          enhancedPrompt += `\n\n[CIDAFM: Apply custom behavior modifier "${modifier}".]`;
-      }
-    }
-
-    return enhancedPrompt;
-  }
-
-  /**
-   * Simple token estimation (4 characters ‚âà 1 token)
-   */
-  private estimateTokens(text: string): number {
-    return Math.ceil(text.length / 4);
-  }
-
-  /**
-   * Calculate cost based on token usage and pricing
-   */
-  private calculateCost(
-    inputTokens: number,
-    outputTokens: number,
-    inputPricePer1k: number,
-    outputPricePer1k: number,
-  ): CostCalculation {
-    const inputCost = (inputTokens / 1000) * inputPricePer1k;
-    const outputCost = (outputTokens / 1000) * outputPricePer1k;
-
-    return {
-      inputTokens: inputTokens,
-      outputTokens: outputTokens,
-      inputCost: inputCost,
-      outputCost: outputCost,
-      totalCost: inputCost + outputCost,
-      currency: 'USD',
-    };
-  }
-
-  /**
-   * Extract sanitization metadata in the format expected by the frontend
-   */
-  private async extractSanitizationMetadataForFrontend(sanitizationMetrics: any): Promise<any> {
-    if (!sanitizationMetrics || sanitizationMetrics.sanitizationLevel === 'none') {
-      return {
-        status: 'none',
-        piiDetectionCount: 0,
-        piiTypes: [],
-        piiSeverityLevels: []
-      };
-    }
-
-    // Get PII severity levels from database based on detected types
-    const piiSeverityLevels = await this.getPiiSeverityLevels(sanitizationMetrics.piiTypes);
-
-    return {
-      status: sanitizationMetrics.piiDetected ? 'completed' : 'none',
-      piiDetectionCount: sanitizationMetrics.pseudonymsUsed + sanitizationMetrics.redactionsApplied,
-      piiTypes: sanitizationMetrics.piiTypes || [],
-      piiSeverityLevels: piiSeverityLevels,
-      sanitizationLevel: sanitizationMetrics.sanitizationLevel,
-      pseudonymsUsed: sanitizationMetrics.pseudonymsUsed,
-      redactionsApplied: sanitizationMetrics.redactionsApplied
-    };
-  }
-
-  /**
-   * Get PII severity levels from database based on detected PII types
-   */
-  private async getPiiSeverityLevels(piiTypes: string[]): Promise<string[]> {
-    if (!piiTypes || piiTypes.length === 0) {
-      return [];
-    }
-
-    try {
-      // Query the redaction_patterns table to get severity levels for detected PII types
-      const { data: patterns, error } = await this.supabaseService
-        .getServiceClient()
-        .from('redaction_patterns')
-        .select('severity, data_type')
-        .in('data_type', piiTypes);
-
-      if (error) {
-        this.logger.warn(`Failed to fetch PII severity levels: ${error.message}`);
-        // Fallback to default mapping
-        return this.getDefaultSeverityMapping(piiTypes);
-      }
-
-      // Extract unique severity levels
-      const severityLevels = [...new Set(patterns?.map(p => p.severity) || [])];
-      return severityLevels.filter(Boolean);
-    } catch (error) {
-      this.logger.warn(`Error fetching PII severity levels: ${error instanceof Error ? error.message : String(error)}`);
-      // Fallback to default mapping
-      return this.getDefaultSeverityMapping(piiTypes);
-    }
-  }
-
-  /**
-   * Fallback mapping for PII types to severity levels when database query fails
-   */
-  private getDefaultSeverityMapping(piiTypes: string[]): string[] {
-    const severityMap: Record<string, string> = {
-      'ssn': 'showstopper',
-      'credit_card': 'showstopper',
-      'creditCard': 'showstopper',
-      'email': 'pseudonymizer',
-      'phone': 'pseudonymizer',
-      'ipAddress': 'flagger',
-      'ip_address': 'flagger',
-      'name': 'pseudonymizer',
-      'api_key': 'showstopper',
-      'other': 'flagger'
-    };
-
-    const severities = piiTypes.map(type => severityMap[type] || 'flagger');
-    return [...new Set(severities)]; // Remove duplicates
-  }
-}
diff --git a/apps/api/src/llms/pii-pseudonym-e2e.spec.ts b/apps/api/src/llms/pii-pseudonym-e2e.spec.ts
new file mode 100644
index 0000000..93dcf64
--- /dev/null
+++ b/apps/api/src/llms/pii-pseudonym-e2e.spec.ts
@@ -0,0 +1,335 @@
+import { Test, TestingModule } from '@nestjs/testing';
+import { INestApplication } from '@nestjs/common';
+import { AppModule } from '../app.module';
+import { LLMService } from './llm.service';
+import { DataSanitizationService } from './data-sanitization.service';
+import { PseudonymizationService } from './pseudonymization.service';
+import { SecretRedactionService } from './secret-redaction.service';
+import { SupabaseService } from '../supabase/supabase.service';
+import { getTableName } from '../supabase/supabase.config';
+
+describe('PII and Pseudonym E2E Tests', () => {
+  let app: INestApplication;
+  let llmService: LLMService;
+  let dataSanitizationService: DataSanitizationService;
+  let pseudonymizationService: PseudonymizationService;
+  let secretRedactionService: SecretRedactionService;
+  let supabaseService: SupabaseService;
+
+  const TEST_PROMPT = `Can you check the status of my server at 192.168.1.1? The documentation is at http://internal-docs.company.com/wiki/setup. I wrote a blog post about Matt Weber. He is sometimes known as GolferGeek. He is the owner of Orchestrator AI. It was a great post! I can't find it anymore.`;
+
+  beforeAll(async () => {
+    const moduleFixture: TestingModule = await Test.createTestingModule({
+      imports: [AppModule],
+    }).compile();
+
+    app = moduleFixture.createNestApplication();
+    llmService = moduleFixture.get<LLMService>(LLMService);
+    dataSanitizationService = moduleFixture.get<DataSanitizationService>(DataSanitizationService);
+    pseudonymizationService = moduleFixture.get<PseudonymizationService>(PseudonymizationService);
+    secretRedactionService = moduleFixture.get<SecretRedactionService>(SecretRedactionService);
+    supabaseService = moduleFixture.get<SupabaseService>(SupabaseService);
+    
+    await app.init();
+  }, 60000);
+
+  afterAll(async () => {
+    if (app) {
+      await app.close();
+    }
+  });
+
+  describe('PII Detection and Flagging', () => {
+    it('should detect and flag IP address and URL', async () => {
+      const redactionResult = secretRedactionService.redactSecrets(TEST_PROMPT);
+      
+      console.log('üîç Redaction Result:', {
+        patternsMatched: redactionResult.result.patternsMatched,
+        redactionCount: redactionResult.result.redactionCount,
+        redactedText: redactionResult.redactedText.substring(0, 200)
+      });
+
+      expect(redactionResult.result.redactionCount).toBeGreaterThanOrEqual(2);
+      expect(redactionResult.result.patternsMatched).toContain('ipAddress');
+      expect(redactionResult.result.patternsMatched).toContain('internalUrl');
+      
+      expect(redactionResult.redactedText).toContain('[IP_ADDRESS_REDACTED]');
+      expect(redactionResult.redactedText).toContain('[INTERNAL_URL_REDACTED]');
+      
+      expect(redactionResult.redactedText).not.toContain('192.168.1.1');
+      expect(redactionResult.redactedText).not.toContain('http://internal-docs.company.com');
+    });
+  });
+
+  describe('Pseudonym Replacement', () => {
+    it('should replace known entities with pseudonyms', async () => {
+      const pseudonymResult = await pseudonymizationService.pseudonymizeText(TEST_PROMPT, {
+        context: 'test'
+      });
+
+      console.log('üé≠ Pseudonym Result:', {
+        pseudonymCount: pseudonymResult.pseudonyms.length,
+        pseudonyms: pseudonymResult.pseudonyms.map(p => ({
+          original: p.originalValue,
+          pseudonym: p.pseudonym,
+          type: p.dataType
+        }))
+      });
+
+      expect(pseudonymResult.pseudonyms.length).toBeGreaterThanOrEqual(3);
+      
+      const pseudonymValues = pseudonymResult.pseudonyms.map(p => p.originalValue.toLowerCase());
+      expect(pseudonymValues).toContain('matt weber');
+      expect(pseudonymValues).toContain('golfergeek');
+      expect(pseudonymValues).toContain('orchestrator ai');
+      
+      expect(pseudonymResult.pseudonymizedText).not.toContain('Matt Weber');
+      expect(pseudonymResult.pseudonymizedText).not.toContain('GolferGeek');
+      expect(pseudonymResult.pseudonymizedText).not.toContain('Orchestrator AI');
+    });
+  });
+
+  describe('Complete Sanitization Pipeline', () => {
+    it('should apply both redaction and pseudonymization', async () => {
+      const sanitizationResult = await dataSanitizationService.sanitizeText(TEST_PROMPT, {
+        enableRedaction: true,
+        enablePseudonymization: true,
+        pseudonymizationContext: 'test'
+      });
+
+      console.log('üõ°Ô∏è Complete Sanitization Result:', {
+        originalLength: sanitizationResult.originalLength,
+        sanitizedLength: sanitizationResult.sanitizedLength,
+        redactionCount: sanitizationResult.redactionResult?.redactionCount || 0,
+        pseudonymCount: sanitizationResult.pseudonymizationResult?.pseudonyms?.length || 0,
+        processingTimeMs: sanitizationResult.processingTimeMs
+      });
+
+      expect(sanitizationResult.redactionResult).toBeDefined();
+      expect(sanitizationResult.redactionResult!.redactionCount).toBeGreaterThanOrEqual(2);
+      
+      expect(sanitizationResult.pseudonymizationResult).toBeDefined();
+      expect(sanitizationResult.pseudonymizationResult!.pseudonyms.length).toBeGreaterThanOrEqual(3);
+      
+      const sanitizedText = sanitizationResult.sanitizedText;
+      expect(sanitizedText).not.toContain('192.168.1.1');
+      expect(sanitizedText).not.toContain('http://internal-docs.company.com');
+      expect(sanitizedText).not.toContain('Matt Weber');
+      expect(sanitizedText).not.toContain('GolferGeek');
+      expect(sanitizedText).not.toContain('Orchestrator AI');
+    });
+  });
+
+  describe('LLM Request with PII Metadata', () => {
+    it('should process LLM request with PII metadata tracking', async () => {
+      const runId = `test-pii-${Date.now()}`;
+      
+      const result: any = await llmService.generateUnifiedResponse({
+        provider: 'ollama',
+        model: 'llama3.2:1b',
+        systemPrompt: 'You are a helpful assistant analyzing network and documentation information.',
+        userMessage: TEST_PROMPT,
+        options: {
+          maxTokens: 100,
+          temperature: 0.1,
+          includeMetadata: true,
+          callerType: 'pii-e2e-test',
+          callerName: 'pii-pseudonym-test',
+          requestId: runId,
+          enableSanitization: true
+        }
+      });
+
+      console.log('üìä LLM Response with PII Metadata:', {
+        provider: result.metadata?.provider,
+        model: result.metadata?.model,
+        requestId: result.metadata?.requestId,
+        piiDetected: result.metadata?.usage?.piiDetected,
+        piiTypes: result.metadata?.usage?.piiTypes,
+        pseudonymsUsed: result.metadata?.usage?.pseudonymsUsed,
+        pseudonymTypes: result.metadata?.usage?.pseudonymTypes,
+        redactionsApplied: result.metadata?.usage?.redactionsApplied,
+        redactionTypes: result.metadata?.usage?.redactionTypes,
+        sanitizationLevel: result.metadata?.usage?.sanitizationLevel
+      });
+
+      expect(result).toBeDefined();
+      expect(result.metadata).toBeDefined();
+      expect(result.metadata?.usage).toBeDefined();
+      
+      const usage = result.metadata!.usage as any;
+      expect(usage.piiDetected).toBe(true);
+      expect(usage.piiTypes).toBeDefined();
+      expect(usage.piiTypes.length).toBeGreaterThan(0);
+      expect(usage.pseudonymsUsed).toBeGreaterThanOrEqual(3);
+      expect(usage.pseudonymTypes).toBeDefined();
+      expect(usage.redactionsApplied).toBeGreaterThanOrEqual(2);
+      expect(usage.redactionTypes).toBeDefined();
+      expect(usage.sanitizationLevel).toBeDefined();
+      expect(['basic', 'standard', 'strict']).toContain(usage.sanitizationLevel);
+    }, 30000);
+  });
+
+  describe('Database Storage Verification', () => {
+    it('should store PII metadata in llm_usage table', async () => {
+      const runId = `test-db-pii-${Date.now()}`;
+      
+      const result: any = await llmService.generateUnifiedResponse({
+        provider: 'ollama',
+        model: 'llama3.2:1b',
+        systemPrompt: 'You are a helpful assistant.',
+        userMessage: TEST_PROMPT,
+        options: {
+          maxTokens: 50,
+          temperature: 0.1,
+          includeMetadata: true,
+          callerType: 'pii-db-test',
+          callerName: 'pii-storage-verification',
+          requestId: runId,
+          enableSanitization: true
+        }
+      });
+
+      await new Promise(resolve => setTimeout(resolve, 2000));
+
+      const client = supabaseService.getServiceClient();
+      const { data: usageRecord, error } = await client
+        .from(getTableName('llm_usage'))
+        .select('*')
+        .eq('run_id', runId)
+        .single();
+
+      console.log('üíæ Database Record:', {
+        runId: usageRecord?.run_id,
+        piiDetected: usageRecord?.pii_detected,
+        piiTypes: usageRecord?.pii_types,
+        pseudonymsUsed: usageRecord?.pseudonyms_used,
+        pseudonymTypes: usageRecord?.pseudonym_types,
+        redactionsApplied: usageRecord?.redactions_applied,
+        redactionTypes: usageRecord?.redaction_types,
+        sanitizationLevel: usageRecord?.sanitization_level
+      });
+
+      expect(error).toBeNull();
+      expect(usageRecord).toBeDefined();
+      expect(usageRecord.pii_detected).toBe(true);
+      expect(usageRecord.pii_types).toBeDefined();
+      expect(usageRecord.pii_types.length).toBeGreaterThan(0);
+      expect(usageRecord.pseudonyms_used).toBeGreaterThanOrEqual(3);
+      expect(usageRecord.pseudonym_types).toBeDefined();
+      expect(usageRecord.redactions_applied).toBeGreaterThanOrEqual(2);
+      expect(usageRecord.redaction_types).toBeDefined();
+      expect(usageRecord.sanitization_level).toBeDefined();
+    }, 30000);
+  });
+
+  describe('Reversible Sanitization', () => {
+    it('should sanitize and then reverse the sanitization', async () => {
+      const requestId = `test-reverse-${Date.now()}`;
+      
+      const sanitizeResult = await dataSanitizationService.reversibleSanitizeText(
+        TEST_PROMPT,
+        requestId,
+        {
+          enableRedaction: false,
+          enablePseudonymization: true,
+          pseudonymizationContext: 'test-reversible'
+        }
+      );
+
+      console.log('üîÑ Reversible Sanitization:', {
+        originalLength: TEST_PROMPT.length,
+        sanitizedLength: sanitizeResult.sanitizedText.length,
+        hasReversalContext: !!sanitizeResult.reversalContext
+      });
+
+      expect(sanitizeResult.sanitizedText).not.toContain('Matt Weber');
+      expect(sanitizeResult.sanitizedText).not.toContain('GolferGeek');
+      expect(sanitizeResult.sanitizedText).not.toContain('Orchestrator AI');
+      
+      const reverseResult = await dataSanitizationService.reverseSanitization(
+        sanitizeResult.sanitizedText,
+        sanitizeResult.reversalContext,
+        requestId
+      );
+
+      console.log('üîÑ Reverse Result:', {
+        reversalCount: reverseResult.reversalCount,
+        source: reverseResult.source,
+        processingTimeMs: reverseResult.processingTimeMs
+      });
+
+      expect(reverseResult.originalText).toContain('Matt Weber');
+      expect(reverseResult.originalText).toContain('GolferGeek');
+      expect(reverseResult.originalText).toContain('Orchestrator AI');
+      expect(reverseResult.reversalCount).toBeGreaterThanOrEqual(3);
+    });
+  });
+
+  describe('Metrics Extraction', () => {
+    it('should extract detailed sanitization metrics', async () => {
+      const sanitizationResult = await dataSanitizationService.sanitizeText(TEST_PROMPT, {
+        enableRedaction: true,
+        enablePseudonymization: true,
+        pseudonymizationContext: 'metrics-test'
+      });
+
+      const metrics = dataSanitizationService.extractSanitizationMetrics(sanitizationResult, false);
+
+      console.log('üìà Sanitization Metrics:', metrics);
+
+      expect(metrics.piiDetected).toBe(true);
+      expect(metrics.piiTypes.length).toBeGreaterThan(0);
+      expect(metrics.pseudonymsUsed).toBeGreaterThanOrEqual(3);
+      expect(metrics.pseudonymTypes.length).toBeGreaterThan(0);
+      expect(metrics.redactionsApplied).toBeGreaterThanOrEqual(2);
+      expect(metrics.redactionTypes.length).toBeGreaterThan(0);
+      expect(metrics.sanitizationTimeMs).toBeGreaterThan(0);
+      expect(metrics.sanitizationLevel).not.toBe('none');
+    });
+  });
+
+  describe('Cache Management', () => {
+    it('should cache and retrieve reversal contexts', async () => {
+      const requestId = `test-cache-${Date.now()}`;
+      
+      const sanitizeResult = await dataSanitizationService.reversibleSanitizeText(
+        'Test message with Matt Weber',
+        requestId,
+        {
+          enableRedaction: false,
+          enablePseudonymization: true
+        }
+      );
+
+      const cacheStats = dataSanitizationService.getCacheStats();
+      console.log('üíæ Cache Stats:', cacheStats);
+
+      expect(cacheStats.size).toBeGreaterThan(0);
+      
+      const reverseFromCache = await dataSanitizationService.reverseSanitization(
+        sanitizeResult.sanitizedText,
+        null,
+        requestId
+      );
+
+      expect(reverseFromCache.source).toBe('memory');
+      expect(reverseFromCache.originalText).toContain('Matt Weber');
+    });
+  });
+
+  describe('Safe Logging', () => {
+    it('should sanitize logs automatically', async () => {
+      const logSpy = jest.spyOn(console, 'log');
+      
+      await dataSanitizationService.info(
+        `Processing request for Matt Weber at 192.168.1.1`,
+        'test-run-id',
+        'SafeLoggingTest',
+        { user: 'GolferGeek', company: 'Orchestrator AI' }
+      );
+
+      logSpy.mockRestore();
+    });
+  });
+});
\ No newline at end of file
diff --git a/apps/api/src/llms/sanitization-management.controller.spec.ts b/apps/api/src/llms/sanitization-management.controller.spec.ts
deleted file mode 100644
index ae4cab4..0000000
--- a/apps/api/src/llms/sanitization-management.controller.spec.ts
+++ /dev/null
@@ -1,700 +0,0 @@
-import { Test, TestingModule } from '@nestjs/testing';
-import { SanitizationManagementController } from './sanitization-management.controller';
-import { SecretRedactionService } from './secret-redaction.service';
-import { PIIPatternService } from './pii-pattern.service';
-import { PseudonymizationService } from './pseudonymization.service';
-import { DataSanitizationService } from './data-sanitization.service';
-
-describe('SanitizationManagementController', () => {
-  let controller: SanitizationManagementController;
-  let mockSecretRedactionService: jest.Mocked<SecretRedactionService>;
-  let mockPIIPatternService: jest.Mocked<PIIPatternService>;
-  let mockPseudonymizationService: jest.Mocked<PseudonymizationService>;
-  let mockDataSanitizationService: jest.Mocked<DataSanitizationService>;
-
-  beforeEach(async () => {
-    const mockSecretRedaction = {
-      getRedactionPatterns: jest.fn(),
-      addRedactionPattern: jest.fn(),
-      removeRedactionPattern: jest.fn(),
-      testRedaction: jest.fn(),
-      getStats: jest.fn(),
-    };
-
-    const mockPIIPattern = {
-      getAllPatterns: jest.fn(),
-      getPatternsByDataType: jest.fn(),
-      addCustomPattern: jest.fn(),
-      detectPII: jest.fn(),
-      getStats: jest.fn(),
-    };
-
-    const mockPseudonymization = {
-      generatePseudonym: jest.fn(),
-      lookupPseudonym: jest.fn(),
-      getStats: jest.fn(),
-    };
-
-    const mockDataSanitization = {
-      testSanitization: jest.fn(),
-      sanitizeText: jest.fn(),
-      getStats: jest.fn(),
-      getCacheStats: jest.fn(),
-    };
-
-    const module: TestingModule = await Test.createTestingModule({
-      controllers: [SanitizationManagementController],
-      providers: [
-        { provide: SecretRedactionService, useValue: mockSecretRedaction },
-        { provide: PIIPatternService, useValue: mockPIIPattern },
-        { provide: PseudonymizationService, useValue: mockPseudonymization },
-        { provide: DataSanitizationService, useValue: mockDataSanitization },
-      ],
-    }).compile();
-
-    controller = module.get<SanitizationManagementController>(SanitizationManagementController);
-    mockSecretRedactionService = module.get(SecretRedactionService);
-    mockPIIPatternService = module.get(PIIPatternService);
-    mockPseudonymizationService = module.get(PseudonymizationService);
-    mockDataSanitizationService = module.get(DataSanitizationService);
-  });
-
-  afterEach(() => {
-    jest.clearAllMocks();
-  });
-
-  describe('Redaction Pattern Endpoints', () => {
-    describe('GET /sanitization/redaction/patterns', () => {
-      it('should return all redaction patterns with stats', async () => {
-        const mockPatterns = [
-          { name: 'api_key', pattern: /sk-\w+/g, replacement: '[REDACTED]', description: 'API keys' },
-          { name: 'password', pattern: /password:\s*\w+/gi, replacement: '[REDACTED]', description: 'Passwords' },
-        ];
-        const mockStats = { totalPatterns: 2, customPatterns: 0, productionMode: false, verboseLogging: false };
-
-        mockSecretRedactionService.getRedactionPatterns.mockReturnValue(mockPatterns);
-        mockSecretRedactionService.getStats.mockReturnValue(mockStats);
-
-        const result = await controller.getRedactionPatterns();
-
-        expect(result.patterns).toEqual(mockPatterns);
-        expect(result.stats).toEqual(mockStats);
-        expect(result.totalPatterns).toBe(2);
-      });
-    });
-
-    describe('POST /sanitization/redaction/patterns', () => {
-      it('should add custom redaction pattern successfully', async () => {
-        const createPatternDto = {
-          name: 'employee_id',
-          pattern: 'EMP\\d{4}',
-          replacement: '[EMPLOYEE_REDACTED]',
-          description: 'Employee ID pattern',
-          category: 'corporate',
-          priority: 10,
-        };
-
-        const result = await controller.addRedactionPattern(createPatternDto);
-
-        expect(result.success).toBe(true);
-        expect(result.message).toContain('employee_id');
-        expect(result.pattern).toEqual(createPatternDto);
-        expect(mockSecretRedactionService.addRedactionPattern).toHaveBeenCalled();
-      });
-
-      it('should handle invalid regex patterns', async () => {
-        const invalidPatternDto = {
-          name: 'invalid_pattern',
-          pattern: '[',  // Invalid regex
-          replacement: '[REDACTED]',
-          description: 'Invalid pattern',
-        };
-
-        const result = await controller.addRedactionPattern(invalidPatternDto);
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('Failed to add pattern');
-      });
-
-      it('should handle service errors', async () => {
-        const createPatternDto = {
-          name: 'test_pattern',
-          pattern: 'test',
-          replacement: '[REDACTED]',
-          description: 'Test pattern',
-        };
-
-        mockSecretRedactionService.addRedactionPattern.mockImplementation(() => {
-          throw new Error('Service error');
-        });
-
-        const result = await controller.addRedactionPattern(createPatternDto);
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('Service error');
-      });
-    });
-
-    describe('DELETE /sanitization/redaction/patterns/:name', () => {
-      it('should remove existing pattern successfully', async () => {
-        mockSecretRedactionService.removeRedactionPattern.mockReturnValue(true);
-
-        const result = await controller.removeRedactionPattern('test_pattern');
-
-        expect(result.success).toBe(true);
-        expect(result.message).toContain('removed successfully');
-        expect(mockSecretRedactionService.removeRedactionPattern).toHaveBeenCalledWith('test_pattern');
-      });
-
-      it('should handle non-existent pattern', async () => {
-        mockSecretRedactionService.removeRedactionPattern.mockReturnValue(false);
-
-        const result = await controller.removeRedactionPattern('non_existent');
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('not found');
-      });
-    });
-
-    describe('POST /sanitization/redaction/test', () => {
-      it('should test redaction patterns successfully', async () => {
-        const testText = 'API key: sk-1234567890abcdef';
-        const mockTestResult = {
-          redactedText: 'API key: [REDACTED]',
-          result: { originalLength: 30, redactedLength: 17, redactionCount: 1, patternsMatched: ['api_key'] },
-          patternDetails: [{ name: 'api_key', matches: 1, description: 'API keys' }],
-        };
-
-        mockSecretRedactionService.testRedaction.mockReturnValue(mockTestResult);
-
-        const result = await controller.testRedaction(testText);
-
-        expect(result.success).toBe(true);
-        expect(result.originalText).toBe(testText);
-        expect(result.redactedText).toBe('API key: [REDACTED]');
-        expect(result.result).toEqual(mockTestResult.result);
-        expect(result.patternDetails).toEqual(mockTestResult.patternDetails);
-      });
-
-      it('should handle missing text input', async () => {
-        const result = await controller.testRedaction('');
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('Text is required');
-      });
-    });
-  });
-
-  describe('PII Pattern Endpoints', () => {
-    describe('GET /sanitization/pii/patterns', () => {
-      it('should return all PII patterns', async () => {
-        const mockPatterns = [
-          { name: 'email', dataType: 'email', pattern: /\S+@\S+\.\S+/g, description: 'Email addresses' },
-          { name: 'phone', dataType: 'phone', pattern: /\(\d{3}\)\s*\d{3}-\d{4}/g, description: 'Phone numbers' },
-        ];
-        const mockStats = { builtInPatterns: 10, customPatterns: 2, totalPatterns: 12, enabledPatterns: 11 };
-
-        mockPIIPatternService.getAllPatterns.mockReturnValue(mockPatterns);
-        mockPIIPatternService.getStats.mockReturnValue(mockStats);
-
-        const result = await controller.getPIIPatterns();
-
-        expect(result.patterns).toEqual(mockPatterns);
-        expect(result.stats).toEqual(mockStats);
-        expect(result.totalPatterns).toBe(2);
-        expect(result.dataTypes).toContain('email');
-        expect(result.dataTypes).toContain('phone');
-      });
-
-      it('should filter patterns by data type', async () => {
-        const allPatterns = [
-          { name: 'email1', dataType: 'email', pattern: /test/g, description: 'Email 1' },
-          { name: 'email2', dataType: 'email', pattern: /test/g, description: 'Email 2' },
-          { name: 'phone1', dataType: 'phone', pattern: /test/g, description: 'Phone 1' },
-        ];
-        const mockStats = { builtInPatterns: 3, customPatterns: 0, totalPatterns: 3, enabledPatterns: 3 };
-
-        mockPIIPatternService.getAllPatterns.mockReturnValue(allPatterns);
-        mockPIIPatternService.getStats.mockReturnValue(mockStats);
-
-        const result = await controller.getPIIPatterns('email');
-
-        expect(result.patterns).toHaveLength(2);
-        expect(result.patterns.every(p => p.dataType === 'email')).toBe(true);
-      });
-    });
-
-    describe('POST /sanitization/pii/patterns', () => {
-      it('should add custom PII pattern successfully', async () => {
-        const createPatternDto = {
-          name: 'custom_email',
-          pattern: '\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b',
-          dataType: 'email' as const,
-          description: 'Custom email pattern',
-          priority: 10,
-        };
-
-        mockPIIPatternService.addCustomPattern.mockResolvedValue();
-
-        const result = await controller.addPIIPattern(createPatternDto);
-
-        expect(result.success).toBe(true);
-        expect(result.message).toContain('custom_email');
-        expect(result.pattern).toEqual(createPatternDto);
-        expect(mockPIIPatternService.addCustomPattern).toHaveBeenCalled();
-      });
-
-      it('should handle invalid regex patterns', async () => {
-        const invalidPatternDto = {
-          name: 'invalid_pii',
-          pattern: '[',
-          dataType: 'custom' as const,
-          description: 'Invalid pattern',
-        };
-
-        const result = await controller.addPIIPattern(invalidPatternDto);
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('Failed to add PII pattern');
-      });
-
-      it('should handle service errors', async () => {
-        const createPatternDto = {
-          name: 'test_pii',
-          pattern: 'test',
-          dataType: 'custom' as const,
-          description: 'Test pattern',
-        };
-
-        mockPIIPatternService.addCustomPattern.mockRejectedValue(new Error('Service error'));
-
-        const result = await controller.addPIIPattern(createPatternDto);
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('Service error');
-      });
-    });
-
-    describe('POST /sanitization/pii/test', () => {
-      it('should test PII detection successfully', async () => {
-        const testText = 'Contact john@example.com or call (555) 123-4567';
-        const mockDetectionResult = {
-          matches: [
-            { value: 'john@example.com', dataType: 'email', patternName: 'email', startIndex: 8, endIndex: 23, confidence: 1.0 },
-            { value: '(555) 123-4567', dataType: 'phone', patternName: 'phone', startIndex: 32, endIndex: 46, confidence: 1.0 },
-          ],
-          processingTime: 5,
-          patternsChecked: 10,
-        };
-
-        mockPIIPatternService.detectPII.mockResolvedValue(mockDetectionResult);
-
-        const result = await controller.testPIIDetection(testText);
-
-        expect(result.success).toBe(true);
-        expect(result.originalText).toBe(testText);
-        expect(result.detectionResult).toEqual(mockDetectionResult);
-        expect(result.matchCount).toBe(2);
-        expect(result.processingTime).toBe(5);
-      });
-
-      it('should handle custom parameters', async () => {
-        const testText = 'john@example.com and (555) 123-4567';
-        const dataTypes = ['email'];
-        const minConfidence = 0.9;
-
-        mockPIIPatternService.detectPII.mockResolvedValue({
-          matches: [{ value: 'john@example.com', dataType: 'email', patternName: 'email', startIndex: 0, endIndex: 15, confidence: 1.0 }],
-          processingTime: 3,
-          patternsChecked: 5,
-        });
-
-        const result = await controller.testPIIDetection(testText, dataTypes, minConfidence);
-
-        expect(mockPIIPatternService.detectPII).toHaveBeenCalledWith(testText, {
-          dataTypes,
-          minConfidence,
-          maxMatches: 50,
-        });
-      });
-
-      it('should handle missing text input', async () => {
-        const result = await controller.testPIIDetection('');
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('Text is required');
-      });
-    });
-
-    describe('GET /sanitization/pii/patterns/:dataType', () => {
-      it('should return patterns for specific data type', async () => {
-        const emailPatterns = [
-          { name: 'email1', dataType: 'email', pattern: /test/g, description: 'Email 1' },
-          { name: 'email2', dataType: 'email', pattern: /test/g, description: 'Email 2' },
-        ];
-
-        mockPIIPatternService.getPatternsByDataType.mockReturnValue(emailPatterns);
-
-        const result = await controller.getPIIPatternsByType('email');
-
-        expect(result.dataType).toBe('email');
-        expect(result.patterns).toEqual(emailPatterns);
-        expect(result.count).toBe(2);
-        expect(mockPIIPatternService.getPatternsByDataType).toHaveBeenCalledWith('email');
-      });
-    });
-  });
-
-  describe('Pseudonymization Endpoints', () => {
-    describe('POST /sanitization/pseudonym/generate', () => {
-      it('should generate pseudonym successfully', async () => {
-        const mockPseudonymResult = {
-          originalValue: 'john@example.com',
-          pseudonym: 'user123@example.com',
-          dataType: 'email',
-          isNew: true,
-          context: 'test-context',
-        };
-
-        mockPseudonymizationService.generatePseudonym.mockResolvedValue(mockPseudonymResult);
-
-        const result = await controller.generatePseudonym('john@example.com', 'email', 'test-context');
-
-        expect(result.success).toBe(true);
-        expect(result.originalValue).toBe('john@example.com');
-        expect(result.pseudonym).toBe('user123@example.com');
-        expect(result.dataType).toBe('email');
-        expect(result.isNew).toBe(true);
-        expect(result.context).toBe('test-context');
-      });
-
-      it('should handle missing required parameters', async () => {
-        const result = await controller.generatePseudonym('', 'email');
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('Value and dataType are required');
-      });
-
-      it('should handle service errors', async () => {
-        mockPseudonymizationService.generatePseudonym.mockRejectedValue(new Error('Generation error'));
-
-        const result = await controller.generatePseudonym('test@example.com', 'email');
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('Generation error');
-      });
-    });
-
-    describe('POST /sanitization/pseudonym/lookup', () => {
-      it('should lookup existing pseudonym', async () => {
-        mockPseudonymizationService.lookupPseudonym.mockResolvedValue('user123@example.com');
-
-        const result = await controller.lookupPseudonym('john@example.com', 'email');
-
-        expect(result.success).toBe(true);
-        expect(result.originalValue).toBe('john@example.com');
-        expect(result.dataType).toBe('email');
-        expect(result.pseudonym).toBe('user123@example.com');
-        expect(result.found).toBe(true);
-      });
-
-      it('should handle non-existent pseudonym', async () => {
-        mockPseudonymizationService.lookupPseudonym.mockResolvedValue(null);
-
-        const result = await controller.lookupPseudonym('nonexistent@example.com', 'email');
-
-        expect(result.success).toBe(true);
-        expect(result.pseudonym).toBeNull();
-        expect(result.found).toBe(false);
-      });
-
-      it('should handle missing parameters', async () => {
-        const result = await controller.lookupPseudonym('', 'email');
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('Value and dataType are required');
-      });
-    });
-
-    describe('GET /sanitization/pseudonym/stats', () => {
-      it('should return pseudonymization statistics', async () => {
-        const mockStats = {
-          totalPIIPatterns: 15,
-          productionMode: false,
-          customPatterns: 3,
-          patternServiceStats: {},
-        };
-
-        mockPseudonymizationService.getStats.mockResolvedValue(mockStats);
-
-        const result = await controller.getPseudonymizationStats();
-
-        expect(result.success).toBe(true);
-        expect(result.stats).toEqual(mockStats);
-        expect(result.timestamp).toBeDefined();
-      });
-    });
-  });
-
-  describe('Integrated Sanitization Endpoints', () => {
-    describe('POST /sanitization/test', () => {
-      it('should test complete sanitization pipeline', async () => {
-        const testText = 'API: sk-1234567890 Email: john@example.com';
-        const mockTestResult = {
-          sanitizedText: 'API: [REDACTED] Email: user123@example.com',
-          result: {
-            sanitizedText: 'API: [REDACTED] Email: user123@example.com',
-            originalLength: testText.length,
-            sanitizedLength: 42,
-            processingTimeMs: 15,
-          },
-          redactionDetails: { redactedText: 'API: [REDACTED] Email: john@example.com', result: {}, patternDetails: [] },
-          pseudonymizationDetails: { originalText: testText, pseudonymizedText: 'user123@example.com', pseudonyms: [], processingTime: 5 },
-        };
-
-        mockDataSanitizationService.testSanitization.mockResolvedValue(mockTestResult);
-
-        const result = await controller.testCompleteSanitization({ text: testText });
-
-        expect(result.success).toBe(true);
-        expect(result.originalText).toBe(testText);
-        expect(result.sanitizedText).toBe('API: [REDACTED] Email: user123@example.com');
-        expect(result.result).toEqual(mockTestResult.result);
-        expect(result.redactionDetails).toBeDefined();
-        expect(result.pseudonymizationDetails).toBeDefined();
-        expect(result.processingTime).toBe(15);
-      });
-
-      it('should handle missing text', async () => {
-        const result = await controller.testCompleteSanitization({ text: '' });
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('Text is required');
-      });
-
-      it('should handle service errors', async () => {
-        mockDataSanitizationService.testSanitization.mockRejectedValue(new Error('Test error'));
-
-        const result = await controller.testCompleteSanitization({ text: 'test' });
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('Test error');
-      });
-    });
-
-    describe('POST /sanitization/sanitize', () => {
-      it('should sanitize text successfully', async () => {
-        const testText = 'Contact john@example.com with API key sk-1234567890';
-        const mockSanitizeResult = {
-          sanitizedText: 'Contact user123@example.com with API key [REDACTED]',
-          originalLength: testText.length,
-          sanitizedLength: 47,
-          processingTimeMs: 20,
-          redactionResult: { redactionCount: 1, patternsMatched: ['api_key'] },
-          pseudonymizationResult: { pseudonyms: [{}], processingTime: 5 },
-        };
-
-        mockDataSanitizationService.sanitizeText.mockResolvedValue(mockSanitizeResult);
-
-        const result = await controller.sanitizeText({
-          text: testText,
-          enableRedaction: true,
-          enablePseudonymization: true,
-          context: 'test-context',
-        });
-
-        expect(result.success).toBe(true);
-        expect(result.sanitizedText).toBe('Contact user123@example.com with API key [REDACTED]');
-        expect(result.originalLength).toBe(testText.length);
-        expect(result.sanitizedLength).toBe(47);
-        expect(result.processingTime).toBe(20);
-        expect(result.redactionApplied).toBe(true);
-        expect(result.pseudonymizationApplied).toBe(true);
-      });
-
-      it('should handle optional parameters', async () => {
-        const testText = 'test text';
-        const mockResult = {
-          sanitizedText: testText,
-          originalLength: 9,
-          sanitizedLength: 9,
-          processingTimeMs: 1,
-        };
-
-        mockDataSanitizationService.sanitizeText.mockResolvedValue(mockResult);
-
-        const result = await controller.sanitizeText({ text: testText });
-
-        expect(mockDataSanitizationService.sanitizeText).toHaveBeenCalledWith(testText, {
-          enableRedaction: true,
-          enablePseudonymization: true,
-          pseudonymizationContext: 'api-request',
-        });
-      });
-
-      it('should handle missing text', async () => {
-        const result = await controller.sanitizeText({ text: '' });
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('Text is required');
-      });
-
-      it('should handle service errors', async () => {
-        mockDataSanitizationService.sanitizeText.mockRejectedValue(new Error('Sanitization error'));
-
-        const result = await controller.sanitizeText({ text: 'test' });
-
-        expect(result.success).toBe(false);
-        expect(result.message).toContain('Sanitization error');
-      });
-    });
-
-    describe('GET /sanitization/stats', () => {
-      it('should return comprehensive service statistics', async () => {
-        const mockStats = {
-          redactionStats: { totalPatterns: 10 },
-          pseudonymizationStats: { totalPIIPatterns: 8 },
-          totalPatterns: 18,
-          productionMode: false,
-          verboseLogging: false,
-        };
-        const mockCacheStats = { size: 5, maxSize: 1000, expirationMs: 3600000 };
-
-        mockDataSanitizationService.getStats.mockResolvedValue(mockStats);
-        mockDataSanitizationService.getCacheStats.mockReturnValue(mockCacheStats);
-
-        const result = await controller.getComprehensiveStats();
-
-        expect(result.success).toBe(true);
-        expect(result.sanitizationStats).toEqual(mockStats);
-        expect(result.cacheStats).toEqual(mockCacheStats);
-        expect(result.timestamp).toBeDefined();
-        expect(result.services).toBeDefined();
-        expect(result.services.redaction).toBe('SecretRedactionService');
-        expect(result.services.piiDetection).toBe('PIIPatternService');
-        expect(result.services.pseudonymization).toBe('PseudonymizationService');
-        expect(result.services.orchestration).toBe('DataSanitizationService');
-      });
-    });
-
-    describe('GET /sanitization/health', () => {
-      it('should return healthy status when services work', async () => {
-        const testText = 'test@example.com and (555) 123-4567';
-        const mockTestResult = {
-          sanitizedText: 'user123@example.com and (555) 999-0000',
-          result: { processingTimeMs: 10 },
-          redactionDetails: {},
-          pseudonymizationDetails: {},
-        };
-
-        mockDataSanitizationService.testSanitization.mockResolvedValue(mockTestResult);
-
-        const result = await controller.healthCheck();
-
-        expect(result.success).toBe(true);
-        expect(result.status).toBe('healthy');
-        expect(result.timestamp).toBeDefined();
-        expect(result.testResult).toBeDefined();
-        expect(result.testResult.originalText).toBe(testText);
-        expect(result.testResult.sanitizedText).toBe('user123@example.com and (555) 999-0000');
-        expect(result.testResult.processingTime).toBe(10);
-      });
-
-      it('should return unhealthy status when services fail', async () => {
-        mockDataSanitizationService.testSanitization.mockRejectedValue(new Error('Service unavailable'));
-
-        const result = await controller.healthCheck();
-
-        expect(result.success).toBe(false);
-        expect(result.status).toBe('unhealthy');
-        expect(result.timestamp).toBeDefined();
-        expect(result.error).toContain('Service unavailable');
-      });
-    });
-  });
-
-  describe('Input Validation', () => {
-    it('should handle validation errors gracefully', async () => {
-      // This would typically be handled by NestJS validation pipes
-      // For unit testing, we'll verify the DTOs are structured correctly
-      expect(controller).toBeDefined();
-    });
-
-    it('should sanitize input parameters', async () => {
-      // Test that malicious input doesn't break the system
-      const maliciousText = '<script>alert("xss")</script>test@example.com';
-      
-      mockDataSanitizationService.sanitizeText.mockResolvedValue({
-        sanitizedText: 'user123@example.com',
-        originalLength: maliciousText.length,
-        sanitizedLength: 17,
-        processingTimeMs: 5,
-      });
-
-      const result = await controller.sanitizeText({ text: maliciousText });
-
-      expect(result.success).toBe(true);
-      // The sanitization service should handle the malicious content
-      expect(mockDataSanitizationService.sanitizeText).toHaveBeenCalledWith(maliciousText, expect.any(Object));
-    });
-  });
-
-  describe('Error Handling', () => {
-    it('should handle unexpected errors gracefully', async () => {
-      mockSecretRedactionService.getRedactionPatterns.mockImplementation(() => {
-        throw new Error('Unexpected error');
-      });
-
-      await expect(controller.getRedactionPatterns()).rejects.toThrow('Unexpected error');
-    });
-
-    it('should handle service unavailability', async () => {
-      mockDataSanitizationService.getStats.mockRejectedValue(new Error('Service unavailable'));
-
-      await expect(controller.getComprehensiveStats()).rejects.toThrow('Service unavailable');
-    });
-  });
-
-  describe('Performance', () => {
-    it('should handle concurrent requests', async () => {
-      const mockResult = {
-        sanitizedText: 'test',
-        originalLength: 4,
-        sanitizedLength: 4,
-        processingTimeMs: 1,
-      };
-
-      mockDataSanitizationService.sanitizeText.mockResolvedValue(mockResult);
-
-      const requests = Array.from({ length: 10 }, () => 
-        controller.sanitizeText({ text: 'test text' })
-      );
-
-      const results = await Promise.all(requests);
-
-      expect(results).toHaveLength(10);
-      results.forEach(result => {
-        expect(result.success).toBe(true);
-      });
-    });
-
-    it('should handle large input efficiently', async () => {
-      const largeText = 'test@example.com '.repeat(1000);
-      const mockResult = {
-        sanitizedText: 'user123@example.com '.repeat(1000),
-        originalLength: largeText.length,
-        sanitizedLength: largeText.length,
-        processingTimeMs: 50,
-      };
-
-      mockDataSanitizationService.sanitizeText.mockResolvedValue(mockResult);
-
-      const startTime = Date.now();
-      const result = await controller.sanitizeText({ text: largeText });
-      const endTime = Date.now();
-
-      expect(result.success).toBe(true);
-      expect(endTime - startTime).toBeLessThan(1000); // Should complete quickly
-    });
-  });
-});
\ No newline at end of file
diff --git a/apps/api/src/llms/sanitization-management.controller.ts b/apps/api/src/llms/sanitization-management.controller.ts
deleted file mode 100644
index 509bef5..0000000
--- a/apps/api/src/llms/sanitization-management.controller.ts
+++ /dev/null
@@ -1,1383 +0,0 @@
-import {
-  Controller,
-  Get,
-  Post,
-  Put,
-  Delete,
-  Body,
-  Param,
-  Query,
-  HttpCode,
-  HttpStatus,
-  ValidationPipe,
-  UsePipes,
-} from '@nestjs/common';
-import { ApiTags, ApiOperation, ApiResponse, ApiQuery, ApiParam } from '@nestjs/swagger';
-import { SecretRedactionService } from './secret-redaction.service';
-import { PIIPatternService, PIIDataType } from './pii-pattern.service';
-import { PseudonymizationService } from './pseudonymization.service';
-import { DataSanitizationService } from './data-sanitization.service';
-import { SupabaseService } from '../supabase/supabase.service';
-import { IsString, IsOptional, IsEnum, IsNumber, IsBoolean, IsArray, Min, Max } from 'class-validator';
-
-// DTO Classes for API validation
-class CreateRedactionPatternDto {
-  @IsString()
-  name!: string;
-
-  @IsString()
-  pattern!: string;
-
-  @IsString()
-  replacement!: string;
-
-  @IsString()
-  @IsOptional()
-  description?: string;
-
-  @IsString()
-  @IsOptional()
-  category?: string;
-
-  @IsNumber()
-  @IsOptional()
-  @Min(1)
-  @Max(100)
-  priority?: number;
-}
-
-class CreatePIIPatternDto {
-  @IsString()
-  name!: string;
-
-  @IsString()
-  pattern!: string;
-
-  @IsEnum(['email', 'phone', 'name', 'address', 'ip_address', 'username', 'credit_card', 'ssn', 'custom'])
-  dataType!: PIIDataType;
-
-  @IsString()
-  @IsOptional()
-  description?: string;
-
-  @IsNumber()
-  @IsOptional()
-  @Min(1)
-  @Max(100)
-  priority?: number;
-}
-
-class TestSanitizationDto {
-  @IsString()
-  text!: string;
-
-  @IsBoolean()
-  @IsOptional()
-  enableRedaction?: boolean;
-
-  @IsBoolean()
-  @IsOptional()
-  enablePseudonymization?: boolean;
-
-  @IsString()
-  @IsOptional()
-  context?: string;
-}
-
-class CreatePseudonymDictionaryDto {
-  @IsEnum(['email', 'phone', 'name', 'address', 'ip_address', 'username', 'credit_card', 'ssn', 'custom'])
-  dataType!: PIIDataType;
-
-  @IsString()
-  category!: string;
-
-  @IsArray()
-  @IsString({ each: true })
-  words!: string[];
-
-  @IsString()
-  @IsOptional()
-  description?: string;
-
-  @IsString()
-  @IsOptional()
-  locale?: string;
-
-  @IsBoolean()
-  @IsOptional()
-  isActive?: boolean;
-
-  @IsNumber()
-  @IsOptional()
-  frequencyWeight?: number;
-}
-
-class UpdatePseudonymDictionaryDto {
-  @IsString()
-  @IsOptional()
-  category?: string;
-
-  @IsArray()
-  @IsString({ each: true })
-  @IsOptional()
-  words?: string[];
-
-  @IsString()
-  @IsOptional()
-  description?: string;
-
-  @IsString()
-  @IsOptional()
-  locale?: string;
-
-  @IsBoolean()
-  @IsOptional()
-  isActive?: boolean;
-
-  @IsNumber()
-  @IsOptional()
-  frequencyWeight?: number;
-}
-
-@ApiTags('Sanitization Management')
-@Controller('llm/sanitization')
-export class SanitizationManagementController {
-  constructor(
-    private readonly secretRedactionService: SecretRedactionService,
-    private readonly piiPatternService: PIIPatternService,
-    private readonly pseudonymizationService: PseudonymizationService,
-    private readonly dataSanitizationService: DataSanitizationService,
-    private readonly supabaseService: SupabaseService,
-  ) {}
-
-  // =====================================
-  // REDACTION PATTERN ENDPOINTS
-  // =====================================
-
-  @Get('redaction/patterns')
-  @ApiOperation({ summary: 'Get all redaction patterns' })
-  @ApiResponse({ status: 200, description: 'List of redaction patterns' })
-  async getRedactionPatterns() {
-    try {
-      const client = this.supabaseService.getServiceClient();
-      
-      // Query redaction patterns from database (excluding PII patterns)
-      const { data: dbPatterns, error } = await client
-        .from('redaction_patterns')
-        .select('*')
-        .not('category', 'in', '(pii_custom,pii_builtin)')
-        .eq('is_active', true)
-        .order('priority', { ascending: true });
-
-      if (error && error.code !== '42P01') { // Ignore table not exists error
-        throw new Error(`Database query failed: ${error.message}`);
-      }
-
-      // Get built-in patterns from service
-      const builtinPatterns = this.secretRedactionService.getRedactionPatterns();
-      
-      // Format database patterns to match service structure
-      const formattedDbPatterns = (dbPatterns || []).map(pattern => ({
-        id: pattern.id,
-        name: pattern.name,
-        pattern: pattern.pattern_regex, // Store as string
-        replacement: pattern.replacement,
-        description: pattern.description || '',
-        priority: pattern.priority || 50,
-        category: pattern.category,
-        isActive: pattern.is_active,
-        isCustom: true,
-        createdAt: pattern.created_at,
-        lastUsed: pattern.last_used_at,
-        usageCount: pattern.usage_count || 0,
-      }));
-
-      // Combine database patterns with built-in patterns
-      const allPatterns = [
-        ...formattedDbPatterns,
-        ...builtinPatterns.map(p => ({
-          ...p,
-          isCustom: false,
-          category: 'builtin',
-          isActive: true,
-        }))
-      ];
-      
-      // Get stats from service and enhance with database info
-      const serviceStats = this.secretRedactionService.getStats();
-      const dbStats = {
-        customPatterns: formattedDbPatterns.length,
-        activeCustomPatterns: formattedDbPatterns.filter(p => p.isActive).length,
-        totalDatabasePatterns: formattedDbPatterns.length,
-      };
-      
-      return {
-        patterns: allPatterns,
-        stats: {
-          ...serviceStats,
-          ...dbStats,
-          totalPatterns: allPatterns.length,
-          builtInPatterns: allPatterns.filter(p => !p.isCustom).length,
-          customPatterns: allPatterns.filter(p => p.isCustom).length,
-        },
-        totalPatterns: allPatterns.length,
-      };
-    } catch (error) {
-      // Fallback to service patterns if database fails
-      console.error('Database query failed, falling back to service patterns:', error);
-      const patterns = this.secretRedactionService.getRedactionPatterns();
-      const stats = this.secretRedactionService.getStats();
-      
-      return {
-        patterns: patterns.map(p => ({ ...p, isCustom: false, category: 'builtin' })),
-        stats: {
-          ...stats,
-          databaseError: error instanceof Error ? error.message : 'Unknown error',
-        },
-        totalPatterns: patterns.length,
-      };
-    }
-  }
-
-  @Post('redaction/patterns')
-  @ApiOperation({ summary: 'Add custom redaction pattern' })
-  @ApiResponse({ status: 201, description: 'Pattern created successfully' })
-  @ApiResponse({ status: 400, description: 'Invalid pattern data' })
-  @UsePipes(new ValidationPipe())
-  async addRedactionPattern(@Body() createPatternDto: CreateRedactionPatternDto) {
-    try {
-      // Validate regex pattern
-      new RegExp(createPatternDto.pattern);
-      
-      this.secretRedactionService.addRedactionPattern({
-        name: createPatternDto.name,
-        pattern: new RegExp(createPatternDto.pattern, 'gi'),
-        replacement: createPatternDto.replacement,
-        description: createPatternDto.description || '',
-      });
-
-      return {
-        success: true,
-        message: `Redaction pattern '${createPatternDto.name}' added successfully`,
-        pattern: createPatternDto,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Failed to add pattern: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      };
-    }
-  }
-
-  @Delete('redaction/patterns/:name')
-  @ApiOperation({ summary: 'Remove redaction pattern by name' })
-  @ApiParam({ name: 'name', description: 'Pattern name to remove' })
-  @ApiResponse({ status: 200, description: 'Pattern removed successfully' })
-  @ApiResponse({ status: 404, description: 'Pattern not found' })
-  async removeRedactionPattern(@Param('name') name: string) {
-    const success = this.secretRedactionService.removeRedactionPattern(name);
-    
-    return {
-      success,
-      message: success 
-        ? `Redaction pattern '${name}' removed successfully`
-        : `Redaction pattern '${name}' not found`,
-    };
-  }
-
-  @Post('redaction/test')
-  @ApiOperation({ summary: 'Test redaction patterns against sample text' })
-  @ApiResponse({ status: 200, description: 'Redaction test results' })
-  @HttpCode(HttpStatus.OK)
-  async testRedaction(@Body('text') text: string) {
-    if (!text) {
-      return {
-        success: false,
-        message: 'Text is required for testing',
-      };
-    }
-
-    const result = this.secretRedactionService.testRedaction(text);
-    
-    return {
-      success: true,
-      originalText: text,
-      redactedText: result.redactedText,
-      result: result.result,
-      patternDetails: result.patternDetails,
-    };
-  }
-
-  // =====================================
-  // PII PATTERN ENDPOINTS  
-  // =====================================
-
-  @Get('pii/patterns')
-  @ApiOperation({ summary: 'Get all PII detection patterns' })
-  @ApiQuery({ name: 'dataType', required: false, description: 'Filter by data type' })
-  @ApiResponse({ status: 200, description: 'List of PII patterns' })
-  async getPIIPatterns(@Query('dataType') dataType?: PIIDataType) {
-    try {
-      const client = this.supabaseService.getServiceClient();
-      
-      // Query PII patterns from database (category = 'pii_custom' or 'pii_builtin')
-      let query = client
-        .from('redaction_patterns')
-        .select('*')
-        .or('category.eq.pii_custom,category.eq.pii_builtin')
-        .eq('is_active', true)
-        .order('priority', { ascending: true });
-
-      const { data: dbPatterns, error } = await query;
-
-      if (error && error.code !== '42P01') { // Ignore table not exists error
-        throw new Error(`Database query failed: ${error.message}`);
-      }
-
-      // Format database patterns to match expected structure
-      const formattedDbPatterns = (dbPatterns || []).map(pattern => ({
-        id: pattern.id,
-        name: pattern.name,
-        dataType: this.extractDataTypeFromPattern(pattern.pattern_regex, pattern.name),
-        pattern: pattern.pattern_regex, // Store as string, will be converted to RegExp when used
-        description: pattern.description || '',
-        priority: pattern.priority || 50,
-        enabled: pattern.is_active,
-        isCustom: pattern.category === 'pii_custom',
-        category: pattern.category,
-        replacement: pattern.replacement,
-        createdAt: pattern.created_at,
-        lastUsed: pattern.last_used_at,
-        usageCount: pattern.usage_count || 0,
-      }));
-
-      // Use only database patterns (service now loads from database too, so no need to combine)
-      const allPatterns = formattedDbPatterns;
-
-      // Apply dataType filter if specified
-      const filteredPatterns = dataType 
-        ? allPatterns.filter(p => p.dataType === dataType)
-        : allPatterns;
-      
-      // Get stats from service (now database-only)
-      const serviceStats = this.piiPatternService.getStats();
-      const dbStats = {
-        customPatterns: formattedDbPatterns.filter(p => p.category === 'pii_custom').length,
-        activeCustomPatterns: formattedDbPatterns.filter(p => p.enabled && p.category === 'pii_custom').length,
-        totalDatabasePatterns: formattedDbPatterns.length,
-      };
-      
-      return {
-        patterns: filteredPatterns,
-        stats: {
-          ...serviceStats,
-          ...dbStats,
-          totalPatterns: allPatterns.length,
-          builtInPatterns: allPatterns.filter(p => !p.isCustom).length,
-          customPatterns: allPatterns.filter(p => p.isCustom).length,
-        },
-        totalPatterns: filteredPatterns.length,
-        dataTypes: ['email', 'phone', 'name', 'address', 'ip_address', 'username', 'credit_card', 'ssn', 'custom'],
-      };
-    } catch (error) {
-      // Fallback to service patterns if database fails
-      console.error('Database query failed, falling back to service patterns:', error);
-      const allPatterns = this.piiPatternService.getAllPatterns();
-      const filteredPatterns = dataType 
-        ? allPatterns.filter(p => p.dataType === dataType)
-        : allPatterns;
-      
-      const stats = this.piiPatternService.getStats();
-      
-      return {
-        patterns: filteredPatterns,
-        stats: {
-          ...stats,
-          databaseError: error instanceof Error ? error.message : 'Unknown error',
-        },
-        totalPatterns: filteredPatterns.length,
-        dataTypes: ['email', 'phone', 'name', 'address', 'ip_address', 'username', 'credit_card', 'ssn', 'custom'],
-      };
-    }
-  }
-
-  @Post('pii/patterns')
-  @ApiOperation({ summary: 'Add custom PII detection pattern' })
-  @ApiResponse({ status: 201, description: 'PII pattern created successfully' })
-  @ApiResponse({ status: 400, description: 'Invalid pattern data' })
-  @UsePipes(new ValidationPipe())
-  async addPIIPattern(@Body() createPatternDto: CreatePIIPatternDto) {
-    try {
-      // Validate regex pattern
-      const regex = new RegExp(createPatternDto.pattern, 'g');
-      
-      await this.piiPatternService.addCustomPattern({
-        name: createPatternDto.name,
-        dataType: createPatternDto.dataType,
-        pattern: regex,
-        description: createPatternDto.description || '',
-        priority: createPatternDto.priority,
-      });
-
-      return {
-        success: true,
-        message: `PII pattern '${createPatternDto.name}' added successfully`,
-        pattern: createPatternDto,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Failed to add PII pattern: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      };
-    }
-  }
-
-  @Post('pii/test')
-  @ApiOperation({ summary: 'Test PII detection patterns against sample text' })
-  @ApiResponse({ status: 200, description: 'PII detection test results' })
-  @HttpCode(HttpStatus.OK)
-  async testPIIDetection(
-    @Body('text') text: string,
-    @Body('dataTypes') dataTypes?: PIIDataType[],
-    @Body('minConfidence') minConfidence?: number
-  ) {
-    if (!text) {
-      return {
-        success: false,
-        message: 'Text is required for testing',
-      };
-    }
-
-    const result = await this.piiPatternService.detectPII(text, {
-      dataTypes,
-      minConfidence: minConfidence || 0.7,
-      maxMatches: 50,
-    });
-    
-    return {
-      success: true,
-      originalText: text,
-      detectionResult: result,
-      matchCount: result.matches.length,
-      processingTime: result.processingTime,
-    };
-  }
-
-  @Put('pii/patterns/:name')
-  @ApiOperation({ summary: 'Update existing PII pattern' })
-  @ApiParam({ name: 'name', description: 'Pattern name to update' })
-  @ApiResponse({ status: 200, description: 'PII pattern updated successfully' })
-  @ApiResponse({ status: 404, description: 'Pattern not found' })
-  @UsePipes(new ValidationPipe())
-  async updatePIIPattern(@Param('name') name: string, @Body() updatePatternDto: CreatePIIPatternDto) {
-    try {
-      // Update in database
-      const client = this.supabaseService.getServiceClient();
-      const { error } = await client
-        .from('redaction_patterns')
-        .update({
-          name: updatePatternDto.name,
-          pattern_regex: updatePatternDto.pattern,
-          description: updatePatternDto.description || '',
-          priority: updatePatternDto.priority || 50,
-        })
-        .eq('name', name)
-        .eq('category', 'pii_custom');
-
-      if (error) {
-        throw new Error(error.message);
-      }
-
-      // Force reload patterns from database
-      await this.piiPatternService.forceReload();
-
-      return {
-        success: true,
-        message: `PII pattern '${name}' updated successfully`,
-        pattern: updatePatternDto,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Failed to update PII pattern: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      };
-    }
-  }
-
-  @Delete('pii/patterns/:name')
-  @ApiOperation({ summary: 'Delete PII pattern by name' })
-  @ApiParam({ name: 'name', description: 'Pattern name to delete' })
-  @ApiResponse({ status: 200, description: 'PII pattern deleted successfully' })
-  @ApiResponse({ status: 404, description: 'Pattern not found' })
-  async deletePIIPattern(@Param('name') name: string) {
-    try {
-      // Remove from database
-      const client = this.supabaseService.getServiceClient();
-      const { error } = await client
-        .from('redaction_patterns')
-        .delete()
-        .eq('name', name)
-        .eq('category', 'pii_custom');
-
-      if (error) {
-        throw new Error(error.message);
-      }
-
-      // Force reload patterns from database
-      await this.piiPatternService.forceReload();
-
-      return {
-        success: true,
-        message: `PII pattern '${name}' deleted successfully`,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Failed to delete PII pattern: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      };
-    }
-  }
-
-  @Get('pii/patterns/:dataType')
-  @ApiOperation({ summary: 'Get PII patterns by data type' })
-  @ApiParam({ name: 'dataType', enum: ['email', 'phone', 'name', 'address', 'ip_address', 'username', 'credit_card', 'ssn', 'custom'] })
-  @ApiResponse({ status: 200, description: 'PII patterns for specified data type' })
-  async getPIIPatternsByType(@Param('dataType') dataType: PIIDataType) {
-    const patterns = this.piiPatternService.getPatternsByDataType(dataType);
-    
-    return {
-      dataType,
-      patterns,
-      count: patterns.length,
-    };
-  }
-
-  // =====================================
-  // PSEUDONYMIZATION ENDPOINTS
-  // =====================================
-
-  @Post('pseudonym/generate')
-  @ApiOperation({ summary: 'Generate pseudonym for a specific value' })
-  @ApiResponse({ status: 200, description: 'Pseudonym generated successfully' })
-  async generatePseudonym(
-    @Body('value') value: string,
-    @Body('dataType') dataType: PIIDataType,
-    @Body('context') context?: string
-  ) {
-    if (!value || !dataType) {
-      return {
-        success: false,
-        message: 'Value and dataType are required',
-      };
-    }
-
-    try {
-      const result = await this.pseudonymizationService.generatePseudonym(value, dataType, context);
-      
-      return {
-        success: true,
-        originalValue: value,
-        pseudonym: result.pseudonym,
-        dataType: result.dataType,
-        isNew: result.isNew,
-        context: result.context,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Failed to generate pseudonym: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      };
-    }
-  }
-
-  @Post('pseudonym/lookup')
-  @ApiOperation({ summary: 'Lookup existing pseudonym' })
-  @ApiResponse({ status: 200, description: 'Pseudonym lookup result' })
-  @HttpCode(HttpStatus.OK)
-  async lookupPseudonym(
-    @Body('value') value: string,
-    @Body('dataType') dataType: PIIDataType
-  ) {
-    if (!value || !dataType) {
-      return {
-        success: false,
-        message: 'Value and dataType are required',
-      };
-    }
-
-    const pseudonym = await this.pseudonymizationService.lookupPseudonym(value, dataType);
-    
-    return {
-      success: true,
-      originalValue: value,
-      dataType,
-      pseudonym,
-      found: !!pseudonym,
-    };
-  }
-
-  @Get('pseudonym/stats')
-  @ApiOperation({ summary: 'Get pseudonymization service statistics' })
-  @ApiResponse({ status: 200, description: 'Pseudonymization statistics' })
-  async getPseudonymizationStats() {
-    const stats = await this.pseudonymizationService.getStats();
-    
-    return {
-      success: true,
-      stats,
-      timestamp: new Date().toISOString(),
-    };
-  }
-
-  @Get('pseudonym/dictionaries')
-  @ApiOperation({ summary: 'Get all pseudonym dictionaries' })
-  @ApiResponse({ status: 200, description: 'List of pseudonym dictionaries' })
-  async getPseudonymDictionaries() {
-    try {
-      const client = this.supabaseService.getServiceClient();
-      
-      // Query pseudonym dictionary data from database - actual structure is individual rows per value
-      const { data: dictionaryEntries, error } = await client
-        .from('pseudonym_dictionaries')
-        .select('*')
-        .eq('is_active', true)
-        .order('category', { ascending: true });
-
-      if (error) {
-        // If table doesn't exist, return empty result
-        if (error.code === '42P01') {
-          return {
-            dictionaries: [],
-            totalDictionaries: 0,
-            totalWords: 0,
-            categories: [],
-            stats: {
-              activeDictionaries: 0,
-              builtInDictionaries: 0,
-              customDictionaries: 0,
-            },
-          };
-        }
-        throw new Error(`Database query failed: ${error.message}`);
-      }
-
-      // Group the individual dictionary entries by category
-      const groupedEntries = (dictionaryEntries || []).reduce((groups, entry) => {
-        const key = `${entry.data_type}-${entry.category}`;
-        if (!groups[key]) {
-          groups[key] = {
-            id: entry.category, // Use category as ID for grouping
-            category: entry.category,
-            name: entry.category.replace(/_/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase()),
-            description: `${entry.category.replace(/_/g, ' ')} for ${entry.data_type} pseudonymization`,
-            dataType: entry.data_type,
-            words: [],
-            isActive: entry.is_active,
-            isBuiltIn: true, // All current entries are built-in
-            lastUpdated: entry.created_at,
-          };
-        }
-        groups[key].words.push(entry.value);
-        return groups;
-      }, {} as Record<string, any>);
-
-      // Convert grouped entries to array and add word counts
-      const formattedDictionaries = Object.values(groupedEntries).map((dict: any) => ({
-        ...dict,
-        wordsCount: dict.words.length,
-      }));
-
-      const totalWords = formattedDictionaries.reduce((sum, dict) => sum + dict.wordsCount, 0);
-      const categories = [...new Set(formattedDictionaries.map(d => d.category))];
-
-      return {
-        dictionaries: formattedDictionaries,
-        totalDictionaries: formattedDictionaries.length,
-        totalWords,
-        categories,
-        stats: {
-          activeDictionaries: formattedDictionaries.filter(d => d.isActive).length,
-          builtInDictionaries: formattedDictionaries.filter(d => d.isBuiltIn).length,
-          customDictionaries: formattedDictionaries.filter(d => !d.isBuiltIn).length,
-        },
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Failed to load dictionaries: ${error instanceof Error ? error.message : 'Unknown error'}`,
-        dictionaries: [],
-        totalDictionaries: 0,
-        totalWords: 0,
-      };
-    }
-  }
-
-  @Get('pseudonym/dictionaries/:id')
-  @ApiOperation({ summary: 'Get pseudonym dictionary by ID' })
-  @ApiParam({ name: 'id', description: 'Dictionary ID' })
-  @ApiResponse({ status: 200, description: 'Pseudonym dictionary found' })
-  @ApiResponse({ status: 404, description: 'Dictionary not found' })
-  async getPseudonymDictionary(@Param('id') id: string) {
-    try {
-      const client = this.supabaseService.getServiceClient();
-      
-      // Query all entries for this dictionary category (since the DB structure stores individual values)
-      const { data: dictionaryEntries, error } = await client
-        .from('pseudonym_dictionaries')
-        .select('*')
-        .eq('category', id) // Using category as ID for grouping
-        .eq('is_active', true)
-        .order('created_at', { ascending: true });
-
-      if (error) {
-        throw new Error(`Database query failed: ${error.message}`);
-      }
-
-      if (!dictionaryEntries || dictionaryEntries.length === 0) {
-        return {
-          success: false,
-          message: 'Dictionary not found',
-        };
-      }
-
-      // Group the entries into a single dictionary object
-      const firstEntry = dictionaryEntries[0];
-      const dictionary = {
-        id: firstEntry.category,
-        category: firstEntry.category,
-        name: firstEntry.category.replace(/_/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase()),
-        description: `${firstEntry.category.replace(/_/g, ' ')} for ${firstEntry.data_type} pseudonymization`,
-        dataType: firstEntry.data_type,
-        words: dictionaryEntries.map(entry => entry.value),
-        isActive: firstEntry.is_active,
-        isBuiltIn: true,
-        lastUpdated: firstEntry.created_at,
-        wordsCount: dictionaryEntries.length,
-        locale: firstEntry.locale || 'en-US',
-        frequencyWeight: firstEntry.frequency_weight || 1,
-      };
-
-      return {
-        success: true,
-        dictionary,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Failed to load dictionary: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      };
-    }
-  }
-
-  @Post('pseudonym/dictionaries')
-  @ApiOperation({ summary: 'Create new pseudonym dictionary' })
-  @ApiResponse({ status: 201, description: 'Dictionary created successfully' })
-  @ApiResponse({ status: 400, description: 'Invalid input' })
-  @UsePipes(new ValidationPipe())
-  async createPseudonymDictionary(@Body() createDto: CreatePseudonymDictionaryDto) {
-    try {
-      const client = this.supabaseService.getServiceClient();
-      
-      // Insert each word as a separate row in the dictionary table
-      const insertData = createDto.words.map(word => ({
-        data_type: createDto.dataType,
-        category: createDto.category,
-        value: word.trim(),
-        locale: createDto.locale || 'en-US',
-        frequency_weight: createDto.frequencyWeight || 1,
-        is_active: createDto.isActive !== false, // Default to true
-      }));
-
-      const { data, error } = await client
-        .from('pseudonym_dictionaries')
-        .insert(insertData)
-        .select();
-
-      if (error) {
-        throw new Error(`Failed to create dictionary: ${error.message}`);
-      }
-
-      // Return formatted dictionary object
-      const dictionary = {
-        id: createDto.category,
-        category: createDto.category,
-        name: createDto.category.replace(/_/g, l => l.toUpperCase()),
-        description: createDto.description || `${createDto.category.replace(/_/g, ' ')} for ${createDto.dataType} pseudonymization`,
-        dataType: createDto.dataType,
-        words: createDto.words,
-        isActive: createDto.isActive !== false,
-        isBuiltIn: false,
-        createdAt: new Date().toISOString(),
-        updatedAt: new Date().toISOString(),
-        wordsCount: createDto.words.length,
-        locale: createDto.locale || 'en-US',
-        frequencyWeight: createDto.frequencyWeight || 1,
-      };
-
-      return {
-        success: true,
-        message: 'Dictionary created successfully',
-        dictionary,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Failed to create dictionary: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      };
-    }
-  }
-
-  @Put('pseudonym/dictionaries/:id')
-  @ApiOperation({ summary: 'Update pseudonym dictionary' })
-  @ApiParam({ name: 'id', description: 'Dictionary ID (category)' })
-  @ApiResponse({ status: 200, description: 'Dictionary updated successfully' })
-  @ApiResponse({ status: 404, description: 'Dictionary not found' })
-  @UsePipes(new ValidationPipe())
-  async updatePseudonymDictionary(@Param('id') id: string, @Body() updateDto: UpdatePseudonymDictionaryDto) {
-    try {
-      const client = this.supabaseService.getServiceClient();
-      
-      // First, check if dictionary exists
-      const { data: existingEntries, error: checkError } = await client
-        .from('pseudonym_dictionaries')
-        .select('*')
-        .eq('category', id);
-
-      if (checkError) {
-        throw new Error(`Database query failed: ${checkError.message}`);
-      }
-
-      if (!existingEntries || existingEntries.length === 0) {
-        return {
-          success: false,
-          message: 'Dictionary not found',
-        };
-      }
-
-      // If words are provided, replace all entries
-      if (updateDto.words && updateDto.words.length > 0) {
-        // Delete existing entries
-        const { error: deleteError } = await client
-          .from('pseudonym_dictionaries')
-          .delete()
-          .eq('category', id);
-
-        if (deleteError) {
-          throw new Error(`Failed to delete existing entries: ${deleteError.message}`);
-        }
-
-        // Insert new entries
-        const insertData = updateDto.words.map(word => ({
-          data_type: existingEntries[0].data_type, // Keep original data type
-          category: updateDto.category || id,
-          value: word.trim(),
-          locale: updateDto.locale || existingEntries[0].locale || 'en-US',
-          frequency_weight: updateDto.frequencyWeight || existingEntries[0].frequency_weight || 1,
-          is_active: updateDto.isActive !== undefined ? updateDto.isActive : existingEntries[0].is_active,
-        }));
-
-        const { error: insertError } = await client
-          .from('pseudonym_dictionaries')
-          .insert(insertData);
-
-        if (insertError) {
-          throw new Error(`Failed to insert new entries: ${insertError.message}`);
-        }
-      } else {
-        // Update existing entries (metadata only)
-        const updateData: any = {};
-        if (updateDto.category) updateData.category = updateDto.category;
-        if (updateDto.locale) updateData.locale = updateDto.locale;
-        if (updateDto.frequencyWeight !== undefined) updateData.frequency_weight = updateDto.frequencyWeight;
-        if (updateDto.isActive !== undefined) updateData.is_active = updateDto.isActive;
-
-        const { error: updateError } = await client
-          .from('pseudonym_dictionaries')
-          .update(updateData)
-          .eq('category', id);
-
-        if (updateError) {
-          throw new Error(`Failed to update entries: ${updateError.message}`);
-        }
-      }
-
-      return {
-        success: true,
-        message: 'Dictionary updated successfully',
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Failed to update dictionary: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      };
-    }
-  }
-
-  @Delete('pseudonym/dictionaries/:id')
-  @ApiOperation({ summary: 'Delete pseudonym dictionary' })
-  @ApiParam({ name: 'id', description: 'Dictionary ID (category)' })
-  @ApiResponse({ status: 200, description: 'Dictionary deleted successfully' })
-  @ApiResponse({ status: 404, description: 'Dictionary not found' })
-  async deletePseudonymDictionary(@Param('id') id: string) {
-    try {
-      const client = this.supabaseService.getServiceClient();
-      
-      // Check if dictionary exists
-      const { data: existingEntries, error: checkError } = await client
-        .from('pseudonym_dictionaries')
-        .select('id')
-        .eq('category', id);
-
-      if (checkError) {
-        throw new Error(`Database query failed: ${checkError.message}`);
-      }
-
-      if (!existingEntries || existingEntries.length === 0) {
-        return {
-          success: false,
-          message: 'Dictionary not found',
-        };
-      }
-
-      // Delete all entries for this category
-      const { error: deleteError } = await client
-        .from('pseudonym_dictionaries')
-        .delete()
-        .eq('category', id);
-
-      if (deleteError) {
-        throw new Error(`Failed to delete dictionary: ${deleteError.message}`);
-      }
-
-      return {
-        success: true,
-        message: 'Dictionary deleted successfully',
-        deletedCount: existingEntries.length,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Failed to delete dictionary: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      };
-    }
-  }
-
-  @Get('pseudonym/mappings')
-  @ApiOperation({ summary: 'Get all pseudonym mappings' })
-  @ApiQuery({ name: 'dataType', required: false, description: 'Filter by data type' })
-  @ApiQuery({ name: 'context', required: false, description: 'Filter by context' })
-  @ApiQuery({ name: 'limit', required: false, description: 'Limit number of results' })
-  @ApiResponse({ status: 200, description: 'List of pseudonym mappings' })
-  async getPseudonymMappings(
-    @Query('dataType') dataType?: PIIDataType,
-    @Query('context') context?: string,
-    @Query('limit') limit?: string
-  ) {
-    try {
-      const client = this.supabaseService.getServiceClient();
-      
-      // Build query for pseudonym mappings - using actual database structure
-      let query = client
-        .from('pseudonym_mappings')
-        .select('*')
-        .order('last_used_at', { ascending: false });
-
-      // Apply filters
-      if (dataType) {
-        query = query.eq('data_type', dataType);
-      }
-      
-      if (context) {
-        query = query.eq('context', context);
-      }
-
-      if (limit) {
-        query = query.limit(parseInt(limit, 10));
-      } else {
-        // Default limit to prevent huge queries
-        query = query.limit(100);
-      }
-
-      const { data: mappings, error } = await query;
-
-      if (error) {
-        // If table doesn't exist, return empty result
-        if (error.code === '42P01') {
-          return {
-            mappings: [],
-            totalMappings: 0,
-            filters: {
-              dataType: dataType || 'all',
-              context: context || 'all',
-              limit: limit || 'all',
-            },
-            stats: {
-              totalByDataType: {},
-              totalUsage: 0,
-              reversibleCount: 0,
-              expiredCount: 0,
-            },
-          };
-        }
-        throw new Error(`Database query failed: ${error.message}`);
-      }
-
-      // Format mappings using actual database columns
-      const formattedMappings = (mappings || []).map(mapping => ({
-        id: mapping.id,
-        originalValue: '[REDACTED]', // Never expose original values - only hash exists in DB
-        originalHash: mapping.original_hash?.substring(0, 8) + '...', // Show partial hash for debugging
-        pseudonym: mapping.pseudonym,
-        dataType: mapping.data_type,
-        context: mapping.context || 'unknown',
-        createdAt: mapping.created_at,
-        lastUsed: mapping.last_used_at || mapping.created_at,
-        usageCount: mapping.usage_count || 1,
-        isReversible: mapping.is_reversible || false,
-        expiresAt: mapping.expires_at,
-        isExpired: mapping.expires_at ? new Date(mapping.expires_at) < new Date() : false,
-        createdBySystem: mapping.created_by_system,
-      }));
-
-      // Calculate stats using actual data
-      const stats = {
-        totalByDataType: {} as Record<string, number>,
-        totalUsage: formattedMappings.reduce((sum, m) => sum + m.usageCount, 0),
-        reversibleCount: formattedMappings.filter(m => m.isReversible).length,
-        expiredCount: formattedMappings.filter(m => m.isExpired).length,
-      };
-
-      formattedMappings.forEach(mapping => {
-        stats.totalByDataType[mapping.dataType] = (stats.totalByDataType[mapping.dataType] || 0) + 1;
-      });
-
-      return {
-        mappings: formattedMappings,
-        totalMappings: formattedMappings.length,
-        filters: {
-          dataType: dataType || 'all',
-          context: context || 'all',
-          limit: limit || 'all',
-        },
-        stats,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Failed to load mappings: ${error instanceof Error ? error.message : 'Unknown error'}`,
-        mappings: [],
-        totalMappings: 0,
-      };
-    }
-  }
-
-  // =====================================
-  // INTEGRATED SANITIZATION ENDPOINTS
-  // =====================================
-
-  @Post('test')
-  @ApiOperation({ summary: 'Test complete sanitization pipeline' })
-  @ApiResponse({ status: 200, description: 'Complete sanitization test results' })
-  @HttpCode(HttpStatus.OK)
-  @UsePipes(new ValidationPipe())
-  async testCompleteSanitization(@Body() testDto: TestSanitizationDto) {
-    if (!testDto.text) {
-      return {
-        success: false,
-        message: 'Text is required for testing',
-      };
-    }
-
-    try {
-      const result = await this.dataSanitizationService.testSanitization(testDto.text);
-      
-      return {
-        success: true,
-        originalText: testDto.text,
-        sanitizedText: result.sanitizedText,
-        result: result.result,
-        redactionDetails: result.redactionDetails,
-        pseudonymizationDetails: result.pseudonymizationDetails,
-        processingTime: result.result.processingTimeMs,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Sanitization test failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      };
-    }
-  }
-
-  @Post('sanitize')
-  @ApiOperation({ summary: 'Sanitize text with options' })
-  @ApiResponse({ status: 200, description: 'Text sanitized successfully' })
-  @UsePipes(new ValidationPipe())
-  async sanitizeText(@Body() sanitizeDto: TestSanitizationDto) {
-    if (!sanitizeDto.text) {
-      return {
-        success: false,
-        message: 'Text is required for sanitization',
-      };
-    }
-
-    try {
-      const result = await this.dataSanitizationService.sanitizeText(sanitizeDto.text, {
-        enableRedaction: sanitizeDto.enableRedaction ?? true,
-        enablePseudonymization: sanitizeDto.enablePseudonymization ?? true,
-        pseudonymizationContext: sanitizeDto.context || 'api-request',
-      });
-      
-      return {
-        success: true,
-        sanitizedText: result.sanitizedText,
-        originalLength: result.originalLength,
-        sanitizedLength: result.sanitizedLength,
-        processingTime: result.processingTimeMs,
-        redactionApplied: !!result.redactionResult,
-        pseudonymizationApplied: !!result.pseudonymizationResult,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Sanitization failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      };
-    }
-  }
-
-  @Get('llm-usage/recent')
-  @ApiOperation({ summary: 'Get recent LLM usage records with PII sanitization data' })
-  @ApiResponse({ status: 200, description: 'Successfully retrieved recent LLM calls' })
-  @ApiQuery({ name: 'limit', required: false, type: Number, description: 'Number of records to return (default: 20)' })
-  async getRecentLLMCalls(@Query('limit') limit?: number) {
-    const recordLimit = limit || 20;
-    
-    try {
-      const client = this.supabaseService.getServiceClient();
-      const { data, error } = await client
-        .from('llm_usage')
-        .select(`
-          run_id,
-          created_at,
-          provider_name,
-          model_name,
-          status,
-          total_cost,
-          duration_ms,
-          pii_detected,
-          pii_types,
-          pseudonyms_used,
-          pseudonym_types,
-          sanitization_level
-        `)
-        .order('created_at', { ascending: false })
-        .limit(recordLimit);
-
-      if (error) {
-        throw error;
-      }
-
-      return {
-        success: true,
-        data,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Failed to retrieve recent LLM calls: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      };
-    }
-  }
-
-  @Get('llm-usage/:runId')
-  @ApiOperation({ summary: 'Get detailed information for a single LLM call' })
-  @ApiResponse({ status: 200, description: 'Successfully retrieved LLM call details' })
-  @ApiParam({ name: 'runId', type: String, description: 'The run_id of the LLM call' })
-  async getLLMCallDetails(@Param('runId') runId: string) {
-    try {
-      const client = this.supabaseService.getServiceClient();
-      const { data, error } = await client
-        .from('llm_usage')
-        .select('*')
-        .eq('run_id', runId)
-        .single();
-
-      if (error) {
-        throw error;
-      }
-
-      return {
-        success: true,
-        data,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        message: `Failed to retrieve LLM call details: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      };
-    }
-  }
-
-  @Get('stats')
-  @ApiOperation({ summary: 'Get comprehensive sanitization service statistics' })
-  @ApiResponse({ status: 200, description: 'Complete service statistics' })
-  async getComprehensiveStats() {
-    try {
-      const client = this.supabaseService.getServiceClient();
-      
-      // Get service stats
-      const stats = await this.dataSanitizationService.getStats();
-      const cacheStats = this.dataSanitizationService.getCacheStats();
-      
-      // Query database for audit log statistics
-      const auditStatsPromises = [
-        // Total operations by type
-        client
-          .from('redaction_audit_log')
-          .select('operation_type')
-          .neq('operation_type', null),
-        
-        // Operations by data type
-        client
-          .from('redaction_audit_log')
-          .select('data_type, operation_type')
-          .neq('data_type', null),
-          
-        // Recent activity (last 24 hours)
-        client
-          .from('redaction_audit_log')
-          .select('*')
-          .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()),
-          
-        // Pattern usage stats
-        client
-          .from('redaction_patterns')
-          .select('name, usage_count, last_used_at, category')
-          .neq('usage_count', null)
-          .order('usage_count', { ascending: false })
-          .limit(10),
-      ];
-
-      const results = await Promise.all(auditStatsPromises);
-      const operationTypes = results[0]?.data;
-      const opError = results[0]?.error;
-      const dataTypes = results[1]?.data;
-      const dtError = results[1]?.error;
-      const recentActivity = results[2]?.data;
-      const raError = results[2]?.error;
-      const patternUsage = results[3]?.data;
-      const puError = results[3]?.error;
-
-      // Calculate database statistics
-      const dbStats = {
-        totalOperations: operationTypes?.length || 0,
-        operationsByType: this.groupBy(operationTypes || [], 'operation_type'),
-        operationsByDataType: this.groupBy(dataTypes || [], 'data_type'),
-        recentActivity: {
-          last24Hours: recentActivity?.length || 0,
-          operations: this.groupBy(recentActivity || [], 'operation_type'),
-        },
-        topPatterns: (patternUsage || []).map((p: any) => ({
-          name: p.name,
-          category: p.category,
-          usageCount: p.usage_count || 0,
-          lastUsed: p.last_used_at,
-        })),
-        errors: [opError, dtError, raError, puError].filter(Boolean).map(e => e?.message),
-      };
-
-      return {
-        success: true,
-        sanitizationStats: stats,
-        cacheStats,
-        databaseStats: dbStats,
-        timestamp: new Date().toISOString(),
-        services: {
-          redaction: 'SecretRedactionService',
-          piiDetection: 'PIIPatternService', 
-          pseudonymization: 'PseudonymizationService',
-          orchestration: 'DataSanitizationService',
-          database: 'SupabaseService',
-        },
-      };
-    } catch (error) {
-      // Fallback to service stats if database fails
-      console.error('Database query failed for stats:', error);
-      const stats = await this.dataSanitizationService.getStats();
-      const cacheStats = this.dataSanitizationService.getCacheStats();
-      
-      return {
-        success: true,
-        sanitizationStats: stats,
-        cacheStats,
-        databaseStats: {
-          error: error instanceof Error ? error.message : 'Database unavailable',
-        },
-        timestamp: new Date().toISOString(),
-        services: {
-          redaction: 'SecretRedactionService',
-          piiDetection: 'PIIPatternService', 
-          pseudonymization: 'PseudonymizationService',
-          orchestration: 'DataSanitizationService',
-          database: 'SupabaseService (Error)',
-        },
-      };
-    }
-  }
-
-  @Get('health')
-  @ApiOperation({ summary: 'Health check for sanitization services' })
-  @ApiResponse({ status: 200, description: 'Service health status' })
-  async healthCheck() {
-    try {
-      // Test basic functionality
-      const testText = 'test@example.com and (555) 123-4567';
-      const testResult = await this.dataSanitizationService.testSanitization(testText);
-      
-      return {
-        success: true,
-        status: 'healthy',
-        timestamp: new Date().toISOString(),
-        testResult: {
-          originalText: testText,
-          sanitizedText: testResult.sanitizedText,
-          processingTime: testResult.result.processingTimeMs,
-        },
-      };
-    } catch (error) {
-      return {
-        success: false,
-        status: 'unhealthy',
-        timestamp: new Date().toISOString(),
-        error: error instanceof Error ? error.message : 'Unknown error',
-      };
-    }
-  }
-
-  // Helper method to group array by property
-  private groupBy(array: any[], key: string): Record<string, number> {
-    return array.reduce((groups, item) => {
-      const value = item[key];
-      if (value) {
-        groups[value] = (groups[value] || 0) + 1;
-      }
-      return groups;
-    }, {} as Record<string, number>);
-  }
-
-  // Helper method to extract data type from pattern or name
-  private extractDataTypeFromPattern(patternRegex: string, name: string): PIIDataType {
-    const lowerName = name.toLowerCase();
-    const lowerPattern = patternRegex.toLowerCase();
-    
-    if (lowerName.includes('email') || lowerPattern.includes('@')) return 'email';
-    if (lowerName.includes('phone') || lowerPattern.includes('phone')) return 'phone';
-    if (lowerName.includes('ssn') || lowerPattern.includes('ssn')) return 'ssn';
-    if (lowerName.includes('credit') || lowerName.includes('card')) return 'credit_card';
-    if (lowerName.includes('name') || lowerName.includes('person')) return 'name';
-    if (lowerName.includes('address') || lowerName.includes('street')) return 'address';
-    if (lowerName.includes('ip') || lowerPattern.includes('\\d+\\.\\d+')) return 'ip_address';
-    if (lowerName.includes('user') || lowerName.includes('username')) return 'username';
-    
-    return 'custom';
-  }
-}
\ No newline at end of file
diff --git a/apps/api/src/llms/secret-redaction.service.ts b/apps/api/src/llms/secret-redaction.service.ts
index 0df2781..40d155d 100644
--- a/apps/api/src/llms/secret-redaction.service.ts
+++ b/apps/api/src/llms/secret-redaction.service.ts
@@ -146,6 +146,18 @@ export class SecretRedactionService {
       replacement: '[EMAIL_REDACTED]',
       description: 'Email addresses',
     },
+    {
+      name: 'ipAddress',
+      pattern: /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/g,
+      replacement: '[IP_ADDRESS_REDACTED]',
+      description: 'IP addresses',
+    },
+    {
+      name: 'internalUrl',
+      pattern: /https?:\/\/(?:localhost|127\.0\.0\.1|10\.\d{1,3}\.\d{1,3}\.\d{1,3}|172\.(?:1[6-9]|2[0-9]|3[01])\.\d{1,3}\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}|[a-zA-Z0-9-]+\.(?:local|internal|corp|test|dev))[^\s]*/g,
+      replacement: '[INTERNAL_URL_REDACTED]',
+      description: 'Internal URLs',
+    },
     {
       name: 'phone',
       pattern: /\b(?:\(\d{3}\)\s?|\d{3}[-.]?)\d{3}[-.]?\d{4}\b/g,
diff --git a/apps/api/src/llms/services/openai-llm.service.ts b/apps/api/src/llms/services/openai-llm.service.ts
index c455107..acd3d56 100644
--- a/apps/api/src/llms/services/openai-llm.service.ts
+++ b/apps/api/src/llms/services/openai-llm.service.ts
@@ -71,29 +71,28 @@ export class OpenAILLMService extends BaseLLMService {
       // Validate configuration
       this.validateConfig(params.config);
       
-      // Handle PII in input - ALWAYS apply dictionary pseudonymization
+      // Handle PII in input - use what's already been processed at LLM Service level
       let piiResult;
       if (params.options?.piiMetadata) {
-        // Use existing PII metadata from centralized routing, but still apply dictionary pseudonymization
-        this.logger.debug(`üîç [PII-METADATA-DEBUG] OpenAILLMService - Using existing PII metadata from routing decision`);
-        
-        // Apply dictionary pseudonymization to the original text
-        const dictionaryResult = await this.dictionaryPseudonymizerService.pseudonymizeText(params.userMessage);
+        // Use existing PII metadata from LLM Service level processing
+        this.logger.debug(`üîç [PII-METADATA-DEBUG] OpenAILLMService - Using PII metadata from LLM Service level`);
         
+        // The text has already been pseudonymized at LLM Service level
         piiResult = {
-          processedText: dictionaryResult.pseudonymizedText,
+          processedText: params.userMessage, // Already processed
           piiMetadata: params.options.piiMetadata,
-          dictionaryMappings: dictionaryResult.mappings, // Store for reversal
+          dictionaryMappings: params.options?.dictionaryMappings || [], // Already applied at LLM Service level
         };
         
-        this.logger.debug(`üéØ [DICTIONARY-DEBUG] Applied dictionary pseudonymization: ${dictionaryResult.mappings.length} replacements`);
+        this.logger.debug(`üéØ [DICTIONARY-DEBUG] Using pre-processed text with ${params.options?.dictionaryMappings?.length || 0} dictionary mappings`);
       } else {
-        // Fallback to local PII processing with dictionary pseudonymization enabled
-        this.logger.debug(`üîç [PII-METADATA-DEBUG] OpenAILLMService - No existing PII metadata, performing local processing`);
-        piiResult = await this.handlePiiInput(params.userMessage, {
-          enablePseudonymization: true,
-          useDictionaryPseudonymizer: true, // Enable dictionary pseudonymization
-        });
+        // Fallback - shouldn't happen if LLM Service is processing correctly
+        this.logger.warn(`‚ö†Ô∏è [PII-METADATA-DEBUG] OpenAILLMService - No PII metadata from LLM Service, skipping PII processing`);
+        piiResult = {
+          processedText: params.userMessage,
+          piiMetadata: null,
+          dictionaryMappings: [],
+        };
       }
       
       // Normalize config for model-specific restrictions
@@ -131,16 +130,12 @@ export class OpenAILLMService extends BaseLLMService {
         throw new Error('No content in OpenAI response');
       }
 
-      // Handle PII in output (pseudonym reversal)
-      // Handle PII output and dictionary reversal
-      let finalContent = await this.handlePiiOutput(choice.message.content, requestId);
+      // Don't reverse pseudonyms here - it will be done at LLM Service level
+      let finalContent = choice.message.content;
       
-      // Apply dictionary reversal if we have mappings
+      // Skip dictionary reversal - handled at LLM Service level
       if ('dictionaryMappings' in piiResult && piiResult.dictionaryMappings && piiResult.dictionaryMappings.length > 0) {
-        this.logger.debug(`üéØ [DICTIONARY-DEBUG] Reversing dictionary pseudonyms: ${piiResult.dictionaryMappings.length} mappings`);
-        const reversalResult = await this.dictionaryPseudonymizerService.reversePseudonyms(finalContent, piiResult.dictionaryMappings);
-        finalContent = reversalResult.originalText;
-        this.logger.debug(`üéØ [DICTIONARY-DEBUG] Dictionary reversal completed: ${reversalResult.reversalCount} reversals`);
+        this.logger.debug(`üéØ [DICTIONARY-DEBUG] Skipping reversal - will be handled at LLM Service level with ${piiResult.dictionaryMappings.length} mappings`);
       }
       
       const endTime = Date.now();
diff --git a/apps/api/src/mcp/services/supabase/supabase-mcp.service.ts b/apps/api/src/mcp/services/supabase/supabase-mcp.service.ts
index aa54015..dfc12fb 100644
--- a/apps/api/src/mcp/services/supabase/supabase-mcp.service.ts
+++ b/apps/api/src/mcp/services/supabase/supabase-mcp.service.ts
@@ -35,9 +35,12 @@ export class SupabaseMCPService implements OnModuleInit, OnModuleDestroy {
 
   constructor(
     private configService: ConfigService,
-    private llmService: LLMService
+    private llmService: LLMService,
   ) {
-    this.mcpServer = new SupabaseMCPServer(configService, llmService);
+    this.mcpServer = new SupabaseMCPServer(
+      configService,
+      llmService,
+    );
   }
 
   /**
@@ -302,4 +305,4 @@ export class SupabaseMCPService implements OnModuleInit, OnModuleDestroy {
       ],
     };
   }
-}
\ No newline at end of file
+}
diff --git a/apps/api/src/mcp/services/supabase/supabase.mcp.ts b/apps/api/src/mcp/services/supabase/supabase.mcp.ts
index 87a559d..f5e2822 100644
--- a/apps/api/src/mcp/services/supabase/supabase.mcp.ts
+++ b/apps/api/src/mcp/services/supabase/supabase.mcp.ts
@@ -554,6 +554,26 @@ export class SupabaseMCPServer implements IMCPServer {
     schemaContext: string, 
     maxRows: number
   ): Promise<string> {
+    // Resolve provider/model for this MCP system call
+    const forceLocal = (process.env.MCP_LOCAL_ONLY || process.env.SOVEREIGN_MODE_ENFORCED) === 'true';
+    let providerName = (process.env.MCP_SQL_PROVIDER || '').toLowerCase();
+    let modelName = process.env.MCP_SQL_MODEL || '';
+
+    if (forceLocal) {
+      providerName = 'ollama';
+      if (!modelName) {
+        try {
+          // TODO: Fix this - getBestModelForTask doesn't exist on llmService
+          const best = null; // await this.llmService.getBestModelForTask('medium', false, 'fast');
+          modelName = best || process.env.LOCAL_LLM_DEFAULT_MODEL || 'gpt-oss:20b';
+        } catch {
+          modelName = process.env.LOCAL_LLM_DEFAULT_MODEL || 'gpt-oss:20b';
+        }
+      }
+    } else {
+      if (!providerName) providerName = 'ollama';
+      if (!modelName) modelName = process.env.LOCAL_LLM_DEFAULT_MODEL || 'gpt-oss:20b';
+    }
     // Use LLM to generate SQL with proper schema context
     const systemPrompt = `You are an expert SQL query generator for a Supabase PostgreSQL database. 
 
@@ -592,7 +612,8 @@ Return ONLY the SQL query, no explanation or formatting.`;
         systemPrompt,
         userPrompt,
         {
-          provider: 'anthropic',
+          providerName: providerName as any,
+          modelName: modelName,
           temperature: 0.1,
           maxTokens: 1000,
           callerType: 'service',
@@ -628,12 +649,16 @@ Return ONLY the SQL query, no explanation or formatting.`;
       console.log('='.repeat(50));
       
       return sql;
-      
+
     } catch (error) {
-      // Fallback to simple query if LLM fails
-      console.warn('LLM SQL generation failed, using fallback:', getErrorMessage(error));
-      const primaryTable = tables[0] || 'users';
-      return `SELECT * FROM ${primaryTable} LIMIT ${maxRows}`;
+      // Do NOT fallback to a generic SELECT *; surface the failure for proper handling
+      const msg = getErrorMessage(error);
+      if (process.env.MCP_SQL_DEBUG === 'true') {
+        console.error('[MCP SQL DEBUG] generation failed:', msg);
+        console.error('[MCP SQL DEBUG] userPrompt:', userPrompt);
+        console.error('[MCP SQL DEBUG] tables:', tables);
+      }
+      throw new Error(`LLM SQL generation failed: ${msg}`);
     }
   }
 
@@ -653,12 +678,29 @@ Please provide:
 
 Format your response as a structured JSON object with these sections.`;
 
+      // Resolve local-only if requested
+      const forceLocal = (process.env.MCP_LOCAL_ONLY || process.env.SOVEREIGN_MODE_ENFORCED) === 'true';
+      let providerName = (provider || process.env.MCP_SQL_PROVIDER || '').toLowerCase();
+      let modelName = model || process.env.MCP_SQL_ANALYSIS_MODEL || process.env.MCP_SQL_MODEL || '';
+      if (forceLocal) {
+        providerName = 'ollama';
+        if (!modelName) {
+          try {
+            // TODO: Fix this - getBestModelForTask doesn't exist on llmService
+          const best = null; // await this.llmService.getBestModelForTask('medium', false, 'fast');
+            modelName = best || process.env.LOCAL_LLM_DEFAULT_MODEL || 'gpt-oss:20b';
+          } catch {
+            modelName = process.env.LOCAL_LLM_DEFAULT_MODEL || 'gpt-oss:20b';
+          }
+        }
+      }
+
       const response = await this.llmService.generateResponse(
         'You are a data analyst providing insights on business data.',
         analysisPrompt,
         {
-          provider: provider as 'anthropic' | 'openai' | 'google' | 'ollama',
-          modelName: model,
+          providerName: (providerName || 'ollama') as any,
+          modelName: modelName || 'gpt-oss:20b',
           temperature: 0.3,
           maxTokens: 1500,
           callerType: 'service',
@@ -708,4 +750,4 @@ Format your response as a structured JSON object with these sections.`;
       },
     };
   }
-}
\ No newline at end of file
+}
diff --git a/apps/api/src/services/pii-simplified.module.ts b/apps/api/src/services/pii-simplified.module.ts
new file mode 100644
index 0000000..19e71e5
--- /dev/null
+++ b/apps/api/src/services/pii-simplified.module.ts
@@ -0,0 +1,34 @@
+/**
+ * Simplified PII Module
+ * 
+ * Provides the clean, simplified PII services
+ * Can be used alongside legacy services during migration
+ */
+
+import { Module } from '@nestjs/common';
+import { SimplifiedPIIService } from './pii-simplified.service';
+import { PIIPatternService } from '../llms/pii-pattern.service';
+import { DictionaryPseudonymizerService } from './dictionary-pseudonymizer.service';
+import { SimplifiedCentralizedRoutingService } from '../llms/centralized-routing-simplified.service';
+import { FeatureFlagService } from '../config/feature-flag.service';
+import { SovereignPolicyService } from '../config/sovereign-policy.service';
+import { SupabaseModule } from '../supabase/supabase.module';
+
+@Module({
+  imports: [
+    SupabaseModule
+  ],
+  providers: [
+    SimplifiedPIIService,
+    PIIPatternService,
+    DictionaryPseudonymizerService,
+    SimplifiedCentralizedRoutingService,
+    FeatureFlagService,
+    SovereignPolicyService,
+  ],
+  exports: [
+    SimplifiedPIIService,
+    SimplifiedCentralizedRoutingService,
+  ],
+})
+export class SimplifiedPIIModule {}
\ No newline at end of file
diff --git a/apps/api/src/services/pii-simplified.service.ts b/apps/api/src/services/pii-simplified.service.ts
new file mode 100644
index 0000000..24a962e
--- /dev/null
+++ b/apps/api/src/services/pii-simplified.service.ts
@@ -0,0 +1,117 @@
+/**
+ * Simplified PII Service
+ * 
+ * Clean, single-responsibility service for PII detection and tracking.
+ * This replaces the complex legacy PII service with a simple, understandable flow.
+ */
+
+import { Injectable, Logger } from '@nestjs/common';
+import { PIIPatternService } from '../llms/pii-pattern.service';
+import { DictionaryPseudonymizerService } from './dictionary-pseudonymizer.service';
+import { SimplifiedPIIMetadata, PIIFlag, PIIPseudonym } from '../common/types/simplified-pii-metadata.types';
+
+@Injectable()
+export class SimplifiedPIIService {
+  private readonly logger = new Logger(SimplifiedPIIService.name);
+
+  constructor(
+    private readonly patternService: PIIPatternService,
+    private readonly dictionaryService: DictionaryPseudonymizerService,
+  ) {}
+
+  /**
+   * Main entry point for PII processing
+   * ONLY detects flags - does NOT apply pseudonymization
+   * LLM service handles all pseudonymization
+   */
+  async processPII(
+    text: string,
+    options: {
+      provider?: string;
+      conversationId?: string;
+      applyDictionary?: boolean;
+    } = {}
+  ): Promise<{
+    processedText: string;
+    metadata: SimplifiedPIIMetadata;
+    dictionaryMappings?: any[]; // For reversal later
+  }> {
+    const startTime = Date.now();
+    
+    // Step 1: Pattern detection (flags ONLY)
+    const detectionResult = await this.patternService.detectPII(text);
+    const flags: PIIFlag[] = detectionResult.matches.map((p: any) => ({
+      value: p.value,
+      dataType: p.dataType,
+      severity: p.severity,
+      confidence: p.confidence,
+      pattern: p.pattern
+    }));
+
+    // Check for showstoppers
+    const hasShowstopper = flags.some(f => f.severity === 'showstopper');
+    if (hasShowstopper) {
+      this.logger.warn(`üõë [SIMPLIFIED-PII] Showstopper PII detected - blocking request`);
+      return {
+        processedText: text,
+        metadata: {
+          flags,
+          pseudonyms: [],
+          flagCount: flags.length,
+          pseudonymCount: 0,
+          blocked: true,
+          blockingReason: 'showstopper-pii'
+        }
+      };
+    }
+
+    const processingTime = Date.now() - startTime;
+    this.logger.debug(`‚úÖ [SIMPLIFIED-PII] Detected ${flags.length} flags in ${processingTime}ms`);
+
+    // Return original text with just the flags
+    // LLM service will handle pseudonymization
+    return {
+      processedText: text,
+      metadata: {
+        flags,
+        pseudonyms: [], // LLM service will populate this
+        flagCount: flags.length,
+        pseudonymCount: 0 // LLM service will update this
+      },
+      dictionaryMappings: [] // LLM service will handle this
+    };
+  }
+
+  /**
+   * Reverse pseudonyms in response text
+   */
+  async reversePseudonyms(
+    text: string,
+    mappings: any[]
+  ): Promise<{
+    originalText: string;
+    reversalCount: number;
+  }> {
+    if (!mappings || mappings.length === 0) {
+      return { originalText: text, reversalCount: 0 };
+    }
+
+    const result = await this.dictionaryService.reversePseudonyms(text, mappings);
+    this.logger.debug(`üîÑ [SIMPLIFIED-PII] Reversed ${result.reversalCount} pseudonyms`);
+    
+    return {
+      originalText: result.originalText,
+      reversalCount: result.reversalCount
+    };
+  }
+
+  /**
+   * Check if text contains showstopper PII
+   * Quick check for early exit
+   */
+  async hasShowstoppers(text: string): Promise<boolean> {
+    const detectionResult = await this.patternService.detectPII(text);
+    return detectionResult.matches.some((p: any) => p.severity === 'showstopper');
+  }
+
+}
\ No newline at end of file
diff --git a/apps/api/src/websocket/task-progress.gateway.ts b/apps/api/src/websocket/task-progress.gateway.ts
index 15c1bb1..0a4c4dd 100644
--- a/apps/api/src/websocket/task-progress.gateway.ts
+++ b/apps/api/src/websocket/task-progress.gateway.ts
@@ -31,6 +31,10 @@ interface AuthenticatedSocket extends Socket {
       // Development ports
       'http://localhost:7101',
       'http://127.0.0.1:7101',
+      'http://localhost:7201',
+      'http://127.0.0.1:7201',
+      'http://localhost:7202',
+      'http://127.0.0.1:7202',
       'http://localhost:9002',
       'http://127.0.0.1:9002',
       'http://localhost:9003',
diff --git a/apps/web/src/components/Admin/LLMUsageDetailModal.vue b/apps/web/src/components/Admin/LLMUsageDetailModal.vue
new file mode 100644
index 0000000..44bec94
--- /dev/null
+++ b/apps/web/src/components/Admin/LLMUsageDetailModal.vue
@@ -0,0 +1,564 @@
+<template>
+  <ion-modal :is-open="isOpen" @did-dismiss="handleDismiss">
+    <ion-header>
+      <ion-toolbar>
+        <ion-title>LLM Usage Details</ion-title>
+        <ion-buttons slot="end">
+          <ion-button @click="handleDismiss">
+            <ion-icon :icon="closeOutline" />
+          </ion-button>
+        </ion-buttons>
+      </ion-toolbar>
+    </ion-header>
+    
+    <ion-content class="ion-padding">
+      <div v-if="loading" class="loading-container">
+        <ion-spinner />
+        <p>Loading details...</p>
+      </div>
+      
+      <div v-else-if="usageDetails">
+        <!-- Basic Information -->
+        <ion-card>
+          <ion-card-header>
+            <ion-card-title>Request Information</ion-card-title>
+          </ion-card-header>
+          <ion-card-content>
+            <ion-grid>
+              <ion-row>
+                <ion-col size="12" size-md="6">
+                  <ion-item lines="none">
+                    <ion-label>
+                      <p>Run ID</p>
+                      <h3>{{ usageDetails.run_id }}</h3>
+                    </ion-label>
+                  </ion-item>
+                </ion-col>
+                <ion-col size="12" size-md="6">
+                  <ion-item lines="none">
+                    <ion-label>
+                      <p>Status</p>
+                      <h3>
+                        <ion-badge :color="getStatusColor(usageDetails.status)">
+                          {{ usageDetails.status }}
+                        </ion-badge>
+                      </h3>
+                    </ion-label>
+                  </ion-item>
+                </ion-col>
+              </ion-row>
+              <ion-row>
+                <ion-col size="12" size-md="6">
+                  <ion-item lines="none">
+                    <ion-label>
+                      <p>Provider</p>
+                      <h3>{{ usageDetails.provider }}</h3>
+                    </ion-label>
+                  </ion-item>
+                </ion-col>
+                <ion-col size="12" size-md="6">
+                  <ion-item lines="none">
+                    <ion-label>
+                      <p>Model</p>
+                      <h3>{{ usageDetails.model }}</h3>
+                    </ion-label>
+                  </ion-item>
+                </ion-col>
+              </ion-row>
+              <ion-row>
+                <ion-col size="12" size-md="6">
+                  <ion-item lines="none">
+                    <ion-label>
+                      <p>Caller Type</p>
+                      <h3>{{ usageDetails.caller_type || 'N/A' }}</h3>
+                    </ion-label>
+                  </ion-item>
+                </ion-col>
+                <ion-col size="12" size-md="6">
+                  <ion-item lines="none">
+                    <ion-label>
+                      <p>Caller Name</p>
+                      <h3>{{ usageDetails.caller_name || 'N/A' }}</h3>
+                    </ion-label>
+                  </ion-item>
+                </ion-col>
+              </ion-row>
+            </ion-grid>
+          </ion-card-content>
+        </ion-card>
+
+        <!-- PII Detection Summary -->
+        <ion-card v-if="hasPIIData">
+          <ion-card-header>
+            <ion-card-title>
+              <ion-icon :icon="shieldCheckmarkOutline" />
+              PII Detection & Sanitization
+            </ion-card-title>
+          </ion-card-header>
+          <ion-card-content>
+            <div class="pii-summary">
+              <ion-grid>
+                <ion-row>
+                  <ion-col size="12" size-md="4">
+                    <div class="pii-stat">
+                      <ion-icon 
+                        :icon="usageDetails.pii_detected ? warningOutline : checkmarkCircleOutline"
+                        :color="usageDetails.pii_detected ? 'warning' : 'success'"
+                        size="large"
+                      />
+                      <div class="pii-stat-content">
+                        <h3>{{ usageDetails.pii_detected ? 'PII Detected' : 'No PII Detected' }}</h3>
+                        <p>{{ usageDetails.sanitization_level || 'None' }} sanitization</p>
+                      </div>
+                    </div>
+                  </ion-col>
+                  
+                  <ion-col size="12" size-md="4">
+                    <div class="pii-stat">
+                      <ion-icon :icon="peopleOutline" color="primary" size="large" />
+                      <div class="pii-stat-content">
+                        <h3>{{ usageDetails.pseudonyms_used || 0 }} Pseudonyms</h3>
+                        <p>{{ getPseudonymTypesText() }}</p>
+                      </div>
+                    </div>
+                  </ion-col>
+                  
+                  <ion-col size="12" size-md="4">
+                    <div class="pii-stat">
+                      <ion-icon :icon="eyeOffOutline" color="danger" size="large" />
+                      <div class="pii-stat-content">
+                        <h3>{{ usageDetails.redactions_applied || 0 }} Redactions</h3>
+                        <p>{{ getRedactionTypesText() }}</p>
+                      </div>
+                    </div>
+                  </ion-col>
+                </ion-row>
+              </ion-grid>
+            </div>
+
+            <!-- PII Types Detected -->
+            <div v-if="usageDetails.pii_types?.length" class="pii-types-section">
+              <h4>PII Types Detected</h4>
+              <div class="pii-badges">
+                <ion-badge 
+                  v-for="piiType in usageDetails.pii_types" 
+                  :key="piiType"
+                  :color="getPIITypeColor(piiType)"
+                  class="pii-badge"
+                >
+                  <ion-icon :icon="getPIITypeIcon(piiType)" />
+                  {{ formatPIIType(piiType) }}
+                </ion-badge>
+              </div>
+            </div>
+
+            <!-- Pseudonym Mappings -->
+            <div v-if="pseudonymMappings?.length" class="mappings-section">
+              <h4>Pseudonym Mappings</h4>
+              <ion-list>
+                <ion-item v-for="mapping in pseudonymMappings" :key="mapping.id" lines="full">
+                  <ion-label>
+                    <p>{{ mapping.data_type }}</p>
+                    <h3>{{ mapping.original_value }}</h3>
+                    <p class="pseudonym-value">‚Üí {{ mapping.pseudonym_value }}</p>
+                  </ion-label>
+                  <ion-badge slot="end" color="medium">
+                    {{ mapping.context }}
+                  </ion-badge>
+                </ion-item>
+              </ion-list>
+            </div>
+
+            <!-- Redaction Patterns -->
+            <div v-if="usageDetails.redaction_types?.length" class="redaction-section">
+              <h4>Redaction Patterns Applied</h4>
+              <div class="redaction-badges">
+                <ion-badge 
+                  v-for="pattern in usageDetails.redaction_types" 
+                  :key="pattern"
+                  color="danger"
+                  class="redaction-badge"
+                >
+                  {{ formatRedactionPattern(pattern) }}
+                </ion-badge>
+              </div>
+            </div>
+          </ion-card-content>
+        </ion-card>
+
+        <!-- Token Usage -->
+        <ion-card>
+          <ion-card-header>
+            <ion-card-title>Token Usage & Cost</ion-card-title>
+          </ion-card-header>
+          <ion-card-content>
+            <ion-grid>
+              <ion-row>
+                <ion-col size="6" size-md="3">
+                  <ion-item lines="none">
+                    <ion-label>
+                      <p>Input Tokens</p>
+                      <h3>{{ usageDetails.input_tokens || 0 }}</h3>
+                    </ion-label>
+                  </ion-item>
+                </ion-col>
+                <ion-col size="6" size-md="3">
+                  <ion-item lines="none">
+                    <ion-label>
+                      <p>Output Tokens</p>
+                      <h3>{{ usageDetails.output_tokens || 0 }}</h3>
+                    </ion-label>
+                  </ion-item>
+                </ion-col>
+                <ion-col size="6" size-md="3">
+                  <ion-item lines="none">
+                    <ion-label>
+                      <p>Total Cost</p>
+                      <h3>${{ ((usageDetails.input_cost || 0) + (usageDetails.output_cost || 0)).toFixed(6) }}</h3>
+                    </ion-label>
+                  </ion-item>
+                </ion-col>
+                <ion-col size="6" size-md="3">
+                  <ion-item lines="none">
+                    <ion-label>
+                      <p>Duration</p>
+                      <h3>{{ usageDetails.duration_ms || 0 }}ms</h3>
+                    </ion-label>
+                  </ion-item>
+                </ion-col>
+              </ion-row>
+            </ion-grid>
+          </ion-card-content>
+        </ion-card>
+
+        <!-- Timing Information -->
+        <ion-card>
+          <ion-card-header>
+            <ion-card-title>Timing</ion-card-title>
+          </ion-card-header>
+          <ion-card-content>
+            <ion-item lines="none">
+              <ion-label>
+                <p>Started At</p>
+                <h3>{{ formatDateTime(usageDetails.started_at) }}</h3>
+              </ion-label>
+            </ion-item>
+            <ion-item lines="none">
+              <ion-label>
+                <p>Completed At</p>
+                <h3>{{ formatDateTime(usageDetails.completed_at) }}</h3>
+              </ion-label>
+            </ion-item>
+            <ion-item lines="none" v-if="usageDetails.sanitization_time_ms">
+              <ion-label>
+                <p>Sanitization Time</p>
+                <h3>{{ usageDetails.sanitization_time_ms }}ms</h3>
+              </ion-label>
+            </ion-item>
+          </ion-card-content>
+        </ion-card>
+
+        <!-- Error Information -->
+        <ion-card v-if="usageDetails.error_message" color="danger">
+          <ion-card-header>
+            <ion-card-title>Error</ion-card-title>
+          </ion-card-header>
+          <ion-card-content>
+            <pre>{{ usageDetails.error_message }}</pre>
+          </ion-card-content>
+        </ion-card>
+      </div>
+      
+      <div v-else class="no-data">
+        <ion-icon :icon="alertCircleOutline" size="large" />
+        <p>No usage details found</p>
+      </div>
+    </ion-content>
+  </ion-modal>
+</template>
+
+<script setup lang="ts">
+import { ref, computed, watch } from 'vue';
+import {
+  IonModal,
+  IonHeader,
+  IonToolbar,
+  IonTitle,
+  IonButtons,
+  IonButton,
+  IonIcon,
+  IonContent,
+  IonCard,
+  IonCardHeader,
+  IonCardTitle,
+  IonCardContent,
+  IonGrid,
+  IonRow,
+  IonCol,
+  IonItem,
+  IonLabel,
+  IonBadge,
+  IonSpinner,
+  IonList,
+} from '@ionic/vue';
+import {
+  closeOutline,
+  shieldCheckmarkOutline,
+  warningOutline,
+  checkmarkCircleOutline,
+  peopleOutline,
+  eyeOffOutline,
+  alertCircleOutline,
+  personOutline,
+  businessOutline,
+  locationOutline,
+  mailOutline,
+  callOutline,
+  cardOutline,
+  keyOutline,
+  lockClosedOutline,
+  globeOutline,
+} from 'ionicons/icons';
+import { llmMonitoringStore } from '@/stores/llmMonitoringStore';
+import { pseudonymMappingsStore } from '@/stores/pseudonymMappingsStore';
+
+interface Props {
+  isOpen: boolean;
+  runId?: string;
+}
+
+const props = defineProps<Props>();
+const emit = defineEmits(['update:isOpen', 'dismiss']);
+
+const loading = ref(false);
+const usageDetails = ref<any>(null);
+const pseudonymMappings = ref<any[]>([]);
+
+const hasPIIData = computed(() => {
+  return usageDetails.value?.pii_detected || 
+         usageDetails.value?.pseudonyms_used > 0 || 
+         usageDetails.value?.redactions_applied > 0;
+});
+
+watch(() => props.runId, async (newRunId) => {
+  if (newRunId && props.isOpen) {
+    await loadUsageDetails(newRunId);
+  }
+});
+
+watch(() => props.isOpen, async (isOpen) => {
+  if (isOpen && props.runId) {
+    await loadUsageDetails(props.runId);
+  }
+});
+
+async function loadUsageDetails(runId: string) {
+  loading.value = true;
+  try {
+    // Load usage details
+    const details = await llmMonitoringStore.getLLMUsageDetails(runId);
+    usageDetails.value = details;
+    
+    // Load pseudonym mappings if there are pseudonyms
+    if (details?.pseudonyms_used > 0) {
+      const mappings = await pseudonymMappingsStore.getMappingsByRunId(runId);
+      pseudonymMappings.value = mappings;
+    }
+  } catch (error) {
+    console.error('Error loading usage details:', error);
+  } finally {
+    loading.value = false;
+  }
+}
+
+function handleDismiss() {
+  emit('update:isOpen', false);
+  emit('dismiss');
+}
+
+function getStatusColor(status: string): string {
+  switch (status) {
+    case 'completed': return 'success';
+    case 'failed': return 'danger';
+    case 'pending': return 'warning';
+    default: return 'medium';
+  }
+}
+
+function getPIITypeColor(type: string): string {
+  switch (type) {
+    case 'email': return 'primary';
+    case 'phone': return 'secondary';
+    case 'ssn': return 'danger';
+    case 'credit_card': return 'warning';
+    case 'ip_address': return 'tertiary';
+    case 'url': return 'medium';
+    default: return 'light';
+  }
+}
+
+function getPIITypeIcon(type: string) {
+  switch (type) {
+    case 'email': return mailOutline;
+    case 'phone': return callOutline;
+    case 'ssn': return cardOutline;
+    case 'credit_card': return cardOutline;
+    case 'api_key': return keyOutline;
+    case 'password': return lockClosedOutline;
+    case 'ip_address': return globeOutline;
+    case 'url': return globeOutline;
+    case 'person_name': return personOutline;
+    case 'organization': return businessOutline;
+    case 'location': return locationOutline;
+    default: return shieldCheckmarkOutline;
+  }
+}
+
+function formatPIIType(type: string): string {
+  return type.split('_').map(word => 
+    word.charAt(0).toUpperCase() + word.slice(1)
+  ).join(' ');
+}
+
+function formatRedactionPattern(pattern: string): string {
+  return pattern.split(/(?=[A-Z])/).join(' ').toLowerCase()
+    .split(' ').map(word => 
+      word.charAt(0).toUpperCase() + word.slice(1)
+    ).join(' ');
+}
+
+function getPseudonymTypesText(): string {
+  if (!usageDetails.value?.pseudonym_types?.length) {
+    return 'No types specified';
+  }
+  return usageDetails.value.pseudonym_types.slice(0, 3).join(', ') + 
+    (usageDetails.value.pseudonym_types.length > 3 ? '...' : '');
+}
+
+function getRedactionTypesText(): string {
+  if (!usageDetails.value?.redaction_types?.length) {
+    return 'No patterns specified';
+  }
+  return usageDetails.value.redaction_types.slice(0, 3).join(', ') + 
+    (usageDetails.value.redaction_types.length > 3 ? '...' : '');
+}
+
+function formatDateTime(dateStr: string): string {
+  if (!dateStr) return 'N/A';
+  const date = new Date(dateStr);
+  return date.toLocaleString();
+}
+</script>
+
+<style scoped>
+.loading-container {
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  justify-content: center;
+  min-height: 200px;
+  gap: 1rem;
+}
+
+.no-data {
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  justify-content: center;
+  min-height: 200px;
+  gap: 1rem;
+  color: var(--ion-color-medium);
+}
+
+.pii-summary {
+  margin: 1rem 0;
+}
+
+.pii-stat {
+  display: flex;
+  align-items: center;
+  gap: 1rem;
+  padding: 1rem;
+  background: var(--ion-color-light);
+  border-radius: 8px;
+  margin-bottom: 1rem;
+}
+
+.pii-stat-content h3 {
+  margin: 0;
+  font-size: 1.1rem;
+  font-weight: 600;
+}
+
+.pii-stat-content p {
+  margin: 0.25rem 0 0 0;
+  font-size: 0.9rem;
+  color: var(--ion-color-medium);
+}
+
+.pii-types-section,
+.mappings-section,
+.redaction-section {
+  margin-top: 1.5rem;
+  padding-top: 1rem;
+  border-top: 1px solid var(--ion-color-light);
+}
+
+.pii-types-section h4,
+.mappings-section h4,
+.redaction-section h4 {
+  margin: 0 0 1rem 0;
+  font-size: 1rem;
+  font-weight: 600;
+  color: var(--ion-color-dark);
+}
+
+.pii-badges,
+.redaction-badges {
+  display: flex;
+  flex-wrap: wrap;
+  gap: 0.5rem;
+}
+
+.pii-badge,
+.redaction-badge {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.25rem;
+  padding: 0.25rem 0.75rem;
+  font-size: 0.875rem;
+}
+
+.pii-badge ion-icon,
+.redaction-badge ion-icon {
+  font-size: 1rem;
+}
+
+.pseudonym-value {
+  color: var(--ion-color-primary);
+  font-family: monospace;
+  margin-top: 0.25rem;
+}
+
+ion-card {
+  margin-bottom: 1rem;
+}
+
+ion-item ion-label p {
+  font-size: 0.875rem;
+  color: var(--ion-color-medium);
+  margin-bottom: 0.25rem;
+}
+
+ion-item ion-label h3 {
+  font-size: 1rem;
+  font-weight: 500;
+}
+
+pre {
+  white-space: pre-wrap;
+  word-wrap: break-word;
+  font-size: 0.875rem;
+  margin: 0;
+}
+</style>
\ No newline at end of file
diff --git a/apps/web/src/components/AgentTaskItem.vue b/apps/web/src/components/AgentTaskItem.vue
index 4f053fb..400622c 100644
--- a/apps/web/src/components/AgentTaskItem.vue
+++ b/apps/web/src/components/AgentTaskItem.vue
@@ -511,17 +511,67 @@ const currentTrustScore = computed(() => {
 
 // Sanitization status - read from message metadata (better architecture)
 const pseudonymizedItemsCount = computed(() => {
-  const piiMetadata = props.message.metadata?.piiMetadata;
-  return piiMetadata?.pseudonymInstructions?.targetMatches?.length || 0;
+  // First check for simplified PII metadata
+  const simplifiedPii = props.message.metadata?.simplifiedPii;
+  if (simplifiedPii) {
+    console.log('üè∑Ô∏è [BADGE-CHECK] Using simplified PII - pseudonym count:', simplifiedPii.pseudonymCount);
+    return simplifiedPii.pseudonymCount || 0;
+  }
+  
+  // Fall back to legacy PII metadata
+  const piiMetadata = props.message.metadata?.piiMetadata || props.message.piiMetadata;
+  
+  // Debug logging for PII badges (only when no simplified metadata)
+  if (props.message.role === 'assistant' && !simplifiedPii) {
+    console.log('üè∑Ô∏è [BADGE-CHECK] Falling back to legacy PII metadata');
+    if (piiMetadata) {
+      console.log('üè∑Ô∏è [BADGE-CHECK] Legacy PII structure found');
+    }
+  }
+  
+  // Check the correct structure based on PIIProcessingMetadata type
+  if (piiMetadata?.pseudonymResults?.processedMatches?.length) {
+    return piiMetadata.pseudonymResults.processedMatches.length;
+  }
+  if (piiMetadata?.pseudonymResults?.mappingsCount) {
+    return piiMetadata.pseudonymResults.mappingsCount;
+  }
+  if (piiMetadata?.pseudonymInstructions?.targetMatches?.length) {
+    return piiMetadata.pseudonymInstructions.targetMatches.length;
+  }
+  return 0;
 });
 
 const flaggedItemsCount = computed(() => {
-  const piiMetadata = props.message.metadata?.piiMetadata;
-  return piiMetadata?.detectionResults?.flaggedMatches?.length || 0;
+  // First check for simplified PII metadata
+  const simplifiedPii = props.message.metadata?.simplifiedPii;
+  if (simplifiedPii) {
+    console.log('üö© [BADGE-CHECK] Using simplified PII - flag count:', simplifiedPii.flagCount);
+    return simplifiedPii.flagCount || 0;
+  }
+  
+  // Fall back to legacy PII metadata
+  const piiMetadata = props.message.metadata?.piiMetadata || props.message.piiMetadata;
+  
+  // Use the correct structure: detectionResults.flaggedMatches
+  if (piiMetadata?.detectionResults?.flaggedMatches?.length) {
+    const count = piiMetadata.detectionResults.flaggedMatches.length;
+    console.log('üö© [BADGE-CHECK] Falling back to legacy - flaggedMatches:', count);
+    return count;
+  }
+  
+  // Alternative: use totalMatches if available
+  if (piiMetadata?.detectionResults?.totalMatches) {
+    const count = piiMetadata.detectionResults.totalMatches;
+    console.log('üö© [BADGE-CHECK] Falling back to legacy - totalMatches:', count);
+    return count;
+  }
+  
+  return 0;
 });
 
 const sanitizationStatus = computed(() => {
-  const piiMetadata = props.message.metadata?.piiMetadata;
+  const piiMetadata = props.message.metadata?.piiMetadata || props.message.piiMetadata;
   if (piiMetadata?.showstopperDetected) {
     return 'blocked';
   }
diff --git a/apps/web/src/components/admin/LlmUsageTable.vue b/apps/web/src/components/admin/LlmUsageTable.vue
index 6d4419a..778866e 100644
--- a/apps/web/src/components/admin/LlmUsageTable.vue
+++ b/apps/web/src/components/admin/LlmUsageTable.vue
@@ -204,6 +204,7 @@
                   <th>Caller</th>
                   <th>Model</th>
                   <th>Status</th>
+                  <th>PII</th>
                   <th>Duration</th>
                   <th>Tokens</th>
                   <th>Cost</th>
@@ -255,6 +256,27 @@
                     </ion-chip>
                   </td>
                   
+                  <td>
+                    <div class="pii-indicators">
+                      <ion-badge 
+                        v-if="record.pii_detected"
+                        color="warning"
+                        @click="viewDetails(record)"
+                        class="clickable"
+                      >
+                        <ion-icon :icon="warningOutline" />
+                        {{ record.pseudonyms_used || 0 }}P / {{ record.redactions_applied || 0 }}R
+                      </ion-badge>
+                      <ion-badge 
+                        v-else
+                        color="success"
+                      >
+                        <ion-icon :icon="checkmarkCircleOutline" />
+                        Clean
+                      </ion-badge>
+                    </div>
+                  </td>
+                  
                   <td>{{ llmUsageService.formatDuration(record.duration_ms) }}</td>
                   
                   <td>
@@ -294,8 +316,16 @@
       </ion-card>
     </div>
 
-    <!-- Details Modal -->
-    <ion-modal :is-open="showDetailsModal" @did-dismiss="closeDetails">
+    <!-- PII Details Modal -->
+    <LLMUsageDetailModal
+      :is-open="showDetailsModal"
+      :run-id="selectedRecord?.run_id"
+      @update:is-open="showDetailsModal = $event"
+      @dismiss="closeDetails"
+    />
+    
+    <!-- Old Details Modal (Backup) -->
+    <ion-modal v-if="false" :is-open="showDetailsModal" @did-dismiss="closeDetails">
       <ion-header>
         <ion-toolbar>
           <ion-title>Usage Record Details</ion-title>
@@ -374,7 +404,8 @@ import {
   IonButtons,
   IonContent,
   IonList,
-  IonLabel
+  IonLabel,
+  IonBadge
 } from '@ionic/vue';
 import {
   filterOutline,
@@ -388,12 +419,15 @@ import {
   personOutline,
   settingsOutline,
   serverOutline,
-  helpOutline
+  helpOutline,
+  warningOutline,
+  checkmarkCircleOutline
 } from 'ionicons/icons';
 
 import { useLlmUsageStore } from '@/stores/llmUsageStore';
 import { llmUsageService, type LlmUsageRecord } from '@/services/llmUsageService';
 import { storeToRefs } from 'pinia';
+import LLMUsageDetailModal from './LLMUsageDetailModal.vue';
 
 const store = useLlmUsageStore();
 
@@ -604,6 +638,32 @@ onUnmounted(() => {
   font-size: 0.875rem;
 }
 
+.pii-indicators {
+  display: flex;
+  justify-content: center;
+  align-items: center;
+}
+
+.pii-indicators ion-badge {
+  display: inline-flex;
+  align-items: center;
+  gap: 4px;
+  font-size: 0.75rem;
+  padding: 2px 8px;
+}
+
+.pii-indicators ion-badge.clickable {
+  cursor: pointer;
+}
+
+.pii-indicators ion-badge.clickable:hover {
+  opacity: 0.8;
+}
+
+.pii-indicators ion-badge ion-icon {
+  font-size: 0.875rem;
+}
+
 .empty-state {
   text-align: center;
   padding: 48px 16px;
diff --git a/apps/web/src/services/llmMonitoringService.ts b/apps/web/src/services/llmMonitoringService.ts
index 3f8d48d..14405a7 100644
--- a/apps/web/src/services/llmMonitoringService.ts
+++ b/apps/web/src/services/llmMonitoringService.ts
@@ -570,6 +570,19 @@ class LLMMonitoringService {
         return this.getDateRange('last30days');
     }
   }
+
+  /**
+   * Get detailed LLM usage information for a specific run
+   */
+  async getUsageDetails(runId: string): Promise<any> {
+    try {
+      const response = await apiService.get(`/api/llm-usage/details/${runId}`);
+      return response;
+    } catch (error) {
+      console.error('Error fetching usage details:', error);
+      throw error;
+    }
+  }
 }
 
 // Export singleton instance
diff --git a/apps/web/src/services/pseudonymService.ts b/apps/web/src/services/pseudonymService.ts
index 8fa5088..b113409 100644
--- a/apps/web/src/services/pseudonymService.ts
+++ b/apps/web/src/services/pseudonymService.ts
@@ -411,6 +411,23 @@ class PseudonymService {
       errors
     };
   }
+
+  /**
+   * Get pseudonym mappings for a specific run ID
+   */
+  async getMappingsByRunId(runId: string): Promise<PseudonymMapping[]> {
+    try {
+      const response = await apiService.get(`${this.basePath}/pseudonym/mappings/run/${runId}`);
+      return response.mappings || [];
+    } catch (error) {
+      console.error(`Error fetching mappings for run ${runId}:`, error);
+      // Return empty array if not found
+      if ((error as any)?.response?.status === 404) {
+        return [];
+      }
+      throw error;
+    }
+  }
 }
 
 // Export singleton instance
diff --git a/apps/web/src/stores/agentChatStore/store.ts b/apps/web/src/stores/agentChatStore/store.ts
index 17e45d3..1af91a5 100644
--- a/apps/web/src/stores/agentChatStore/store.ts
+++ b/apps/web/src/stores/agentChatStore/store.ts
@@ -637,6 +637,23 @@ export const useAgentChatStore = defineStore('agentChat', {
         console.log('üîç [FRONTEND-DEBUG] Has sanitizationMetadata:', !!parsedResponse?.metadata?.sanitizationMetadata);
         console.log('üîç [FRONTEND-DEBUG] Full sanitizationMetadata:', parsedResponse?.metadata?.sanitizationMetadata);
 
+        // Import the converter at the top of the function if needed
+        const { convertToSimplifiedPII } = await import('@/utils/pii-converter');
+        
+        // Extract PII metadata from the correct location
+        const legacyPiiMetadata = parsedResponse?.metadata?.piiMetadata || 
+                                  parsedResponse?.piiMetadata;
+        
+        // Convert to simplified format
+        const simplifiedPiiMetadata = convertToSimplifiedPII(legacyPiiMetadata);
+        
+        // Log the conversion
+        if (simplifiedPiiMetadata) {
+          console.log('‚úÖ [SIMPLIFIED-PII] Created simplified metadata:', simplifiedPiiMetadata);
+          console.log('‚úÖ [SIMPLIFIED-PII] Flag count:', simplifiedPiiMetadata.flagCount);
+          console.log('‚úÖ [SIMPLIFIED-PII] Pseudonym count:', simplifiedPiiMetadata.pseudonymCount);
+        }
+        
         // Merge agent result metadata with task LLM metadata
         const mergedMetadata = {
           ...parsedResponse?.metadata,
@@ -644,9 +661,50 @@ export const useAgentChatStore = defineStore('agentChat', {
           ...(completedTask.llmMetadata && {
             llmMetadata: completedTask.llmMetadata,
           }),
+          // Include legacy PII metadata for backward compatibility
+          ...(legacyPiiMetadata && {
+            piiMetadata: legacyPiiMetadata,
+          }),
+          // Include new simplified PII metadata
+          ...(simplifiedPiiMetadata && {
+            simplifiedPii: simplifiedPiiMetadata,
+          }),
+          // Also check for sanitizationMetadata at the top level
+          ...(parsedResponse?.sanitizationMetadata && {
+            sanitizationMetadata: parsedResponse.sanitizationMetadata,
+          }),
         };
 
         console.log('üîç [FRONTEND-DEBUG] Merged metadata for message:', mergedMetadata);
+        console.log('üîç [FRONTEND-DEBUG] PII metadata extracted:', parsedResponse?.piiMetadata);
+        
+        // Add detailed PII debugging
+        console.log('üéØ [PII-CHECK] Full parsedResponse:', parsedResponse);
+        console.log('üéØ [PII-CHECK] completedTask.response type:', typeof completedTask.response);
+        console.log('üéØ [PII-CHECK] completedTask.llmMetadata:', completedTask.llmMetadata);
+        
+        // Check multiple locations for PII metadata
+        const piiLocations = {
+          'parsedResponse.piiMetadata': parsedResponse?.piiMetadata,
+          'parsedResponse.metadata.piiMetadata': parsedResponse?.metadata?.piiMetadata,
+          'completedTask.llmMetadata.piiMetadata': completedTask.llmMetadata?.piiMetadata,
+          'completedTask.piiMetadata': completedTask.piiMetadata,
+        };
+        
+        console.log('üîç [PII-SEARCH] Checking all possible locations:', piiLocations);
+        
+        // Find where PII metadata actually is
+        const actualPiiMetadata = parsedResponse?.metadata?.piiMetadata || 
+                                  parsedResponse?.piiMetadata || 
+                                  completedTask.piiMetadata;
+        
+        if (actualPiiMetadata) {
+          console.log('‚úÖ [PII-FOUND] PII metadata detected!', actualPiiMetadata);
+          console.log('‚úÖ [PII-FOUND] Flaggings:', actualPiiMetadata.flaggings);
+          console.log('‚úÖ [PII-FOUND] Pseudonyms Applied:', actualPiiMetadata.pseudonymsApplied);
+        } else {
+          console.log('‚ùå [PII-MISSING] No PII metadata found in any location');
+        }
 
         existingMessage.metadata = {
           ...existingMessage.metadata,
diff --git a/apps/web/src/stores/llmMonitoringStore.ts b/apps/web/src/stores/llmMonitoringStore.ts
index d3fca6e..da2670e 100644
--- a/apps/web/src/stores/llmMonitoringStore.ts
+++ b/apps/web/src/stores/llmMonitoringStore.ts
@@ -580,6 +580,19 @@ export const useLLMMonitoringStore = defineStore('llmMonitoring', () => {
     ]);
   }
 
+  /**
+   * Get detailed LLM usage information for a specific run
+   */
+  async function getLLMUsageDetails(runId: string) {
+    try {
+      const response = await llmMonitoringService.getUsageDetails(runId);
+      return response;
+    } catch (err) {
+      error.value = `Failed to load usage details: ${err}`;
+      throw err;
+    }
+  }
+
   // =====================================
   // RETURN STORE INTERFACE
   // =====================================
@@ -649,6 +662,7 @@ export const useLLMMonitoringStore = defineStore('llmMonitoring', () => {
     setUsageRecordsLimit,
     clearError,
     getDateRange,
-    refreshAllData
+    refreshAllData,
+    getLLMUsageDetails
   };
 });
diff --git a/apps/web/src/stores/pseudonymMappingsStore.ts b/apps/web/src/stores/pseudonymMappingsStore.ts
index c6ffc6d..251e04a 100644
--- a/apps/web/src/stores/pseudonymMappingsStore.ts
+++ b/apps/web/src/stores/pseudonymMappingsStore.ts
@@ -270,6 +270,25 @@ export const usePseudonymMappingsStore = defineStore('pseudonymMappings', () =>
     ]);
   };
 
+  /**
+   * Fetch pseudonym mappings for a specific run ID
+   */
+  const getMappingsByRunId = async (runId: string): Promise<PseudonymMapping[]> => {
+    try {
+      isLoading.value = true;
+      error.value = null;
+      
+      const response = await pseudonymService.getMappingsByRunId(runId);
+      return response || [];
+    } catch (err) {
+      error.value = err instanceof Error ? err.message : 'Failed to fetch mappings by run ID';
+      console.error('Error fetching mappings by run ID:', err);
+      return [];
+    } finally {
+      isLoading.value = false;
+    }
+  };
+
 
   return {
     // State
@@ -302,6 +321,7 @@ export const usePseudonymMappingsStore = defineStore('pseudonymMappings', () =>
     updateFilters,
     updateSortOptions,
     clearFilters,
-    refreshData
+    refreshData,
+    getMappingsByRunId
   };
 });
diff --git a/apps/web/src/utils/pii-converter.ts b/apps/web/src/utils/pii-converter.ts
new file mode 100644
index 0000000..85394e8
--- /dev/null
+++ b/apps/web/src/utils/pii-converter.ts
@@ -0,0 +1,87 @@
+/**
+ * Frontend converter for PII metadata
+ * Transforms legacy complex structure to simplified format
+ */
+
+export interface SimplifiedPIIMetadata {
+  flags: Array<{
+    value: string;
+    dataType: string;
+    severity: 'info' | 'warning' | 'showstopper';
+    confidence: number;
+    pattern: string;
+  }>;
+  pseudonyms: Array<{
+    original: string;
+    pseudonym: string;
+    dataType: string;
+  }>;
+  flagCount: number;
+  pseudonymCount: number;
+  blocked?: boolean;
+  blockingReason?: string;
+}
+
+/**
+ * Converts legacy PII metadata to simplified structure
+ */
+export function convertToSimplifiedPII(legacyMetadata: any): SimplifiedPIIMetadata | null {
+  if (!legacyMetadata) {
+    return null;
+  }
+
+  const simplified: SimplifiedPIIMetadata = {
+    flags: [],
+    pseudonyms: [],
+    flagCount: 0,
+    pseudonymCount: 0
+  };
+
+  // Extract flags from detectionResults.flaggedMatches
+  if (legacyMetadata.detectionResults?.flaggedMatches) {
+    simplified.flags = legacyMetadata.detectionResults.flaggedMatches.map((match: any) => ({
+      value: match.value,
+      dataType: match.dataType,
+      severity: match.severity,
+      confidence: match.confidence,
+      pattern: match.pattern
+    }));
+    simplified.flagCount = simplified.flags.length;
+  }
+
+  // Extract pseudonyms from pseudonymResults.processedMatches
+  if (legacyMetadata.pseudonymResults?.processedMatches) {
+    simplified.pseudonyms = legacyMetadata.pseudonymResults.processedMatches
+      .filter((match: any) => match.pseudonym)
+      .map((match: any) => ({
+        original: match.value,
+        pseudonym: match.pseudonym,
+        dataType: match.dataType
+      }));
+    simplified.pseudonymCount = simplified.pseudonyms.length;
+  }
+
+  // Check if blocked
+  if (legacyMetadata.showstopperDetected || legacyMetadata.policyDecision?.blocked) {
+    simplified.blocked = true;
+    simplified.blockingReason = legacyMetadata.policyDecision?.blockingReason || 'showstopper-pii';
+  }
+
+  return simplified;
+}
+
+/**
+ * Helper to get badge counts from simplified metadata
+ */
+export function getPIIBadgeCounts(metadata: SimplifiedPIIMetadata | null): {
+  flagCount: number;
+  pseudonymCount: number;
+} {
+  if (!metadata) {
+    return { flagCount: 0, pseudonymCount: 0 };
+  }
+  return {
+    flagCount: metadata.flagCount,
+    pseudonymCount: metadata.pseudonymCount
+  };
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index 2a570c5..a94e028 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -11,6 +11,7 @@
         "apps/web"
       ],
       "dependencies": {
+        "@openai/codex": "^0.34.0",
         "@supabase/supabase-js": "^2.57.2",
         "axios": "^1.10.0",
         "boxen": "^8.0.1",
@@ -7276,6 +7277,21 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@openai/codex": {
+      "version": "0.34.0",
+      "resolved": "https://registry.npmjs.org/@openai/codex/-/codex-0.34.0.tgz",
+      "integrity": "sha512-lLEC2HYccGgazkd1aKcAH5FqpNvhYRV905Fke9HQdEUJrhB85a97x2zddXIYblAHK0YkL+pQsNRm95bKytu5Tg==",
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@vscode/ripgrep": "^1.15.14"
+      },
+      "bin": {
+        "codex": "bin/codex.js"
+      },
+      "engines": {
+        "node": ">=20"
+      }
+    },
     "node_modules/@paralleldrive/cuid2": {
       "version": "2.2.2",
       "resolved": "https://registry.npmjs.org/@paralleldrive/cuid2/-/cuid2-2.2.2.tgz",
@@ -9523,6 +9539,50 @@
         "vscode-uri": "^3.0.8"
       }
     },
+    "node_modules/@vscode/ripgrep": {
+      "version": "1.15.14",
+      "resolved": "https://registry.npmjs.org/@vscode/ripgrep/-/ripgrep-1.15.14.tgz",
+      "integrity": "sha512-/G1UJPYlm+trBWQ6cMO3sv6b8D1+G16WaJH1/DSqw32JOVlzgZbLkDxRyzIpTpv30AcYGMkCf5tUqGlW6HbDWw==",
+      "hasInstallScript": true,
+      "license": "MIT",
+      "dependencies": {
+        "https-proxy-agent": "^7.0.2",
+        "proxy-from-env": "^1.1.0",
+        "yauzl": "^2.9.2"
+      }
+    },
+    "node_modules/@vscode/ripgrep/node_modules/agent-base": {
+      "version": "7.1.4",
+      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-7.1.4.tgz",
+      "integrity": "sha512-MnA+YT8fwfJPgBx3m60MNqakm30XOkyIoH1y6huTQvC0PwZG7ki8NacLBcrPbNoo8vEZy7Jpuk7+jMO+CUovTQ==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 14"
+      }
+    },
+    "node_modules/@vscode/ripgrep/node_modules/https-proxy-agent": {
+      "version": "7.0.6",
+      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-7.0.6.tgz",
+      "integrity": "sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==",
+      "license": "MIT",
+      "dependencies": {
+        "agent-base": "^7.1.2",
+        "debug": "4"
+      },
+      "engines": {
+        "node": ">= 14"
+      }
+    },
+    "node_modules/@vscode/ripgrep/node_modules/yauzl": {
+      "version": "2.10.0",
+      "resolved": "https://registry.npmjs.org/yauzl/-/yauzl-2.10.0.tgz",
+      "integrity": "sha512-p4a9I6X6nu6IhoGmBqAcbJy1mlC4j27vEPZX9F4L4/vZT3Lyq1VkFHw/V/PUcB9Buo+DG3iHkT0x3Qya58zc3g==",
+      "license": "MIT",
+      "dependencies": {
+        "buffer-crc32": "~0.2.3",
+        "fd-slicer": "~1.1.0"
+      }
+    },
     "node_modules/@vue/compiler-core": {
       "version": "3.5.20",
       "resolved": "https://registry.npmjs.org/@vue/compiler-core/-/compiler-core-3.5.20.tgz",
@@ -11509,7 +11569,6 @@
       "version": "0.2.13",
       "resolved": "https://registry.npmjs.org/buffer-crc32/-/buffer-crc32-0.2.13.tgz",
       "integrity": "sha512-VO9Ht/+p3SN7SKWqcrgEzjGbRSJYTx+Q1pTQC0wrWqHx0vpJraQ6GtHx8tvcg1rlK1byhU5gccxgOgj7B0TDkQ==",
-      "dev": true,
       "license": "MIT",
       "engines": {
         "node": "*"
@@ -14678,7 +14737,6 @@
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/fd-slicer/-/fd-slicer-1.1.0.tgz",
       "integrity": "sha512-cE1qsB/VwyQozZ+q1dGxR8LBYNZeofhEdUNGSMbQD3Gw2lAzX9Zb3uIU6Ebc/Fmyjo9AWWfnn0AUCHqtevs/8g==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "pend": "~1.2.0"
@@ -19834,7 +19892,6 @@
       "version": "1.2.0",
       "resolved": "https://registry.npmjs.org/pend/-/pend-1.2.0.tgz",
       "integrity": "sha512-F3asv42UuXchdzt+xXqfW1OGlVBe+mxa2mqI0pg5yAHZPvFmY3Y6drSf/GQ1A86WgWEN9Kzh/WrgKa6iGcHXLg==",
-      "dev": true,
       "license": "MIT"
     },
     "node_modules/perfect-debounce": {
diff --git a/package.json b/package.json
index 71e91a4..c2d1e35 100644
--- a/package.json
+++ b/package.json
@@ -60,6 +60,7 @@
     "apps/web"
   ],
   "dependencies": {
+    "@openai/codex": "^0.34.0",
     "@supabase/supabase-js": "^2.57.2",
     "axios": "^1.10.0",
     "boxen": "^8.0.1",
diff --git a/scripts/setup-pii-dictionary.sh b/scripts/setup-pii-dictionary.sh
new file mode 100755
index 0000000..4e85c56
--- /dev/null
+++ b/scripts/setup-pii-dictionary.sh
@@ -0,0 +1,144 @@
+#!/bin/bash
+
+echo "üîß Setting up PII Dictionary Entries..."
+echo "======================================="
+
+# Load environment variables
+source .env
+
+# Connect to database and insert dictionary entries
+echo "üìù Adding pseudonym dictionary entries to database..."
+
+PGPASSWORD=postgres psql -h 127.0.0.1 -p 7012 -U postgres -d postgres << EOF
+
+-- First, check if entries already exist
+SELECT COUNT(*) as existing_count FROM pseudonym_dictionaries 
+WHERE original_value IN ('Matthew Weber', 'Matt Weber', 'GolferGeek', 'Orchestrator AI');
+
+-- Delete existing entries to avoid duplicates
+DELETE FROM pseudonym_dictionaries 
+WHERE original_value IN ('Matthew Weber', 'Matt Weber', 'GolferGeek', 'Orchestrator AI');
+
+-- Insert the three entries we need
+INSERT INTO pseudonym_dictionaries (
+  original_value, 
+  pseudonym, 
+  data_type, 
+  category, 
+  is_active,
+  created_at,
+  updated_at
+) VALUES 
+  ('Matthew Weber', 'PERSON_001', 'person_name', 'test', true, NOW(), NOW()),
+  ('Matt Weber', 'PERSON_001', 'person_name', 'test', true, NOW(), NOW()),
+  ('GolferGeek', 'USERNAME_001', 'username', 'test', true, NOW(), NOW()),
+  ('Orchestrator AI', 'COMPANY_001', 'organization', 'test', true, NOW(), NOW())
+ON CONFLICT (original_value) DO UPDATE
+SET 
+  pseudonym = EXCLUDED.pseudonym,
+  data_type = EXCLUDED.data_type,
+  category = EXCLUDED.category,
+  is_active = true,
+  updated_at = NOW();
+
+-- Verify the entries were added
+SELECT original_value, pseudonym, data_type, category, is_active 
+FROM pseudonym_dictionaries 
+WHERE original_value IN ('Matthew Weber', 'Matt Weber', 'GolferGeek', 'Orchestrator AI');
+
+EOF
+
+echo ""
+echo "‚úÖ Dictionary entries added successfully!"
+echo ""
+echo "Now testing with the API..."
+
+# API endpoint
+API_URL="${VITE_API_BASE_URL:-http://localhost:3001}"
+
+# Login to get JWT token
+echo "üîê Logging in to get JWT token..."
+LOGIN_RESPONSE=$(curl -s -X POST "${API_URL}/auth/login" \
+  -H "Content-Type: application/json" \
+  -d "{
+    \"email\": \"${SUPABASE_TEST_USER}\",
+    \"password\": \"${SUPABASE_TEST_PASSWORD}\"
+  }")
+
+JWT_TOKEN=$(echo $LOGIN_RESPONSE | jq -r '.accessToken // .access_token // .token // empty')
+
+if [ -z "$JWT_TOKEN" ]; then
+  echo "‚ùå Failed to get JWT token"
+  exit 1
+fi
+
+echo "‚úÖ Got JWT token"
+
+# Test the sanitization
+echo ""
+echo "üß™ Testing PII detection with our test prompt..."
+
+TEST_PROMPT="Can you check the status of my server at 192.168.1.1? The documentation is at http://internal-docs.company.com/wiki/setup. I wrote a blog post about Matt Weber. He is sometimes known as GolferGeek. He is the owner of Orchestrator AI. It was a great post!"
+
+SANITIZE_RESULT=$(curl -s -X POST "${API_URL}/llm/sanitization/test" \
+  -H "Authorization: Bearer ${JWT_TOKEN}" \
+  -H "Content-Type: application/json" \
+  -d "{
+    \"text\": \"$TEST_PROMPT\",
+    \"enableRedaction\": true,
+    \"enablePseudonymization\": true
+  }")
+
+echo "Sanitization test result:"
+echo "$SANITIZE_RESULT" | jq '.'
+
+# Extract counts
+REDACTIONS=$(echo "$SANITIZE_RESULT" | jq -r '.result.redactionResult.redactionCount // 0')
+PSEUDONYMS=$(echo "$SANITIZE_RESULT" | jq -r '.result.pseudonymizationResult.pseudonyms | length // 0')
+
+echo ""
+echo "üìä Summary:"
+echo "  - Redactions applied: $REDACTIONS (expected: 2 - IP and URL)"
+echo "  - Pseudonyms used: $PSEUDONYMS (expected: 3 - Matt Weber, GolferGeek, Orchestrator AI)"
+
+# Check if the sanitized text has replacements
+SANITIZED_TEXT=$(echo "$SANITIZE_RESULT" | jq -r '.sanitizedText // ""')
+
+echo ""
+echo "üîç Checking replacements in sanitized text:"
+if [[ "$SANITIZED_TEXT" == *"[IP_ADDRESS_REDACTED]"* ]]; then
+  echo "  ‚úÖ IP address was redacted"
+else
+  echo "  ‚ùå IP address was NOT redacted"
+fi
+
+if [[ "$SANITIZED_TEXT" == *"[INTERNAL_URL_REDACTED]"* ]]; then
+  echo "  ‚úÖ Internal URL was redacted"
+else
+  echo "  ‚ùå Internal URL was NOT redacted"
+fi
+
+if [[ "$SANITIZED_TEXT" == *"PERSON_001"* ]]; then
+  echo "  ‚úÖ Matt Weber was replaced with PERSON_001"
+else
+  echo "  ‚ùå Matt Weber was NOT replaced"
+fi
+
+if [[ "$SANITIZED_TEXT" == *"USERNAME_001"* ]]; then
+  echo "  ‚úÖ GolferGeek was replaced with USERNAME_001"
+else
+  echo "  ‚ùå GolferGeek was NOT replaced"
+fi
+
+if [[ "$SANITIZED_TEXT" == *"COMPANY_001"* ]]; then
+  echo "  ‚úÖ Orchestrator AI was replaced with COMPANY_001"
+else
+  echo "  ‚ùå Orchestrator AI was NOT replaced"
+fi
+
+echo ""
+if [ "$REDACTIONS" -ge 2 ] && [ "$PSEUDONYMS" -ge 3 ]; then
+  echo "‚úÖ All PII detection tests passed!"
+else
+  echo "‚ö†Ô∏è  PII detection not fully working yet"
+fi
\ No newline at end of file
diff --git a/scripts/setup-pii-test-data.sh b/scripts/setup-pii-test-data.sh
new file mode 100755
index 0000000..64586a9
--- /dev/null
+++ b/scripts/setup-pii-test-data.sh
@@ -0,0 +1,167 @@
+#!/bin/bash
+
+echo "üîß Setting up PII test data..."
+echo "================================"
+
+# Load environment variables
+source .env
+
+# API endpoint
+API_URL="${VITE_API_BASE_URL:-http://localhost:3001}"
+
+# First, login to get JWT token
+echo "üîê Logging in to get JWT token..."
+LOGIN_RESPONSE=$(curl -s -X POST "${API_URL}/auth/login" \
+  -H "Content-Type: application/json" \
+  -d "{
+    \"email\": \"${SUPABASE_TEST_USER}\",
+    \"password\": \"${SUPABASE_TEST_PASSWORD}\"
+  }")
+
+# Extract JWT token
+JWT_TOKEN=$(echo $LOGIN_RESPONSE | jq -r '.accessToken // .access_token // .token // .data.token // .data.access_token // empty')
+
+if [ -z "$JWT_TOKEN" ]; then
+  echo "‚ùå Failed to get JWT token"
+  echo "Response: $LOGIN_RESPONSE"
+  exit 1
+fi
+
+echo "‚úÖ Got JWT token"
+
+# Add pseudonym dictionary entries
+echo ""
+echo "üìù Adding pseudonym dictionary entries..."
+
+# Add Matthew Weber -> Matt Weber
+echo "  Adding: Matthew Weber"
+curl -s -X POST "${API_URL}/llm/sanitization/pseudonym/dictionary" \
+  -H "Authorization: Bearer ${JWT_TOKEN}" \
+  -H "Content-Type: application/json" \
+  -d '{
+    "originalValue": "Matthew Weber",
+    "pseudonym": "PERSON_001",
+    "dataType": "person_name",
+    "context": "test",
+    "isActive": true
+  }' | jq -r '.message // .error // "Entry added"'
+
+curl -s -X POST "${API_URL}/llm/sanitization/pseudonym/dictionary" \
+  -H "Authorization: Bearer ${JWT_TOKEN}" \
+  -H "Content-Type: application/json" \
+  -d '{
+    "originalValue": "Matt Weber",
+    "pseudonym": "PERSON_001",
+    "dataType": "person_name",
+    "context": "test",
+    "isActive": true
+  }' | jq -r '.message // .error // "Entry added"'
+
+# Add GolferGeek
+echo "  Adding: GolferGeek"
+curl -s -X POST "${API_URL}/llm/sanitization/pseudonym/dictionary" \
+  -H "Authorization: Bearer ${JWT_TOKEN}" \
+  -H "Content-Type: application/json" \
+  -d '{
+    "originalValue": "GolferGeek",
+    "pseudonym": "USERNAME_001",
+    "dataType": "username",
+    "context": "test",
+    "isActive": true
+  }' | jq -r '.message // .error // "Entry added"'
+
+# Add Orchestrator AI
+echo "  Adding: Orchestrator AI"
+curl -s -X POST "${API_URL}/llm/sanitization/pseudonym/dictionary" \
+  -H "Authorization: Bearer ${JWT_TOKEN}" \
+  -H "Content-Type: application/json" \
+  -d '{
+    "originalValue": "Orchestrator AI",
+    "pseudonym": "COMPANY_001",
+    "dataType": "organization",
+    "context": "test",
+    "isActive": true
+  }' | jq -r '.message // .error // "Entry added"'
+
+echo ""
+echo "üîç Checking PII patterns configuration..."
+
+# Get current PII patterns
+PATTERNS=$(curl -s -X GET "${API_URL}/llm/sanitization/pii/patterns" \
+  -H "Authorization: Bearer ${JWT_TOKEN}")
+
+echo "Current patterns count: $(echo $PATTERNS | jq -r '.patterns | length // 0')"
+
+# Check if we have IP and URL patterns
+HAS_IP=$(echo $PATTERNS | jq -r '.patterns[] | select(.name == "ipAddress") // empty')
+HAS_URL=$(echo $PATTERNS | jq -r '.patterns[] | select(.name == "url") // empty')
+
+if [ -z "$HAS_IP" ]; then
+  echo "  ‚ö†Ô∏è  No IP address pattern found - adding..."
+  curl -s -X POST "${API_URL}/llm/sanitization/pii/patterns" \
+    -H "Authorization: Bearer ${JWT_TOKEN}" \
+    -H "Content-Type: application/json" \
+    -d '{
+      "name": "ipAddress",
+      "pattern": "\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b",
+      "type": "ip_address",
+      "description": "IP Address pattern",
+      "isActive": true,
+      "severity": "high"
+    }' | jq -r '.message // .error // "Pattern added"'
+else
+  echo "  ‚úÖ IP address pattern exists"
+fi
+
+if [ -z "$HAS_URL" ]; then
+  echo "  ‚ö†Ô∏è  No URL pattern found - adding..."
+  curl -s -X POST "${API_URL}/llm/sanitization/pii/patterns" \
+    -H "Authorization: Bearer ${JWT_TOKEN}" \
+    -H "Content-Type: application/json" \
+    -d '{
+      "name": "url",
+      "pattern": "https?://[\\w.-]+(?:\\.[\\w\\.-]+)+[\\w\\-\\._~:/?#[\\]@!\\$&'"'"'\\(\\)\\*\\+,;=.]+",
+      "type": "url",
+      "description": "URL pattern",
+      "isActive": true,
+      "severity": "medium"
+    }' | jq -r '.message // .error // "Pattern added"'
+else
+  echo "  ‚úÖ URL pattern exists"
+fi
+
+echo ""
+echo "üß™ Testing PII detection with our test prompt..."
+
+TEST_PROMPT="Can you check the status of my server at 192.168.1.1? The documentation is at http://internal-docs.company.com/wiki/setup. I wrote a blog post about Matt Weber. He is sometimes known as GolferGeek. He is the owner of Orchestrator AI. It was a great post!"
+
+# Test the sanitization endpoint
+SANITIZE_RESULT=$(curl -s -X POST "${API_URL}/llm/sanitization/test" \
+  -H "Authorization: Bearer ${JWT_TOKEN}" \
+  -H "Content-Type: application/json" \
+  -d "{
+    \"text\": \"$TEST_PROMPT\",
+    \"enableRedaction\": true,
+    \"enablePseudonymization\": true
+  }")
+
+echo "Sanitization test result:"
+echo "$SANITIZE_RESULT" | jq '.'
+
+# Extract counts
+REDACTIONS=$(echo "$SANITIZE_RESULT" | jq -r '.result.redactionResult.redactionCount // 0')
+PSEUDONYMS=$(echo "$SANITIZE_RESULT" | jq -r '.result.pseudonymizationResult.pseudonyms | length // 0')
+
+echo ""
+echo "üìä Summary:"
+echo "  - Redactions applied: $REDACTIONS (expected: 2 - IP and URL)"
+echo "  - Pseudonyms used: $PSEUDONYMS (expected: 3 - Matt Weber, GolferGeek, Orchestrator AI)"
+
+if [ "$REDACTIONS" -ge 2 ] && [ "$PSEUDONYMS" -ge 3 ]; then
+  echo ""
+  echo "‚úÖ All PII detection tests passed!"
+else
+  echo ""
+  echo "‚ö†Ô∏è  PII detection not fully working yet"
+  echo "  Please check the configuration and try again"
+fi
\ No newline at end of file
diff --git a/scripts/test-llm-pii-flow.sh b/scripts/test-llm-pii-flow.sh
new file mode 100755
index 0000000..d29048e
--- /dev/null
+++ b/scripts/test-llm-pii-flow.sh
@@ -0,0 +1,112 @@
+#!/bin/bash
+
+echo "üß™ Testing LLM PII Flow End-to-End"
+echo "==================================="
+
+# Load environment variables
+source .env
+
+# API endpoint
+API_URL="${VITE_API_BASE_URL:-http://localhost:3001}"
+
+# Login to get JWT token
+echo "üîê Logging in..."
+LOGIN_RESPONSE=$(curl -s -X POST "${API_URL}/auth/login" \
+  -H "Content-Type: application/json" \
+  -d "{
+    \"email\": \"${SUPABASE_TEST_USER}\",
+    \"password\": \"${SUPABASE_TEST_PASSWORD}\"
+  }")
+
+JWT_TOKEN=$(echo $LOGIN_RESPONSE | jq -r '.accessToken // .access_token // .token // empty')
+
+if [ -z "$JWT_TOKEN" ]; then
+  echo "‚ùå Failed to get JWT token"
+  exit 1
+fi
+
+echo "‚úÖ Got JWT token"
+echo ""
+
+# Test prompt with all 5 PII items
+TEST_PROMPT="Can you check the status of my server at 192.168.1.1? The documentation is at http://internal-docs.company.com/wiki/setup. I wrote a blog post about Matt Weber. He is sometimes known as GolferGeek. He is the owner of Orchestrator AI."
+
+echo "üìù Test prompt:"
+echo "$TEST_PROMPT"
+echo ""
+
+# Call the LLM directly
+echo "ü§ñ Calling LLM with PII in prompt..."
+echo ""
+
+LLM_RESPONSE=$(curl -s -X POST "${API_URL}/llm/generate" \
+  -H "Authorization: Bearer ${JWT_TOKEN}" \
+  -H "Content-Type: application/json" \
+  -d "{
+    \"systemPrompt\": \"You are a helpful assistant. Be very concise.\",
+    \"userPrompt\": \"$TEST_PROMPT\",
+    \"options\": {
+      \"provider\": \"openai\",
+      \"providerName\": \"openai\",
+      \"modelName\": \"gpt-4o-mini\",
+      \"maxTokens\": 50,
+      \"temperature\": 0.1,
+      \"callerType\": \"pii-test\",
+      \"callerName\": \"test-script\"
+    }
+  }")
+
+# Check if we got an error
+if echo "$LLM_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
+  echo "‚ùå LLM call failed:"
+  echo "$LLM_RESPONSE" | jq '.'
+  exit 1
+fi
+
+# Extract and display the response
+echo "üì§ LLM Response:"
+echo "$LLM_RESPONSE" | jq -r '.content // .response // .data.content // "No content found"'
+echo ""
+
+# Check PII metadata
+echo "üîç PII Metadata:"
+PII_METADATA=$(echo "$LLM_RESPONSE" | jq '.piiMetadata // .metadata.piiMetadata // {}')
+
+if [ "$PII_METADATA" != "{}" ]; then
+  echo "$PII_METADATA" | jq '.'
+  
+  # Extract specific values
+  PII_DETECTED=$(echo "$PII_METADATA" | jq -r '.piiDetected // false')
+  FLAGGINGS=$(echo "$PII_METADATA" | jq -r '.flaggings // []')
+  PSEUDONYMS=$(echo "$PII_METADATA" | jq -r '.pseudonymsApplied // .pseudonyms // []')
+  
+  echo ""
+  echo "üìä Summary:"
+  echo "  - PII Detected: $PII_DETECTED"
+  echo "  - Flaggings: $(echo "$FLAGGINGS" | jq 'length') items"
+  echo "  - Pseudonyms Applied: $(echo "$PSEUDONYMS" | jq 'length') items"
+  
+  if [ "$(echo "$FLAGGINGS" | jq 'length')" -gt 0 ]; then
+    echo ""
+    echo "  üö© Flagged items:"
+    echo "$FLAGGINGS" | jq -r '.[] | "    - \(.type): \(.value)"'
+  fi
+  
+  if [ "$(echo "$PSEUDONYMS" | jq 'length')" -gt 0 ]; then
+    echo ""
+    echo "  üé≠ Pseudonymized items:"
+    echo "$PSEUDONYMS" | jq -r '.[] | "    - \(.original) ‚Üí \(.pseudonym)"'
+  fi
+else
+  echo "‚ö†Ô∏è  No PII metadata found in response"
+fi
+
+echo ""
+echo "üîç Checking usage metadata:"
+USAGE=$(echo "$LLM_RESPONSE" | jq '.metadata.usage // {}')
+if [ "$USAGE" != "{}" ]; then
+  echo "  - PII Detected: $(echo "$USAGE" | jq -r '.piiDetected // "N/A"')"
+  echo "  - PII Types: $(echo "$USAGE" | jq -r '.piiTypes // [] | join(", ")')"
+  echo "  - Pseudonyms Used: $(echo "$USAGE" | jq -r '.pseudonymsUsed // 0')"
+  echo "  - Redactions Applied: $(echo "$USAGE" | jq -r '.redactionsApplied // 0')"
+fi
\ No newline at end of file
diff --git a/scripts/test-pii-pseudonym.sh b/scripts/test-pii-pseudonym.sh
new file mode 100755
index 0000000..606af2c
--- /dev/null
+++ b/scripts/test-pii-pseudonym.sh
@@ -0,0 +1,45 @@
+#!/bin/bash
+
+echo "üß™ Running PII and Pseudonym End-to-End Tests"
+echo "============================================="
+echo ""
+
+cd "$(dirname "$0")/.."
+
+echo "üì¶ Ensuring dependencies are installed..."
+npm install
+
+echo ""
+echo "üîç Running PII/Pseudonym E2E tests..."
+echo ""
+
+cd apps/api
+
+npx jest src/llms/pii-pseudonym-e2e.spec.ts \
+  --verbose \
+  --forceExit \
+  --detectOpenHandles \
+  --testTimeout=60000
+
+TEST_EXIT_CODE=$?
+
+if [ $TEST_EXIT_CODE -eq 0 ]; then
+  echo ""
+  echo "‚úÖ All PII/Pseudonym tests passed!"
+  echo ""
+  echo "Summary:"
+  echo "- ‚úì IP address and URL flagging detection"
+  echo "- ‚úì Pseudonym replacement for known entities"
+  echo "- ‚úì Complete sanitization pipeline"
+  echo "- ‚úì LLM request with PII metadata tracking"
+  echo "- ‚úì Database storage verification"
+  echo "- ‚úì Reversible sanitization"
+  echo "- ‚úì Metrics extraction"
+  echo "- ‚úì Cache management"
+  echo "- ‚úì Safe logging"
+else
+  echo ""
+  echo "‚ùå Some tests failed. Please review the output above."
+fi
+
+exit $TEST_EXIT_CODE
\ No newline at end of file
diff --git a/scripts/wt-add.sh b/scripts/wt-add.sh
new file mode 100755
index 0000000..2361e1b
--- /dev/null
+++ b/scripts/wt-add.sh
@@ -0,0 +1,46 @@
+#!/bin/bash
+
+# Script to add a new Windows Terminal tab with port-based naming
+# Usage: ./scripts/wt-add.sh
+# Reads ports from .env file
+
+# Load environment variables to get ports
+if [ -f ".env" ]; then
+    # Extract API_PORT from .env
+    API_PORT=$(grep "^API_PORT=" .env | cut -d '=' -f2)
+    WEB_PORT=$(grep "^WEB_PORT=" .env | cut -d '=' -f2)
+    
+    if [ -z "$API_PORT" ] || [ -z "$WEB_PORT" ]; then
+        echo "Error: API_PORT and WEB_PORT must be defined in .env file"
+        echo "Please add:"
+        echo "API_PORT=7100"
+        echo "WEB_PORT=7101"
+        exit 1
+    fi
+else
+    echo "Error: .env file not found"
+    echo "Please create .env file with API_PORT and WEB_PORT defined"
+    exit 1
+fi
+
+# Tab name with port from .env
+TAB_NAME="Orch-port-${API_PORT}"
+
+# Get current directory name (for worktree identification)
+CURRENT_DIR=$(basename "$PWD")
+
+echo "Starting environment with API_PORT=${API_PORT}, WEB_PORT=${WEB_PORT}"
+
+# Check if we're using Windows Terminal
+if command -v wt.exe &> /dev/null; then
+    echo "Opening new Windows Terminal tab: ${TAB_NAME}"
+    wt.exe -w 0 new-tab --title "${TAB_NAME}" -d "$PWD" bash -c "./start-dev-local.sh"
+elif command -v wt &> /dev/null; then
+    echo "Opening new Windows Terminal tab: ${TAB_NAME}"
+    wt -w 0 new-tab --title "${TAB_NAME}" -d "$PWD" bash -c "./start-dev-local.sh"
+else
+    echo "Windows Terminal not found. Setting terminal title instead..."
+    # For other terminals, try to set the title
+    echo -e "\033]0;${TAB_NAME}\007"
+    ./start-dev-local.sh
+fi
\ No newline at end of file
diff --git a/start-dev-local.sh b/start-dev-local.sh
index f5bf33d..cc1c5f4 100755
--- a/start-dev-local.sh
+++ b/start-dev-local.sh
@@ -8,9 +8,6 @@ YELLOW='\033[1;33m'
 NC='\033[0m' # No Color
 
 echo -e "${BLUE}üöÄ Starting Orchestrator AI Development Environment${NC}"
-echo -e "${BLUE}   API Port: 7100${NC}"
-echo -e "${BLUE}   Web Port: 7101${NC}"
-echo -e "${BLUE}   Supabase: Local instance${NC}"
 
 # Function to cleanup on exit
 cleanup() {
@@ -56,6 +53,22 @@ source .env
 set +a
 echo -e "${GREEN}‚úÖ Environment variables loaded${NC}"
 
+# Check if ports are defined in .env
+if [ -z "$API_PORT" ] || [ -z "$WEB_PORT" ]; then
+    echo -e "${RED}‚ùå Error: API_PORT and WEB_PORT must be defined in .env file${NC}"
+    echo -e "${YELLOW}Please add the following to your .env file:${NC}"
+    echo -e "${YELLOW}API_PORT=7100${NC}"
+    echo -e "${YELLOW}WEB_PORT=7101${NC}"
+    exit 1
+fi
+
+# Set terminal title with port number
+echo -e "\033]0;Orch-port-${API_PORT}\007"
+
+echo -e "${BLUE}   API Port: ${API_PORT}${NC}"
+echo -e "${BLUE}   Web Port: ${WEB_PORT}${NC}"
+echo -e "${BLUE}   Supabase: Local instance${NC}"
+
 # Check if Supabase is running
 echo -e "${BLUE}üóÑÔ∏è  Checking Supabase status...${NC}"
 cd apps/api
@@ -73,8 +86,8 @@ else
 fi
 
 # Start API server
-echo -e "${BLUE}üî• Starting API server on port 7100...${NC}"
-npm run start:dev &
+echo -e "${BLUE}üî• Starting API server on port ${API_PORT}...${NC}"
+PORT=${API_PORT} npm run start:dev &
 API_PID=$!
 
 # Wait a moment for API to start
@@ -82,16 +95,16 @@ sleep 3
 
 # Go back to root and start web server
 cd ../../apps/web
-echo -e "${BLUE}üåê Starting Web server on port 7101...${NC}"
-npm run dev:http &
+echo -e "${BLUE}üåê Starting Web server on port ${WEB_PORT}...${NC}"
+PORT=${WEB_PORT} npm run dev:http &
 WEB_PID=$!
 
 # Wait a moment for web server to start
 sleep 3
 
 echo -e "${GREEN}‚úÖ Development environment ready!${NC}"
-echo -e "${BLUE}üì° API Server: http://localhost:7100${NC}"
-echo -e "${BLUE}üåê Web App: http://localhost:7101${NC}"
+echo -e "${BLUE}üì° API Server: http://localhost:${API_PORT}${NC}"
+echo -e "${BLUE}üåê Web App: http://localhost:${WEB_PORT}${NC}"
 echo -e "${BLUE}üóÑÔ∏è  Supabase Studio: http://127.0.0.1:54323${NC}"
 echo -e "${BLUE}üìß Inbucket (Email): http://127.0.0.1:54324${NC}"
 echo -e "\n${BLUE}Press Ctrl+C to stop all services${NC}"
-- 
2.50.1

