import { createMockExecutionContext } from "@orchestrator-ai/transport-types";
import {
  ExtendedPostWriterStateAnnotation,
  ExtendedPostWriterState,
} from "./extended-post-writer.state";
import { createExtendedPostWriterGraph } from "./extended-post-writer.graph";
import { LLMHttpClientService } from "../../services/llm-http-client.service";
import { ObservabilityService } from "../../services/observability.service";
import { PostgresCheckpointerService } from "../../persistence/postgres-checkpointer.service";

/**
 * Unit tests for createExtendedPostWriterGraph
 *
 * Tests the Extended Post Writer graph creation and node logic.
 * Validates ExecutionContext flow, HITL workflows, and state transitions.
 *
 * CRITICAL: This agent relies heavily on HITL (Human-In-The-Loop) functionality.
 * Tests must validate:
 * - HITL interruption at the correct point (after blog post generation)
 * - HITL resume with different decisions (approve, regenerate, reject, replace)
 * - Content flow through HITL (blog post only at interrupt, SEO/social after approval)
 * - ExecutionContext preservation through HITL workflow
 *
 * Note: These tests focus on the graph creation and individual node behavior.
 * For full workflow integration tests, see extended-post-writer-e2e.spec.ts
 */
describe("createExtendedPostWriterGraph", () => {
  let mockLLMClient: jest.Mocked<LLMHttpClientService>;
  let mockObservability: jest.Mocked<ObservabilityService>;
  let mockCheckpointer: jest.Mocked<PostgresCheckpointerService>;
  let mockExecutionContext: ReturnType<typeof createMockExecutionContext>;

  const mockSaver = {
    setup: jest.fn().mockResolvedValue(undefined),
    put: jest.fn().mockResolvedValue(undefined),
    get: jest.fn().mockResolvedValue(null),
    getTuple: jest.fn().mockResolvedValue(null),
    list: jest.fn().mockReturnValue([]),
  };

  beforeEach(() => {
    // Create mock ExecutionContext
    mockExecutionContext = createMockExecutionContext({
      taskId: "task-123",
      userId: "user-456",
      conversationId: "conv-789",
      orgSlug: "org-abc",
      agentSlug: "extended-post-writer",
      agentType: "langgraph",
      provider: "anthropic",
      model: "claude-sonnet-4-20250514",
    });

    // Mock LLMHttpClientService
    mockLLMClient = {
      callLLM: jest.fn().mockResolvedValue({
        text: "This is a sample blog post content generated by the LLM.",
        usage: { promptTokens: 100, completionTokens: 50, totalTokens: 150 },
      }),
    } as any;

    // Mock ObservabilityService
    mockObservability = {
      emit: jest.fn().mockResolvedValue(undefined),
      emitStarted: jest.fn().mockResolvedValue(undefined),
      emitProgress: jest.fn().mockResolvedValue(undefined),
      emitHitlWaiting: jest.fn().mockResolvedValue(undefined),
      emitCompleted: jest.fn().mockResolvedValue(undefined),
      emitFailed: jest.fn().mockResolvedValue(undefined),
    } as any;

    // Mock PostgresCheckpointerService
    mockCheckpointer = {
      getSaver: jest.fn().mockReturnValue(mockSaver),
      getPool: jest.fn().mockReturnValue({}),
      isReady: jest.fn().mockReturnValue(true),
    } as any;
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe("Graph Creation", () => {
    it("should create a graph with all required components", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockCheckpointer.getSaver).toHaveBeenCalled();
    });

    it("should compile graph with checkpointer for state persistence", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockCheckpointer.getSaver).toHaveBeenCalled();
      // Checkpointer is required for HITL workflow to persist state during interrupts
    });

    it("should accept required service dependencies", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockLLMClient).toBeDefined();
      expect(mockObservability).toBeDefined();
      expect(mockCheckpointer).toBeDefined();
    });
  });

  describe("Node Configuration", () => {
    it("should configure all required nodes", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // Nodes: initialize, generate_blog_post, hitl_interrupt, generate_seo,
      // generate_social, finalize, finalize_rejected, handle_error
    });

    it("should configure initialize node", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockObservability).toBeDefined();
      // Initialize node emits started event
    });

    it("should configure generate_blog_post node", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockLLMClient).toBeDefined();
      // Blog post node calls LLM
    });

    it("should configure hitl_interrupt node", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockObservability).toBeDefined();
      // HITL node emits waiting event and uses interrupt()
    });

    it("should configure generate_seo node", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockLLMClient).toBeDefined();
      // SEO node calls LLM after HITL approval
    });

    it("should configure generate_social node", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockLLMClient).toBeDefined();
      // Social node calls LLM after SEO generation
    });

    it("should configure finalize node", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockObservability).toBeDefined();
      // Finalize node emits completed event
    });

    it("should configure finalize_rejected node", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockObservability).toBeDefined();
      // Finalize rejected node emits failed event
    });

    it("should configure handle_error node", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockObservability).toBeDefined();
      // Error node emits failed event
    });
  });

  describe("HITL Workflow Configuration", () => {
    it("should support HITL interruption after blog post generation", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockCheckpointer.getSaver).toHaveBeenCalled();
      // HITL interrupt happens after generate_blog_post node
      // Checkpointer is required to persist state during interrupt
    });

    it("should emit HITL waiting event at interrupt point", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockObservability.emitHitlWaiting).toBeDefined();
      // HITL interrupt node calls emitHitlWaiting before interrupt()
    });

    it("should route to generate_seo after approve decision", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // routeAfterHitl function routes approve/skip/replace to generate_seo
    });

    it("should route to generate_blog_post after regenerate decision", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // routeAfterHitl function routes regenerate to generate_blog_post
    });

    it("should route to finalize_rejected after reject decision", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // routeAfterHitl function routes reject to finalize_rejected
    });

    it("should handle edited content with replace decision", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // HITL interrupt node handles editedContent from replace decision
    });
  });

  describe("Content Generation Flow", () => {
    it("should generate blog post first", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockLLMClient.callLLM).toBeDefined();
      // Flow: initialize → generate_blog_post → HITL
    });

    it("should generate SEO after HITL approval", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // Flow: HITL (approve) → generate_seo
    });

    it("should generate social posts after SEO", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // Flow: generate_seo → generate_social
    });

    it("should finalize content after social generation", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // Flow: generate_social → finalize → END
    });
  });

  describe("ExecutionContext Flow Validation", () => {
    it("should pass ExecutionContext to observability service", () => {
      // Arrange
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockObservability).toBeDefined();
      // ExecutionContext flow validated in integration tests
    });

    it("should maintain ExecutionContext through state", () => {
      // Arrange
      const initialState: Partial<ExtendedPostWriterState> = {
        executionContext: mockExecutionContext,
        userMessage: "Test topic",
      };

      // Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(initialState.executionContext).toEqual(mockExecutionContext);
    });

    it("should use ExecutionContext taskId as thread_id", () => {
      // Arrange
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // Graph uses context.taskId as thread_id in config during invocation
    });

    it("should preserve ExecutionContext through HITL workflow", () => {
      // Arrange
      const initialState: Partial<ExtendedPostWriterState> = {
        executionContext: mockExecutionContext,
        userMessage: "Test topic",
      };

      // Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(initialState.executionContext.taskId).toBe("task-123");
      // ExecutionContext must be preserved through HITL interrupt/resume cycle
    });
  });

  describe("LLM Integration", () => {
    it("should call LLM for blog post generation", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockLLMClient.callLLM).toBeDefined();
      // generate_blog_post node calls LLM with topic and tone
    });

    it("should call LLM for SEO generation", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockLLMClient.callLLM).toBeDefined();
      // generate_seo node calls LLM with blog post
    });

    it("should call LLM for social posts generation", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockLLMClient.callLLM).toBeDefined();
      // generate_social node calls LLM with blog post
    });

    it("should pass ExecutionContext to LLM calls", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // All LLM calls use context: ctx parameter
    });

    it("should handle LLM errors gracefully", () => {
      // Arrange
      mockLLMClient.callLLM.mockRejectedValue(new Error("LLM timeout"));

      // Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // Error handling tested in integration tests
    });
  });

  describe("Error Handling Configuration", () => {
    it("should handle blog post generation errors", () => {
      // Arrange
      mockLLMClient.callLLM.mockRejectedValue(new Error("LLM error"));

      // Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // generate_blog_post node sets error and status: 'failed' on error
    });

    it("should handle SEO generation errors", () => {
      // Arrange
      mockLLMClient.callLLM.mockRejectedValue(new Error("LLM error"));

      // Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // generate_seo node sets error and status: 'failed' on error
    });

    it("should handle social posts generation errors gracefully", () => {
      // Arrange
      mockLLMClient.callLLM.mockRejectedValue(new Error("LLM error"));

      // Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // generate_social node returns empty array on error instead of failing workflow
    });

    it("should route to handle_error node on errors", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // Conditional edges route to handle_error when state.error is set
    });

    it("should emit failed event on errors", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockObservability.emitFailed).toBeDefined();
      // handle_error node calls emitFailed
    });
  });

  describe("State Management", () => {
    it("should define state annotation with all required fields", () => {
      // Arrange
      const annotation = ExtendedPostWriterStateAnnotation;

      // Assert
      expect(annotation).toBeDefined();
      expect(annotation.spec).toBeDefined();
    });

    it("should validate ExecutionContext in state", () => {
      // Arrange
      const initialState: Partial<ExtendedPostWriterState> = {
        executionContext: mockExecutionContext,
      };

      // Assert
      expect(initialState.executionContext).toBeDefined();
      expect(initialState.executionContext.taskId).toBe("task-123");
      expect(initialState.executionContext.userId).toBe("user-456");
      expect(initialState.executionContext.agentSlug).toBe(
        "extended-post-writer",
      );
    });

    it("should include HITL state fields from HitlBaseStateAnnotation", () => {
      // Arrange
      const initialState: Partial<ExtendedPostWriterState> = {
        executionContext: mockExecutionContext,
        hitlDecision: null,
        hitlFeedback: null,
        hitlPending: false,
      };

      // Assert
      expect(initialState.hitlDecision).toBeNull();
      expect(initialState.hitlFeedback).toBeNull();
      expect(initialState.hitlPending).toBe(false);
    });

    it("should include content generation fields", () => {
      // Arrange
      const initialState: Partial<ExtendedPostWriterState> = {
        executionContext: mockExecutionContext,
        blogPost: "",
        seoDescription: "",
        socialPosts: [],
      };

      // Assert
      expect(initialState.blogPost).toBe("");
      expect(initialState.seoDescription).toBe("");
      expect(initialState.socialPosts).toEqual([]);
    });

    it("should track generation count for regeneration", () => {
      // Arrange
      const initialState: Partial<ExtendedPostWriterState> = {
        executionContext: mockExecutionContext,
        generationCount: 0,
      };

      // Assert
      expect(initialState.generationCount).toBe(0);
      // generationCount increments on each blog post generation
    });
  });

  describe("Observability Integration", () => {
    it("should emit started event on initialization", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockObservability.emitStarted).toBeDefined();
      // initialize node calls emitStarted
    });

    it("should emit progress events during generation", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockObservability.emitProgress).toBeDefined();
      // All generation nodes call emitProgress
    });

    it("should emit HITL waiting event at interrupt", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockObservability.emitHitlWaiting).toBeDefined();
      // HITL interrupt node calls emitHitlWaiting
    });

    it("should emit completed event on success", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockObservability.emitCompleted).toBeDefined();
      // finalize node calls emitCompleted
    });

    it("should emit failed event on rejection", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(mockObservability.emitFailed).toBeDefined();
      // finalize_rejected node calls emitFailed
    });

    it("should pass ExecutionContext to all observability events", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // All observability calls use ctx (ExecutionContext) parameter
    });
  });

  describe("HITL Decision Routing", () => {
    it("should handle approve decision correctly", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // approve → generate_seo → generate_social → finalize
    });

    it("should handle skip decision correctly", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // skip → generate_seo (same as approve)
    });

    it("should handle replace decision correctly", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // replace → generate_seo (with edited content)
    });

    it("should handle regenerate decision correctly", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // regenerate → generate_blog_post (with feedback)
    });

    it("should handle reject decision correctly", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // reject → finalize_rejected → END
    });
  });

  describe("Content Flow Through HITL", () => {
    it("should only have blog post at HITL interrupt point", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // HITL interrupt happens after blog post generation
      // SEO and social posts are empty at this point
    });

    it("should generate SEO and social only after HITL approval", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // Flow: HITL (approve) → generate_seo → generate_social
    });

    it("should include all content in final output", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // finalize node creates finalContent with blog, SEO, and social
    });
  });

  describe("Feedback and Regeneration", () => {
    it("should support feedback on regenerate decision", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // regenerate decision includes hitlFeedback
      // generate_blog_post node uses hitlFeedback in prompt
    });

    it("should clear feedback after regeneration", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // generate_blog_post node clears hitlFeedback and hitlDecision
    });

    it("should increment generation count on regeneration", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // generate_blog_post node increments generationCount
    });
  });

  describe("Input Parameters", () => {
    it("should support optional tone parameter", () => {
      // Arrange
      const initialState: Partial<ExtendedPostWriterState> = {
        executionContext: mockExecutionContext,
        tone: "casual",
      };

      // Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(initialState.tone).toBe("casual");
      // generate_blog_post uses tone in prompt
    });

    it("should support optional keywords parameter", () => {
      // Arrange
      const initialState: Partial<ExtendedPostWriterState> = {
        executionContext: mockExecutionContext,
        keywords: ["AI", "automation", "productivity"],
      };

      // Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(initialState.keywords).toEqual([
        "AI",
        "automation",
        "productivity",
      ]);
      // generate_blog_post uses keywords in prompt
    });

    it("should support optional context parameter", () => {
      // Arrange
      const initialState: Partial<ExtendedPostWriterState> = {
        executionContext: mockExecutionContext,
        context: "Additional context for the blog post",
      };

      // Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      expect(initialState.context).toBe("Additional context for the blog post");
      // generate_blog_post uses context in prompt
    });
  });

  describe("Social Posts JSON Parsing", () => {
    it("should parse valid JSON social posts response", () => {
      // Arrange
      mockLLMClient.callLLM.mockResolvedValue({
        text: JSON.stringify({
          posts: [
            "Twitter post here",
            "LinkedIn post here",
            "Instagram post here",
          ],
        }),
        usage: { promptTokens: 100, completionTokens: 50, totalTokens: 150 },
      });

      // Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // generate_social node parses JSON response
    });

    it("should handle malformed JSON in social posts response", () => {
      // Arrange
      mockLLMClient.callLLM.mockResolvedValue({
        text: "Not valid JSON",
        usage: { promptTokens: 100, completionTokens: 50, totalTokens: 150 },
      });

      // Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // generate_social node has fallback parsing for numbered/bulleted lists
    });

    it("should fallback to numbered list parsing for social posts", () => {
      // Arrange
      mockLLMClient.callLLM.mockResolvedValue({
        text: "1. First post\n2. Second post\n3. Third post",
        usage: { promptTokens: 100, completionTokens: 50, totalTokens: 150 },
      });

      // Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // generate_social node extracts numbered list items
    });

    it("should return empty array on social posts generation failure", () => {
      // Arrange
      mockLLMClient.callLLM.mockRejectedValue(new Error("LLM error"));

      // Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // generate_social node returns empty array instead of failing workflow
    });
  });

  describe("Graph Edge Configuration", () => {
    it("should configure edge from start to initialize", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // __start__ → initialize
    });

    it("should configure edge from initialize to generate_blog_post", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // initialize → generate_blog_post
    });

    it("should configure conditional edge from generate_blog_post", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // generate_blog_post → hitl_interrupt (or handle_error if error)
    });

    it("should configure conditional edge from hitl_interrupt", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // hitl_interrupt → (generate_seo | generate_blog_post | finalize_rejected)
    });

    it("should configure conditional edge from generate_seo", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // generate_seo → generate_social (or handle_error if error)
    });

    it("should configure conditional edge from generate_social", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // generate_social → finalize (or handle_error if error)
    });

    it("should configure edge from finalize to END", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // finalize → END
    });

    it("should configure edge from finalize_rejected to END", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // finalize_rejected → END
    });

    it("should configure edge from handle_error to END", () => {
      // Arrange & Act
      const graph = createExtendedPostWriterGraph(
        mockLLMClient,
        mockObservability,
        mockCheckpointer,
      );

      // Assert
      expect(graph).toBeDefined();
      // handle_error → END
    });
  });
});

/**
 * Integration Tests
 *
 * Full workflow integration tests are in extended-post-writer-e2e.spec.ts
 * These test the complete graph execution with real services:
 * - Full node execution flow
 * - HITL interrupt and resume workflows
 * - State transitions
 * - Error routing
 * - ExecutionContext flow
 * - Observability events
 * - Content generation and validation
 */
