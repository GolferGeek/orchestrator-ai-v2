/**
 * Test Data Injection Framework Interfaces
 * Phase 3 of Financial Asset Predictor PRD
 */

/**
 * Test scenario status lifecycle
 * - active: Created but not yet running
 * - running: Currently executing
 * - completed: Successfully finished
 * - failed: Execution failed
 * - archived: No longer active
 */
export type TestScenarioStatus =
  | 'active'
  | 'running'
  | 'completed'
  | 'failed'
  | 'archived';

/**
 * Valid injection points (prediction schema table names)
 */
export type InjectionPoint =
  | 'strategies'
  | 'universes'
  | 'targets'
  | 'sources'
  | 'source_crawls'
  | 'source_seen_items'
  | 'signal_fingerprints'
  | 'signals'
  | 'predictors'
  | 'predictions'
  | 'snapshots'
  | 'evaluations'
  | 'target_snapshots'
  | 'missed_opportunities'
  | 'tool_requests'
  | 'analysts'
  | 'learnings'
  | 'learning_queue'
  | 'review_queue';

/**
 * Test scenario entity - tracks a test data injection scenario
 * Based on prediction.test_scenarios table
 */
export interface TestScenario {
  id: string;
  name: string;
  description: string | null;
  injection_points: InjectionPoint[];
  target_id: string | null;
  organization_slug: string;
  config: TestScenarioConfig;
  created_by: string | null;
  status: TestScenarioStatus;
  results: TestScenarioResults | null;
  created_at: string;
  started_at: string | null;
  completed_at: string | null;
}

/**
 * Configuration for a test scenario
 */
export interface TestScenarioConfig {
  /** Whether to run tier runners after injection */
  auto_run_tiers?: boolean;
  /** Which tiers to run automatically */
  tiers_to_run?: string[];
  /** Custom configuration per tier */
  tier_config?: Record<string, unknown>;
}

/**
 * Results from a test scenario execution
 */
export interface TestScenarioResults {
  /** Number of items injected per table */
  items_injected?: Record<string, number>;
  /** Number of items generated by tier runners */
  items_generated?: Record<string, number>;
  /** Tier execution results */
  tier_results?: Record<
    string,
    {
      success: boolean;
      processed: number;
      created: number;
      errors: string[];
    }
  >;
  /** Any errors that occurred */
  errors?: string[];
}

/**
 * Data for creating a new test scenario
 */
export interface CreateTestScenarioData {
  name: string;
  description?: string;
  injection_points: InjectionPoint[];
  target_id?: string;
  organization_slug: string;
  config?: TestScenarioConfig;
  created_by?: string;
}

/**
 * Data for updating a test scenario
 */
export interface UpdateTestScenarioData {
  name?: string;
  description?: string;
  injection_points?: InjectionPoint[];
  target_id?: string | null;
  config?: TestScenarioConfig;
  status?: TestScenarioStatus;
  results?: TestScenarioResults;
  started_at?: string;
  completed_at?: string;
}

/**
 * Filter for including/excluding test data in queries
 * Used by all prediction repositories
 */
export interface TestDataFilter {
  /**
   * Whether to include test data in results
   * Default: false (test data excluded)
   */
  includeTestData?: boolean;

  /**
   * Filter to a specific test scenario only
   * When set, only data from this scenario is returned
   */
  testScenarioId?: string;

  /**
   * Only return test data (exclude production data)
   * Useful for viewing test scenario results
   */
  testDataOnly?: boolean;
}

/**
 * Base interface for entities with test data markers
 * All prediction entities should extend this
 */
export interface TestDataMarkers {
  /** Whether this record is test data */
  is_test_data?: boolean;
  /** ID of the test scenario this record belongs to */
  test_scenario_id?: string | null;
}

/**
 * Generic injection data - adds test markers to any entity
 */
export type WithTestMarkers<T> = T & TestDataMarkers;

/**
 * Result from cleanup operations
 */
export interface CleanupResult {
  /** Tables that had data deleted */
  tables_cleaned: Array<{
    table_name: string;
    rows_deleted: number;
  }>;
  /** Total rows deleted */
  total_deleted: number;
}

/**
 * Result from a tier runner execution on test data
 */
export interface TierRunResult {
  /** Whether the tier completed successfully */
  success: boolean;
  /** Number of items processed */
  items_processed: number;
  /** Number of items created */
  items_created: number;
  /** Duration in milliseconds */
  duration_ms: number;
  /** Any errors that occurred */
  errors: string[];
}

/**
 * Summary of a test scenario with data counts
 */
export interface TestScenarioSummary extends TestScenario {
  /** Counts of test data per table */
  data_counts: Record<string, number>;
}

/**
 * Configuration for generating mock signals
 */
export interface MockSignalConfig {
  /** Number of signals to generate */
  count: number;
  /** Target ID for the signals */
  target_id: string;
  /** Source ID for the signals */
  source_id: string;
  /** Distribution of signal directions */
  distribution?: {
    bullish: number;
    bearish: number;
    neutral: number;
  };
  /** Topic for content generation */
  topic?: string;
}

/**
 * Configuration for generating mock predictions with known outcomes
 */
export interface MockPredictionConfig {
  /** Number of predictions to generate */
  count: number;
  /** Target ID for the predictions */
  target_id: string;
  /** Expected accuracy rate (0.0 - 1.0) */
  accuracy_rate: number;
  /** Distribution of prediction directions */
  distribution?: {
    up: number;
    down: number;
    flat: number;
  };
}

/**
 * Configuration for generating mock articles
 */
export interface MockArticleConfig {
  /** Number of articles to generate */
  count: number;
  /** Topic for the articles */
  topic: string;
  /** Overall sentiment */
  sentiment?: 'bullish' | 'bearish' | 'mixed';
  /** Source type */
  source_type?: 'web' | 'rss' | 'twitter_search' | 'api';
}

/**
 * A generated mock article
 */
export interface MockArticle {
  title: string;
  content: string;
  url: string;
  published_at: string;
  author?: string;
  source_name?: string;
}

/**
 * A prediction with its known outcome for testing
 */
export interface MockPredictionWithOutcome {
  prediction: MockPredictionData;
  outcome: 'correct' | 'incorrect' | 'partial';
  actual_direction: 'up' | 'down' | 'flat';
}

/**
 * Mock prediction data for injection
 */
export interface MockPredictionData {
  target_id: string;
  direction: 'up' | 'down' | 'flat';
  confidence: number;
  magnitude: 'small' | 'medium' | 'large';
  reasoning: string;
  timeframe_hours: number;
  entry_price?: number;
  target_price?: number;
  stop_loss?: number;
}

/**
 * Scenario run status lifecycle
 * - pending: Created but not yet started
 * - running: Currently executing
 * - completed: Successfully finished
 * - failed: Execution failed
 */
export type ScenarioRunStatus = 'pending' | 'running' | 'completed' | 'failed';

/**
 * Scenario run entity - tracks execution of a test scenario
 * Based on prediction.scenario_runs table
 */
export interface ScenarioRun {
  id: string;
  organization_slug: string;
  scenario_id: string;
  status: ScenarioRunStatus;
  started_at: string | null;
  completed_at: string | null;
  triggered_by: string | null;
  version_info: Record<string, unknown>;
  outcome_expected: Record<string, unknown>;
  outcome_actual: Record<string, unknown> | null;
  outcome_match: boolean | null;
  error_message: string | null;
  created_at: string;
}

/**
 * Data for creating a new scenario run
 */
export interface CreateScenarioRunData {
  id?: string;
  organization_slug: string;
  scenario_id: string;
  triggered_by?: string;
  version_info?: Record<string, unknown>;
  outcome_expected?: Record<string, unknown>;
}

/**
 * Data for updating a scenario run
 */
export interface UpdateScenarioRunData {
  status?: ScenarioRunStatus;
  started_at?: string;
  completed_at?: string;
  outcome_actual?: Record<string, unknown> | null;
  outcome_match?: boolean | null;
  error_message?: string | null;
}

/**
 * Valid audit action types
 */
export type AuditAction =
  | 'scenario_created'
  | 'scenario_updated'
  | 'scenario_deleted'
  | 'scenario_run_started'
  | 'scenario_run_completed'
  | 'scenario_run_failed'
  | 'learning_promoted'
  | 'learning_rejected'
  | 'data_injected'
  | 'data_cleaned';

/**
 * Valid resource types for audit log
 */
export type AuditResourceType =
  | 'test_scenario'
  | 'scenario_run'
  | 'learning'
  | 'injection';

/**
 * Test audit log entry - tracks audit trail for test operations
 * Based on prediction.test_audit_log table
 */
export interface TestAuditLogEntry {
  id: string;
  organization_slug: string;
  user_id: string;
  action: string;
  resource_type: string;
  resource_id: string;
  details: Record<string, unknown>;
  created_at: string;
}

/**
 * Data for creating a new audit log entry
 */
export interface CreateAuditLogData {
  id?: string;
  organization_slug: string;
  user_id: string;
  action: string;
  resource_type: string;
  resource_id: string;
  details?: Record<string, unknown>;
}

/**
 * Filter options for audit log queries
 */
export interface AuditLogFilter {
  /** Filter by specific action */
  action?: string;
  /** Filter by resource type */
  resource_type?: string;
  /** Filter by resource ID */
  resource_id?: string;
  /** Filter by user ID */
  user_id?: string;
  /** Start date for date range filter */
  start_date?: string;
  /** End date for date range filter */
  end_date?: string;
  /** Limit number of results */
  limit?: number;
}
