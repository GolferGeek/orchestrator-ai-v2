/**
 * Test Data Injection Framework Interfaces
 * Phase 3 of Financial Asset Predictor PRD
 */

/**
 * Test scenario status lifecycle
 * - active: Created but not yet running
 * - running: Currently executing
 * - completed: Successfully finished
 * - failed: Execution failed
 * - archived: No longer active
 */
export type TestScenarioStatus =
  | 'active'
  | 'running'
  | 'completed'
  | 'failed'
  | 'archived';

/**
 * Valid injection points (prediction schema table names)
 */
export type InjectionPoint =
  | 'strategies'
  | 'universes'
  | 'targets'
  | 'sources'
  | 'source_crawls'
  | 'source_seen_items'
  | 'signal_fingerprints'
  | 'signals'
  | 'predictors'
  | 'predictions'
  | 'snapshots'
  | 'evaluations'
  | 'target_snapshots'
  | 'missed_opportunities'
  | 'tool_requests'
  | 'analysts'
  | 'learnings'
  | 'learning_queue'
  | 'review_queue'
  | 'test_articles'
  | 'test_price_data';

/**
 * Test scenario entity - tracks a test data injection scenario
 * Based on prediction.test_scenarios table
 */
export interface TestScenario {
  id: string;
  name: string;
  description: string | null;
  injection_points: InjectionPoint[];
  target_id: string | null;
  organization_slug: string;
  config: TestScenarioConfig;
  created_by: string | null;
  status: TestScenarioStatus;
  results: TestScenarioResults | null;
  created_at: string;
  started_at: string | null;
  completed_at: string | null;
}

/**
 * Configuration for a test scenario
 */
export interface TestScenarioConfig extends Record<string, unknown> {
  /** Whether to run tier runners after injection */
  auto_run_tiers?: boolean;
  /** Which tiers to run automatically */
  tiers_to_run?: string[];
  /** Custom configuration per tier */
  tier_config?: Record<string, unknown>;
  /** Source missed opportunity ID (if generated from missed opportunity) */
  source_missed_opportunity_id?: string;
  /** Source learning ID (if generated from learning) */
  source_learning_id?: string;
  /** Source evaluation ID (if generated from evaluation) */
  source_evaluation_id?: string | null;
  /** Expected outcome for the scenario */
  expected_outcome?: Record<string, unknown>;
  /** Scenario type */
  scenario_type?: string;
  /** Learning type (if generated from learning) */
  learning_type?: string;
}

/**
 * Results from a test scenario execution
 */
export interface TestScenarioResults {
  /** Number of items injected per table */
  items_injected?: Record<string, number>;
  /** Number of items generated by tier runners */
  items_generated?: Record<string, number>;
  /** Tier execution results */
  tier_results?: Record<
    string,
    {
      success: boolean;
      processed: number;
      created: number;
      errors: string[];
    }
  >;
  /** Any errors that occurred */
  errors?: string[];
}

/**
 * Data for creating a new test scenario
 */
export interface CreateTestScenarioData {
  name: string;
  description?: string;
  injection_points: InjectionPoint[];
  target_id?: string;
  organization_slug: string;
  config?: TestScenarioConfig;
  created_by?: string;
}

/**
 * Data for updating a test scenario
 */
export interface UpdateTestScenarioData {
  name?: string;
  description?: string;
  injection_points?: InjectionPoint[];
  target_id?: string | null;
  config?: TestScenarioConfig;
  status?: TestScenarioStatus;
  results?: TestScenarioResults;
  started_at?: string;
  completed_at?: string;
}

/**
 * Filter for including/excluding test data in queries
 * Used by all prediction repositories
 */
export interface TestDataFilter {
  /**
   * Whether to include test data in results
   * Default: false (test data excluded)
   */
  includeTestData?: boolean;

  /**
   * Filter to a specific test scenario only
   * When set, only data from this scenario is returned
   */
  testScenarioId?: string;

  /**
   * Only return test data (exclude production data)
   * Useful for viewing test scenario results
   */
  testDataOnly?: boolean;
}

/**
 * Base interface for entities with test data markers
 * All prediction entities should extend this
 */
export interface TestDataMarkers {
  /** Whether this record is test data */
  is_test_data?: boolean;
  /** ID of the test scenario this record belongs to */
  test_scenario_id?: string | null;
}

/**
 * Generic injection data - adds test markers to any entity
 */
export type WithTestMarkers<T> = T & TestDataMarkers;

/**
 * Result from cleanup operations
 */
export interface CleanupResult {
  /** Tables that had data deleted */
  tables_cleaned: Array<{
    table_name: string;
    rows_deleted: number;
  }>;
  /** Total rows deleted */
  total_deleted: number;
}

/**
 * Result from a tier runner execution on test data
 */
export interface TierRunResult {
  /** Whether the tier completed successfully */
  success: boolean;
  /** Number of items processed */
  items_processed: number;
  /** Number of items created */
  items_created: number;
  /** Duration in milliseconds */
  duration_ms: number;
  /** Any errors that occurred */
  errors: string[];
}

/**
 * Summary of a test scenario with data counts
 */
export interface TestScenarioSummary extends TestScenario {
  /** Counts of test data per table */
  data_counts: Record<string, number>;
}

/**
 * Configuration for generating mock signals
 */
export interface MockSignalConfig {
  /** Number of signals to generate */
  count: number;
  /** Target ID for the signals */
  target_id: string;
  /** Source ID for the signals */
  source_id: string;
  /** Distribution of signal directions */
  distribution?: {
    bullish: number;
    bearish: number;
    neutral: number;
  };
  /** Topic for content generation */
  topic?: string;
}

/**
 * Configuration for generating mock predictions with known outcomes
 */
export interface MockPredictionConfig {
  /** Number of predictions to generate */
  count: number;
  /** Target ID for the predictions */
  target_id: string;
  /** Expected accuracy rate (0.0 - 1.0) */
  accuracy_rate: number;
  /** Distribution of prediction directions */
  distribution?: {
    up: number;
    down: number;
    flat: number;
  };
}

/**
 * Configuration for generating mock articles
 */
export interface MockArticleConfig {
  /** Number of articles to generate */
  count: number;
  /** Topic for the articles */
  topic: string;
  /** Overall sentiment */
  sentiment?: 'bullish' | 'bearish' | 'mixed';
  /** Source type */
  source_type?: 'web' | 'rss' | 'twitter_search' | 'api';
}

/**
 * A generated mock article
 */
export interface MockArticle {
  title: string;
  content: string;
  url: string;
  published_at: string;
  author?: string;
  source_name?: string;
}

/**
 * A prediction with its known outcome for testing
 */
export interface MockPredictionWithOutcome {
  prediction: MockPredictionData;
  outcome: 'correct' | 'incorrect' | 'partial';
  actual_direction: 'up' | 'down' | 'flat';
}

/**
 * Mock prediction data for injection
 */
export interface MockPredictionData {
  target_id: string;
  direction: 'up' | 'down' | 'flat';
  confidence: number;
  magnitude: 'small' | 'medium' | 'large';
  reasoning: string;
  timeframe_hours: number;
  entry_price?: number;
  target_price?: number;
  stop_loss?: number;
}

/**
 * Scenario run status lifecycle
 * - pending: Created but not yet started
 * - running: Currently executing
 * - completed: Successfully finished
 * - failed: Execution failed
 */
export type ScenarioRunStatus = 'pending' | 'running' | 'completed' | 'failed';

/**
 * Scenario run entity - tracks execution of a test scenario
 * Based on prediction.scenario_runs table
 */
export interface ScenarioRun {
  id: string;
  organization_slug: string;
  scenario_id: string;
  status: ScenarioRunStatus;
  started_at: string | null;
  completed_at: string | null;
  triggered_by: string | null;
  version_info: Record<string, unknown>;
  outcome_expected: Record<string, unknown>;
  outcome_actual: Record<string, unknown> | null;
  outcome_match: boolean | null;
  error_message: string | null;
  created_at: string;
}

/**
 * Data for creating a new scenario run
 */
export interface CreateScenarioRunData {
  id?: string;
  organization_slug: string;
  scenario_id: string;
  triggered_by?: string;
  version_info?: Record<string, unknown>;
  outcome_expected?: Record<string, unknown>;
}

/**
 * Data for updating a scenario run
 */
export interface UpdateScenarioRunData {
  status?: ScenarioRunStatus;
  started_at?: string;
  completed_at?: string;
  outcome_actual?: Record<string, unknown> | null;
  outcome_match?: boolean | null;
  error_message?: string | null;
}

/**
 * Valid audit action types
 */
export type AuditAction =
  | 'scenario_created'
  | 'scenario_updated'
  | 'scenario_deleted'
  | 'scenario_run_started'
  | 'scenario_run_completed'
  | 'scenario_run_failed'
  | 'learning_promoted'
  | 'learning_rejected'
  | 'data_injected'
  | 'data_cleaned';

/**
 * Valid resource types for audit log
 */
export type AuditResourceType =
  | 'test_scenario'
  | 'scenario_run'
  | 'learning'
  | 'injection';

/**
 * Test audit log entry - tracks audit trail for test operations
 * Based on prediction.test_audit_log table
 */
export interface TestAuditLogEntry {
  id: string;
  organization_slug: string;
  user_id: string;
  action: string;
  resource_type: string;
  resource_id: string;
  details: Record<string, unknown>;
  created_at: string;
}

/**
 * Data for creating a new audit log entry
 */
export interface CreateAuditLogData {
  id?: string;
  organization_slug: string;
  user_id: string;
  action: string;
  resource_type: string;
  resource_id: string;
  details?: Record<string, unknown>;
}

/**
 * Filter options for audit log queries
 */
export interface AuditLogFilter {
  /** Filter by specific action */
  action?: string;
  /** Filter by resource type */
  resource_type?: string;
  /** Filter by resource ID */
  resource_id?: string;
  /** Filter by user ID */
  user_id?: string;
  /** Start date for date range filter */
  start_date?: string;
  /** End date for date range filter */
  end_date?: string;
  /** Limit number of results */
  limit?: number;
}

// =============================================================================
// PHASE 8: HISTORICAL REPLAY TEST TYPES
// =============================================================================

/**
 * Replay test status lifecycle
 * - pending: Created but not started
 * - snapshot_created: Snapshot taken, ready to run
 * - running: Pipeline executing
 * - completed: Finished successfully
 * - failed: Failed at some step
 * - restored: Original data restored (cleanup complete)
 */
export type ReplayTestStatus =
  | 'pending'
  | 'snapshot_created'
  | 'running'
  | 'completed'
  | 'failed'
  | 'restored';

/**
 * Rollback depth options
 * - predictions: Only predictions rolled back
 * - predictors: Predictions + predictors rolled back
 * - signals: Signals + predictors + predictions rolled back
 */
export type RollbackDepth = 'predictions' | 'predictors' | 'signals';

/**
 * Configuration for a replay test
 */
export interface ReplayTestConfig extends Record<string, unknown> {
  /** Whether to auto-run pipeline after snapshot */
  auto_run?: boolean;
  /** Skip confirmation dialogs (for programmatic use) */
  skip_confirmation?: boolean;
  /** Mark replay predictions as test data instead of deleting */
  keep_replay_predictions?: boolean;
}

/**
 * Aggregated results from a replay test
 */
export interface ReplayTestResults {
  /** Total number of predictions compared */
  total_comparisons: number;
  /** Number of direction matches between original and replay */
  direction_matches: number;
  /** Number of originally correct predictions */
  original_correct_count: number;
  /** Number of replay predictions that were correct */
  replay_correct_count: number;
  /** Number of cases where replay improved on original */
  improvements: number;
  /** Original accuracy percentage */
  original_accuracy_pct: number | null;
  /** Replay accuracy percentage */
  replay_accuracy_pct: number | null;
  /** Accuracy improvement (replay - original) */
  accuracy_delta: number | null;
  /** Total P&L from original predictions */
  total_pnl_original: number | null;
  /** Total P&L from replay predictions */
  total_pnl_replay: number | null;
  /** P&L improvement */
  pnl_delta: number | null;
  /** Average confidence difference */
  avg_confidence_diff: number | null;
}

/**
 * Replay test entity
 * Based on prediction.replay_tests table
 */
export interface ReplayTest {
  id: string;
  organization_slug: string;
  name: string;
  description: string | null;
  status: ReplayTestStatus;
  rollback_depth: RollbackDepth;
  rollback_to: string;
  universe_id: string | null;
  target_ids: string[] | null;
  config: ReplayTestConfig;
  results: ReplayTestResults | null;
  error_message: string | null;
  created_by: string | null;
  created_at: string;
  started_at: string | null;
  completed_at: string | null;
}

/**
 * Data for creating a new replay test
 */
export interface CreateReplayTestData {
  name: string;
  description?: string;
  organization_slug: string;
  rollback_depth: RollbackDepth;
  rollback_to: string;
  universe_id: string;
  target_ids?: string[];
  config?: ReplayTestConfig;
  created_by?: string;
}

/**
 * Data for updating a replay test
 */
export interface UpdateReplayTestData {
  name?: string;
  description?: string;
  status?: ReplayTestStatus;
  results?: ReplayTestResults | null;
  error_message?: string | null;
  started_at?: string | null;
  completed_at?: string | null;
}

/**
 * Replay test snapshot entity
 * Stores original data before deletion
 */
export interface ReplayTestSnapshot {
  id: string;
  replay_test_id: string;
  table_name: 'signals' | 'predictors' | 'predictions' | 'analyst_assessments';
  original_data: unknown[];
  record_ids: string[];
  row_count: number;
  created_at: string;
}

/**
 * Per-prediction comparison result
 */
export interface ReplayTestResult {
  id: string;
  replay_test_id: string;
  target_id: string | null;

  // Original prediction data
  original_prediction_id: string | null;
  original_direction: string | null;
  original_confidence: number | null;
  original_magnitude: string | null;
  original_predicted_at: string | null;

  // Replay prediction data
  replay_prediction_id: string | null;
  replay_direction: string | null;
  replay_confidence: number | null;
  replay_magnitude: string | null;
  replay_predicted_at: string | null;

  // Comparison metrics
  direction_match: boolean | null;
  confidence_diff: number | null;

  // Ground truth
  evaluation_id: string | null;
  actual_outcome: string | null;
  actual_outcome_value: number | null;

  // Accuracy assessment
  original_correct: boolean | null;
  replay_correct: boolean | null;
  improvement: boolean | null;

  // P&L comparison
  pnl_original: number | null;
  pnl_replay: number | null;
  pnl_diff: number | null;

  created_at: string;
}

/**
 * Replay test summary with aggregated metrics
 * Based on prediction.replay_test_summary view
 */
export interface ReplayTestSummary extends ReplayTest {
  /** Total number of comparisons */
  total_comparisons: number;
  /** Direction matches count */
  direction_matches: number;
  /** Original correct count */
  original_correct_count: number;
  /** Replay correct count */
  replay_correct_count: number;
  /** Number of improvements */
  improvements: number;
  /** Original accuracy percentage */
  original_accuracy_pct: number | null;
  /** Replay accuracy percentage */
  replay_accuracy_pct: number | null;
  /** Total original P&L */
  total_pnl_original: number | null;
  /** Total replay P&L */
  total_pnl_replay: number | null;
  /** Total P&L improvement */
  total_pnl_improvement: number | null;
  /** Average confidence difference */
  avg_confidence_diff: number | null;
}

/**
 * Records that would be affected by a replay test
 */
export interface ReplayAffectedRecords {
  table_name: string;
  record_ids: string[];
  row_count: number;
}
